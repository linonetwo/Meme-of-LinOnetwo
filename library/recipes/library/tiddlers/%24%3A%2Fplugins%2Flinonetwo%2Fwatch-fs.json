{"title":"$:/plugins/linonetwo/watch-fs","description":"Reload changed tiddlers from disc","author":"LinOnetwo","core-version":">=5.1.22","plugin-type":"plugin","version":"0.0.1","list":"readme","dependents":"","type":"application/json","text":"{\n    \"tiddlers\": {\n        \"$:/plugins/linonetwo/watch-fs/FileSystemMonitor.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/FileSystemMonitor.js\",\n            \"text\": \"/*\\\\\\n  title: $:/plugins/linonetwo/watch-fs/FileSystemMonitor.js\\n  type: application/javascript\\n  module-type: startup\\n\\n  !! About\\n\\n  This module watches the file system in the tiddlers folder and any changes to\\n  the files in the folder that don't come from the browser are reported to the\\n  browser. So if you make a new .tid file in the tiddlers folder it will appear\\n  in the wiki in the browser without needing to restart the server. You can also\\n  delete files to remove the tiddlers from the browser.\\n\\n  !! How to decide whether a change is comes from the browser?\\n\\n  We will compare disk file and wiki file, if there is any discrepancy,\\n  then the change is not made by the wiki, it is made by git or VSCode.\\n\\n  This file is modified based on $:/plugins/OokTech/Bob/FileSystemMonitor.js\\n\\\\*/\\n\\nfunction FileSystemMonitor() {\\n  exports.name = 'FileSystemMonitor';\\n  exports.after = ['load-modules'];\\n  exports.platforms = ['node'];\\n  exports.synchronous = true;\\n\\n  // this allow us to test this module in nodejs directly without \\\"ReferenceError: $tw is not defined\\\"\\n  var $tw = this.$tw || { node: true };\\n\\n  if ($tw.node && !($tw?.settings?.disableFileWatchers === 'yes')) {\\n    const deepEqual = require('./deep-equal');\\n    // use node-watch\\n    const watch = require('./watch');\\n    const watcher = watch('./Meme-of-LinOnetwo/tiddlers', { recursive: true, delay: 500 }, listener);\\n\\n    /**\\n     * $tw.boot.files: {\\n     *   [tiddlerTitle: string]: {\\n     *     filepath: '/Users/linonetwo/xxxx/wiki/Meme-of-LinOnetwo/tiddlers/tiddlerTitle.tid',\\n     *     type: 'application/x-tiddler',\\n     *     hasMetaFile: false\\n     *   }\\n     * }\\n     */\\n    const initialLoadedFiles = $tw.boot.files;\\n\\n    /**\\n     * we can use this for getTitleByPath\\n     * {\\n     *   [filepath: string]: {\\n     *     filepath: '/Users/linonetwo/xxxx/wiki/Meme-of-LinOnetwo/tiddlers/tiddlerTitle.tid',\\n     *     tiddlerTitle: string,\\n     *     type: 'application/x-tiddler',\\n     *     hasMetaFile: false\\n     *   }\\n     * }\\n     */\\n    const inverseFilesIndex = {};\\n    // initialize the inverse index\\n    for (const tiddlerTitle in initialLoadedFiles) {\\n      const fileDescriptor = initialLoadedFiles[tiddlerTitle];\\n      inverseFilesIndex[fileDescriptor.filepath] = { ...fileDescriptor, tiddlerTitle };\\n    }\\n\\n    const updateInverseIndex = (filePath, fileDescriptor) => {\\n      inverseFilesIndex[filePath] = fileDescriptor;\\n    };\\n\\n    const filePathExistsInWiki = (filePath) => !!inverseFilesIndex[filePath];\\n    const getTitleByPath = (filePath) => {\\n      try {\\n        return inverseFilesIndex[filePath].tiddlerTitle;\\n      } catch (error) {\\n        // fatal error, shutting down.\\n        watcher.close();\\n        throw new Error(`${filePath}\\\\nâ†‘ not existed in watch-fs plugin's FileSystemMonitor's inverseFilesIndex`);\\n      }\\n    };\\n\\n    /**\\n     * This watches for changes to a folder and updates the wiki when anything changes in the folder.\\n     *\\n     * The filePath reported by listener is not the actual tiddler name, and all tiddlywiki operations requires that we have the name of tiddler,\\n     * So we have get tiddler name by path from `$tw.boot.files`.\\n     *\\n     * Then we can perform following logic:\\n     * File update -> update or create tiddler using `$tw.syncadaptor.wiki.addTiddler`\\n     * File remove & tiddler exist in wiki -> then remove tiddler using `$tw.syncadaptor.wiki.deleteTiddler`\\n     * File remove & tiddler not exist in wiki -> This change is caused by tiddlywiki itself, do noting here\\n     *\\n     * @param {\\\"update\\\" | \\\"remove\\\"} event\\n     * @param {*} filePath changed file's relative path to the folder executing this watcher\\n     */\\n    function listener(event, filePath) {\\n      console.log('%s changed.', filePath, event);\\n      // on create or modify\\n      if (event == 'update') {\\n        // get tiddler from the disk\\n        /**\\n         * tiddlersDescriptor:\\n         * {\\n         *    \\\"filepath\\\": \\\"Meme-of-LinOnetwo/tiddlers/$__StoryList.tid\\\",\\n         *    \\\"type\\\": \\\"application/x-tiddler\\\",\\n         *    \\\"tiddlers\\\": [\\n         *      {\\n         *        \\\"title\\\": \\\"$:/StoryList\\\",\\n         *        \\\"list\\\": \\\"Index\\\"\\n         *      }\\n         *    ],\\n         *    \\\"hasMetaFile\\\": false\\n         *  }\\n         */\\n        const [tiddlersDescriptor] = $tw.loadTiddlersFromPath(filePath);\\n        const { tiddlers, ...fileDescriptor } = tiddlersDescriptor;\\n        // if user is using git or VSCode to create new file in the disk, that is not yet exist in the wiki\\n        if (!filePathExistsInWiki(filePath)) {\\n          tiddlers.forEach((tiddler) => {\\n            updateInverseIndex(filePath, { ...fileDescriptor, tiddlerTitle: tiddler.title });\\n            $tw.syncadaptor.wiki.addTiddler(tiddler);\\n          });\\n        } else {\\n          // if it already existed in the wiki, this change might due to our last call to `$tw.syncadaptor.wiki.addTiddler`,\\n          // so we have to check whether tiddler in the disk is identical to the one in the wiki, if so, we ignore it.\\n          tiddlers\\n            .filter((tiddler) => {\\n              const { fields: tiddlerInWiki } = $tw.syncadaptor.wiki.getTiddler(tiddler.title);\\n              // console.warn(`tiddler`, tiddler);\\n              // console.warn(`tiddlerInWiki`, tiddlerInWiki);\\n              // console.log('deepEqual(tiddler, tiddlerInWiki)', deepEqual(tiddler, tiddlerInWiki))\\n              return !deepEqual(tiddler, tiddlerInWiki);\\n            })\\n            // then we update wiki with each newly created tiddler\\n            .forEach((tiddler) => {\\n              $tw.syncadaptor.wiki.addTiddler(tiddler);\\n            });\\n        }\\n        const tiddlerTitle = getTitleByPath(filePath);\\n      }\\n\\n      // on delete\\n      if (event == 'remove') {\\n        const tiddlerTitle = getTitleByPath(filePath);\\n        console.log(tiddlerTitle);\\n      }\\n    }\\n  }\\n}\\nFileSystemMonitor();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\",\n            \"creator\": \"LinOnetwo\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/deep-equal.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/deep-equal.js\",\n            \"text\": \"module.exports = function deepEqual(x, y) {\\n  if (x === y) {\\n    return true;\\n  } else if (titleListEqual(x, y)) {\\n    // handle title list https://tiddlywiki.com/#Title%20List\\n    /* tiddler {\\n      \\\"title\\\": \\\"$:/StoryList\\\",\\n      \\\"list\\\": \\\"Index\\\"\\n    }\\n    tiddlerInWiki {\\n      \\\"title\\\": \\\"$:/StoryList\\\",\\n      \\\"list\\\": [\\n        \\\"Index\\\"\\n      ]\\n    } */\\n    return true;\\n  } else if (timeStampEqual(x, y)) {\\n    // handles time stamp format\\n    /* tiddler {\\n      \\\"title\\\": \\\"$:/StoryList\\\",\\n      \\\"created\\\": \\\"20200806161101351\\\",\\n      \\\"list\\\": \\\"Index\\\",\\n      \\\"modified\\\": \\\"20200806161101351\\\",\\n      \\\"type\\\": \\\"text/vnd.tiddlywiki\\\"\\n    }\\n    tiddlerInWiki {\\n      \\\"title\\\": \\\"$:/StoryList\\\",\\n      \\\"created\\\": \\\"2020-08-06T16:11:01.351Z\\\",\\n      \\\"list\\\": [\\n        \\\"Index\\\"\\n      ],\\n      \\\"modified\\\": \\\"2020-08-06T16:11:01.351Z\\\",\\n      \\\"type\\\": \\\"text/vnd.tiddlywiki\\\"\\n    } */\\n    return true;\\n  } else if (typeof x === 'object' && x !== null && typeof y === 'object' && y !== null) {\\n    if (Object.keys(x).length != Object.keys(y).length) return false;\\n\\n    for (var prop in x) {\\n      if (!deepEqual(x[prop], y[prop])) return false;\\n    }\\n\\n    return true;\\n  } else {\\n    return false;\\n  }\\n};\\n\\nfunction titleListEqual(x, y) {\\n  // y is like \\\"GettingStarted [[Discover TiddlyWiki]] Upgrading\\\", and x is an array\\n  if (typeof x === 'string' && Array.isArray(y)) {\\n    // $tw.utils.parseStringArray is heavy, so we use $tw.utils.stringifyList instead\\n    return $tw.utils.stringifyList(y) === x;\\n  } else if (typeof y === 'string' && Array.isArray(x)) {\\n    return $tw.utils.stringifyList(x) === y;\\n  }\\n  return false;\\n}\\n\\nfunction timeStampEqual(x, y) {\\n  // strangely, `created` and `modified` field is not instanceof Date, so have to use x === 'object' to check it\\n  if (typeof y === 'object' && y.toString && Object.keys(y).length === 0 && typeof x === 'string') {\\n    return JSON.stringify(y).replace(/[\\\"\\\\-T:Z.]/g, '') === x;\\n  } else if (typeof x === 'object' && x.toString && Object.keys(x).length === 0 && typeof y === 'string') {\\n    return JSON.stringify(x).replace(/[\\\"\\\\-T:Z.]/g, '') === y;\\n  } else if (typeof x === 'string' && typeof y === 'string') {\\n    return x.replace(/[\\\\-T:Z.]/g, '') === y || y.replace(/[\\\\-T:Z.]/g, '') === x;\\n  }\\n  return false;\\n}\\n\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/has-native-recursive.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/has-native-recursive.js\",\n            \"text\": \"var fs = require('fs');\\nvar os = require('os');\\nvar path = require('path');\\nvar is = require('./is');\\n\\nvar IS_SUPPORT;\\nvar TEMP_DIR = os.tmpdir && os.tmpdir()\\n  || process.env.TMPDIR\\n  || process.env.TEMP\\n  || process.cwd();\\n\\nfunction TempStack() {\\n  this.stack = [];\\n}\\n\\nTempStack.prototype = {\\n  create: function(type, base) {\\n    var name = path.join(base,\\n      'node-watch-' + Math.random().toString(16).substr(2)\\n    );\\n    this.stack.push({ name: name, type: type });\\n    return name;\\n  },\\n  write: function(/* file */) {\\n    for (var i = 0; i < arguments.length; ++i) {\\n      fs.writeFileSync(arguments[i], ' ');\\n    }\\n  },\\n  mkdir: function(/* dirs */) {\\n    for (var i = 0; i < arguments.length; ++i) {\\n      fs.mkdirSync(arguments[i]);\\n    }\\n  },\\n  cleanup: function(fn) {\\n    try {\\n      var temp;\\n      while ((temp = this.stack.pop())) {\\n        var type = temp.type;\\n        var name = temp.name;\\n        if (type === 'file' && is.file(name)) {\\n          fs.unlinkSync(name);\\n        }\\n        else if (type === 'dir' && is.directory(name)) {\\n          fs.rmdirSync(name);\\n        }\\n      }\\n    }\\n    finally {\\n      if (is.func(fn)) fn();\\n    }\\n  }\\n};\\n\\nvar pending = false;\\n\\nmodule.exports = function hasNativeRecursive(fn) {\\n  if (!is.func(fn)) {\\n    return false;\\n  }\\n  if (IS_SUPPORT !== undefined) {\\n    return fn(IS_SUPPORT);\\n  }\\n\\n  if (!pending) {\\n    pending = true;\\n  }\\n  // check again later\\n  else {\\n    return setTimeout(function() {\\n      hasNativeRecursive(fn);\\n    }, 300);\\n  }\\n\\n  var stack = new TempStack();\\n  var parent = stack.create('dir', TEMP_DIR);\\n  var child = stack.create('dir', parent);\\n  var file = stack.create('file', child);\\n\\n  stack.mkdir(parent, child);\\n\\n  var options = { recursive: true };\\n  var watcher;\\n\\n  try {\\n    watcher = fs.watch(parent, options);\\n  } catch (e) {\\n    if (e.code == 'ERR_FEATURE_UNAVAILABLE_ON_PLATFORM') {\\n      return fn(IS_SUPPORT = false);\\n    } else {\\n      throw e;\\n    }\\n  }\\n\\n  if (!watcher) {\\n    return false;\\n  }\\n\\n  var timer = setTimeout(function() {\\n    watcher.close();\\n    stack.cleanup(function() {\\n      fn(IS_SUPPORT = false);\\n    });\\n  }, 200);\\n\\n  watcher.on('change', function(evt, name) {\\n    if (path.basename(file) === path.basename(name)) {\\n      watcher.close();\\n      clearTimeout(timer);\\n      stack.cleanup(function() {\\n        fn(IS_SUPPORT = true);\\n      });\\n    }\\n  });\\n  stack.write(file);\\n}\\n\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/is.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/is.js\",\n            \"text\": \"var fs = require('fs');\\nvar path = require('path');\\nvar os = require('os');\\n\\nfunction matchObject(item, str) {\\n  return Object.prototype.toString.call(item)\\n    === '[object ' + str + ']';\\n}\\n\\nfunction checkStat(name, fn) {\\n  try {\\n    return fn(name);\\n  } catch (err) {\\n    if (/^(ENOENT|EPERM|EACCES)$/.test(err.code)) {\\n      if (err.code !== 'ENOENT') {\\n        console.warn('Warning: Cannot access %s', name);\\n      }\\n      return false;\\n    }\\n    throw err;\\n  }\\n}\\n\\nvar is = {\\n  nil: function(item) {\\n    return item == null;\\n  },\\n  array: function(item) {\\n    return Array.isArray(item);\\n  },\\n  emptyObject: function(item) {\\n    for (var key in item) {\\n      return false;\\n    }\\n    return true;\\n  },\\n  buffer: function(item) {\\n    return Buffer.isBuffer(item);\\n  },\\n  regExp: function(item) {\\n    return matchObject(item, 'RegExp');\\n  },\\n  string: function(item) {\\n    return matchObject(item, 'String');\\n  },\\n  func: function(item) {\\n    return typeof item === 'function';\\n  },\\n  number: function(item) {\\n    return matchObject(item, 'Number');\\n  },\\n  exists: function(name) {\\n    return fs.existsSync(name);\\n  },\\n  file: function(name) {\\n    return checkStat(name, function(n) {\\n      return fs.statSync(n).isFile()\\n    });\\n  },\\n  samePath: function(a, b) {\\n    return path.resolve(a) === path.resolve(b);\\n  },\\n  directory: function(name) {\\n    return checkStat(name, function(n) {\\n      return fs.statSync(n).isDirectory()\\n    });\\n  },\\n  symbolicLink: function(name) {\\n    return checkStat(name, function(n) {\\n      return fs.lstatSync(n).isSymbolicLink();\\n    });\\n  },\\n  windows: function() {\\n    return os.platform() === 'win32';\\n  }\\n};\\n\\nmodule.exports = is;\\n\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/readme\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/readme\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"!! About\\n\\nThis plugin enables TiddlyWiki to watch the change in your disk, and if you edit one of your tiddler using editor likes VSCode and save it on the disk, the change will immediately reflected in the browser.\\n\\nSee https://github.com/Jermolene/TiddlyWiki5/issues/3060 for related discussions.\\n\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/watch.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/watch.js\",\n            \"text\": \"/**\\n * https://github.com/yuanchuan/node-watch\\n * @version 0.6.4\\n */\\nvar fs = require('fs');\\nvar path = require('path');\\nvar util = require('util');\\nvar events = require('events');\\n\\nvar hasNativeRecursive = require('./has-native-recursive');\\nvar is = require('./is');\\n\\nvar EVENT_UPDATE = 'update';\\nvar EVENT_REMOVE = 'remove';\\n\\nfunction hasDup(arr) {\\n  return arr.some(function(v, i, self) {\\n    return self.indexOf(v) !== i;\\n  });\\n}\\n\\nfunction unique(arr) {\\n  return arr.filter(function(v, i, self) {\\n    return self.indexOf(v) === i;\\n  });\\n}\\n\\nfunction assertEncoding(encoding) {\\n  if (encoding && encoding !== 'buffer' && !Buffer.isEncoding(encoding)) {\\n    throw new Error('Unknown encoding: ' + encoding);\\n  }\\n}\\n\\nfunction guard(fn) {\\n  return function(arg, action) {\\n    if (is.func(fn)) {\\n      if (fn(arg)) action();\\n    }\\n    else if (is.regExp(fn)) {\\n      if (fn.test(arg)) action();\\n    }\\n    else {\\n      action();\\n    }\\n  }\\n}\\n\\nfunction composeMessage(names) {\\n  return names.map(function(n) {\\n    return is.exists(n)\\n      ? [EVENT_UPDATE, n]\\n      : [EVENT_REMOVE, n];\\n  });\\n}\\n\\nfunction getMessages(cache) {\\n  var filtered = unique(cache);\\n\\n  // Saving file from an editor? If so, assuming the\\n  // non-existed files in the cache are temporary files\\n  // generated by an editor and thus be filtered.\\n  var reg = /~$|^\\\\.#|^##$/g;\\n  var hasSpecialChar = cache.some(function(c) {\\n    return reg.test(c);\\n  });\\n\\n  if (hasSpecialChar) {\\n    var dup = hasDup(cache.map(function(c) {\\n      return c.replace(reg, '');\\n    }));\\n    if (dup) {\\n      filtered = filtered.filter(function(m) {\\n        return is.exists(m);\\n      });\\n    }\\n  }\\n\\n  // Prevent redundant event for its parent when creating file/directory.\\n  // The operation is kinda expensive so only be triggered under Windows.\\n  // https://github.com/yuanchuan/node-watch/issues/79\\n  if (is.windows()) {\\n    var parents = filtered.map(function(n) {\\n      return path.parse(n).dir;\\n    });\\n    filtered = filtered.filter(function(n) {\\n      // Skip on removal\\n      if (!is.exists(n)) {\\n        return true;\\n      }\\n      // Ignore the parent directory\\n      return !parents.some(function(m) {\\n        return is.samePath(n, m);\\n      });\\n    });\\n  }\\n\\n  return composeMessage(filtered);\\n}\\n\\nfunction debounce(info, fn) {\\n  var timer, cache = [];\\n  var encoding = info.options.encoding;\\n  var delay = info.options.delay;\\n  if (!is.number(delay)) {\\n    delay = 200;\\n  }\\n  function handle() {\\n    getMessages(cache).forEach(function(msg) {\\n      msg[1] = Buffer.from(msg[1]);\\n      if (encoding !== 'buffer') {\\n        msg[1] = msg[1].toString(encoding);\\n      }\\n      fn.apply(null, msg);\\n    });\\n    timer = null;\\n    cache = [];\\n  }\\n  return function(rawEvt, name) {\\n    cache.push(name);\\n    if (!timer) {\\n      timer = setTimeout(handle, delay);\\n    }\\n  }\\n}\\n\\nfunction createDupsFilter() {\\n  var memo = {};\\n  return function(fn) {\\n    return function(evt, name) {\\n      memo[evt + name] = [evt, name];\\n      setTimeout(function() {\\n        Object.keys(memo).forEach(function(n) {\\n          fn.apply(null, memo[n]);\\n        });\\n        memo = {};\\n      });\\n    }\\n  }\\n}\\n\\nfunction getSubDirectories(dir, fn, done = function() {}) {\\n  if (is.directory(dir)) {\\n    fs.readdir(dir, function(err, all) {\\n      if (err) {\\n        // don't throw permission errors.\\n        if (/^(EPERM|EACCES)$/.test(err.code)) {\\n          console.warn('Warning: Cannot access %s.', dir);\\n        } else {\\n          throw err;\\n        }\\n      }\\n      else {\\n        all.forEach(function(f) {\\n          var sdir = path.join(dir, f);\\n          if (is.directory(sdir)) fn(sdir);\\n        });\\n        done();\\n      }\\n    });\\n  } else {\\n    done();\\n  }\\n}\\n\\nfunction semaphore(final) {\\n  var counter = 0;\\n  return function start() {\\n    counter++;\\n    return function stop() {\\n      counter--;\\n      if (counter === 0) final();\\n    };\\n  };\\n}\\n\\nfunction nullCounter() {\\n  return function nullStop() {};\\n}\\n\\nvar deprecationWarning = util.deprecate(\\n  function() {},\\n  '(node-watch) First param in callback function\\\\\\n  is replaced with event name since 0.5.0, use\\\\\\n  `(evt, filename) => {}` if you want to get the filename'\\n);\\n\\nfunction Watcher() {\\n  events.EventEmitter.call(this);\\n  this.watchers = {};\\n  this._isReady = false;\\n  this._isClosed = false;\\n}\\n\\nutil.inherits(Watcher, events.EventEmitter);\\n\\nWatcher.prototype.expose = function() {\\n  var self = this;\\n  var methods = [\\n    'on', 'emit', 'close', 'isClosed', 'listeners', 'once',\\n    'setMaxListeners', 'getMaxListeners'\\n  ];\\n  return methods.reduce(function(expose, name) {\\n    expose[name] = function() {\\n      return self[name].apply(self, arguments);\\n    }\\n    return expose;\\n  }, {});\\n}\\n\\nWatcher.prototype.isClosed = function() {\\n  return this._isClosed;\\n}\\n\\nWatcher.prototype.close = function(fullPath) {\\n  var self = this;\\n  if (fullPath) {\\n    var watcher = this.watchers[fullPath];\\n    if (watcher && watcher.close) {\\n      watcher.close();\\n      delete self.watchers[fullPath];\\n    }\\n    getSubDirectories(fullPath, function(fpath) {\\n      self.close(fpath);\\n    });\\n  }\\n  else {\\n    Object.keys(self.watchers).forEach(function(fpath) {\\n      var watcher = self.watchers[fpath];\\n      if (watcher && watcher.close) {\\n        watcher.close();\\n      }\\n    });\\n    this.watchers = {};\\n  }\\n  // Do not close the Watcher unless all child watchers are closed.\\n  // https://github.com/yuanchuan/node-watch/issues/75\\n  if (is.emptyObject(self.watchers)) {\\n    this._isClosed = true;\\n    process.nextTick(emitClose, this);\\n  }\\n};\\n\\nfunction emitReady(self) {\\n  if (!self._isReady) {\\n    self._isReady = true;\\n    // do not call emit for 'ready' until after watch() has returned,\\n    // so that consumer can call on().\\n    process.nextTick(function () {\\n      self.emit('ready');\\n    });\\n  }\\n}\\n\\nfunction emitClose(self) {\\n  self.emit('close');\\n}\\n\\nWatcher.prototype.add = function(watcher, info) {\\n  var self = this;\\n  info = info || { fpath: '' };\\n  var watcherPath = path.resolve(info.fpath);\\n  this.watchers[watcherPath] = watcher;\\n\\n  // Internal callback for handling fs.FSWatcher 'change' events\\n  var internalOnChange = function(rawEvt, rawName) {\\n    if (self.isClosed()) {\\n      return;\\n    }\\n\\n    // normalise lack of name and convert to full path\\n    var name = rawName;\\n    if (is.nil(name)) {\\n      name = '';\\n    }\\n    name = path.join(info.fpath, name);\\n\\n    if (info.options.recursive) {\\n      hasNativeRecursive(function(has) {\\n        if (!has) {\\n          var fullPath = path.resolve(name);\\n          // remove watcher on removal\\n          if (!is.exists(name)) {\\n            self.close(fullPath);\\n          }\\n          // watch new created directory\\n          else if (is.directory(name) && !self.watchers[fullPath]) {\\n            self.watchDirectory(name, info.options);\\n          }\\n        }\\n      });\\n    }\\n\\n    handlePublicEvents(rawEvt, name);\\n  };\\n\\n  // Debounced based on the 'delay' option\\n  var handlePublicEvents = debounce(info, function (evt, name) {\\n    // watch single file\\n    if (info.compareName) {\\n      if (info.compareName(name)) {\\n        self.emit('change', evt, name);\\n      }\\n    }\\n    // watch directory\\n    else {\\n      var filterGuard = guard(info.options.filter);\\n      filterGuard(name, function() {\\n        if (self.flag) self.flag = '';\\n        else self.emit('change', evt, name);\\n      });\\n    }\\n  });\\n\\n  watcher.on('error', function(err) {\\n    if (self.isClosed()) {\\n      return;\\n    }\\n    if (is.windows() && err.code === 'EPERM') {\\n      watcher.emit('change', EVENT_REMOVE, info.fpath && '');\\n      self.flag = 'windows-error';\\n      self.close(watcherPath);\\n    } else {\\n      self.emit('error', err);\\n    }\\n  });\\n\\n  watcher.on('change', internalOnChange);\\n}\\n\\nWatcher.prototype.watchFile = function(file, options, fn) {\\n  var parent = path.join(file, '../');\\n  var opts = Object.assign({}, options, {\\n    // no filter for single file\\n    filter: null,\\n    encoding: 'utf8'\\n  });\\n\\n  // no need to watch recursively\\n  delete opts.recursive;\\n\\n  var watcher = fs.watch(parent, opts);\\n  this.add(watcher, {\\n    type: 'file',\\n    fpath: parent,\\n    options: Object.assign({}, opts, {\\n      encoding: options.encoding\\n    }),\\n    compareName: function(n) {\\n      return is.samePath(n, file);\\n    }\\n  });\\n\\n  if (is.func(fn)) {\\n    if (fn.length === 1) deprecationWarning();\\n    this.on('change', fn);\\n  }\\n}\\n\\nWatcher.prototype.watchDirectory = function(dir, options, fn, counter = nullCounter) {\\n  var self = this;\\n  var done = counter();\\n  hasNativeRecursive(function(has) {\\n    // always specify recursive\\n    options.recursive = !!options.recursive;\\n    // using utf8 internally\\n    var opts = Object.assign({}, options, {\\n      encoding: 'utf8'\\n    });\\n    if (!has) {\\n      delete opts.recursive;\\n    }\\n\\n    var watcher = fs.watch(dir, opts);\\n\\n    self.add(watcher, {\\n      type: 'dir',\\n      fpath: dir,\\n      options: options\\n    });\\n\\n    if (is.func(fn)) {\\n      if (fn.length === 1) deprecationWarning();\\n      self.on('change', fn);\\n    }\\n\\n    if (options.recursive && !has) {\\n      getSubDirectories(dir, function(d) {\\n        self.watchDirectory(d, options, null, counter);\\n      }, counter());\\n    }\\n\\n    done();\\n  });\\n}\\n\\nfunction composeWatcher(watchers) {\\n  var watcher = new Watcher();\\n  var filterDups = createDupsFilter();\\n  var counter = watchers.length;\\n  watchers.forEach(function(w) {\\n    w.on('change', filterDups(function(evt, name) {\\n      watcher.emit('change', evt, name);\\n    }));\\n    w.on('error', function(err) {\\n      watcher.emit('error', err);\\n    });\\n    w.on('ready', function() {\\n      if (!(--counter)) {\\n        emitReady(watcher);\\n      }\\n    });\\n  });\\n\\n  watcher.close = function() {\\n    watchers.forEach(function(w) {\\n      w.close();\\n    });\\n    process.nextTick(emitClose, watcher);\\n  }\\n  return watcher.expose();\\n}\\n\\nfunction watch(fpath, options, fn) {\\n  var watcher = new Watcher();\\n\\n  if (is.buffer(fpath)) {\\n    fpath = fpath.toString();\\n  }\\n\\n  if (is.array(fpath)) {\\n    if (fpath.length === 1) {\\n      return watch(fpath[0], options, fn);\\n    }\\n    var filterDups = createDupsFilter();\\n    return composeWatcher(unique(fpath).map(function(f) {\\n      var w = watch(f, options);\\n      if (fn) w.on('change', filterDups(fn));\\n      return w;\\n    }));\\n  }\\n\\n  if (!is.exists(fpath)) {\\n    watcher.emit('error',\\n      new Error(fpath + ' does not exist.')\\n    );\\n  }\\n\\n  if (is.string(options)) {\\n    options = {\\n      encoding: options\\n    }\\n  }\\n\\n  if (is.func(options)) {\\n    fn = options;\\n    options = {};\\n  }\\n\\n  if (arguments.length < 2) {\\n    options = {};\\n  }\\n\\n  if (options.encoding) {\\n    assertEncoding(options.encoding);\\n  } else {\\n    options.encoding = 'utf8';\\n  }\\n\\n  if (is.file(fpath)) {\\n    watcher.watchFile(fpath, options, fn);\\n    emitReady(watcher);\\n  }\\n\\n  else if (is.directory(fpath)) {\\n    var counter = semaphore(function () {\\n      emitReady(watcher);\\n    });\\n    watcher.watchDirectory(fpath, options, fn, counter);\\n  }\\n\\n  return watcher.expose();\\n}\\n\\nmodule.exports = watch;\\nmodule.exports.default = watch;\\n\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        }\n    }\n}"}