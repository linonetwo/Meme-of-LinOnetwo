{"title":"$:/plugins/OokTech/Bob","description":"A plugin that real-time syncing between wiki and server, among other things","author":"inmysocks","version":"1.6.0b1","core-version":">=5.1.21","source":"","plugin-type":"plugin","list":"readme WebSocketMessages ActionWebSocketMessage OokTechInfo","dependents":"","type":"application/json","text":"{\n    \"tiddlers\": {\n        \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/.gitignore\": {\n            \"title\": \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/.gitignore\",\n            \"text\": \"*.DS_Store\\n*.borked\\n*.old\\n\",\n            \"type\": \"text/plain\"\n        },\n        \"$:/plugins/OokTech/Bob/action-convertwiki.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/action-convertwiki.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/action-convertwiki.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nAction widget to take an input html file and split it into a node wiki\\n\\n<$action-convertwiki $fileInput='#fileInput'/>\\n\\nwhere #fileInput is the name given to the file input html element used.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nconst ActionConvertWiki = function(parseTreeNode,options) {\\n  this.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nActionConvertWiki.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nActionConvertWiki.prototype.render = function(parent,nextSibling) {\\n  this.computeAttributes();\\n  this.execute();\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nActionConvertWiki.prototype.execute = function() {\\n  this.inputName = this.getAttribute('fileInput', \\\"#fileInput\\\");\\n  this.wikiFolder = this.getAttribute('wikiFolder', undefined);\\n  this.wikisPath = this.getAttribute('wikisPath', undefined);\\n  this.wikiName = this.getAttribute('wikiName', undefined);\\n  this.overwrite = this.getAttribute('overwrite', undefined);\\n};\\n\\n/*\\nRefresh the widget by ensuring our attributes are up to date\\n*/\\nActionConvertWiki.prototype.refresh = function(changedTiddlers) {\\n  const changedAttributes = this.computeAttributes();\\n  if(Object.keys(changedAttributes).length) {\\n    this.refreshSelf();\\n    return true;\\n  }\\n  return this.refreshChildren(changedTiddlers);\\n};\\n\\n/*\\nInvoke the action associated with this widget\\n*/\\nActionConvertWiki.prototype.invokeAction = function(triggeringWidget,event) {\\n  let self = this;\\n  // Find the file input html element, get the file from that.\\n  const fileElement = document.getElementById(this.inputName);\\n  if(fileElement) {\\n    const file = fileElement.files[0];\\n    const wikiName = $tw.wiki.getTiddlerText(\\\"$:/WikiName\\\");\\n    // Read the file and pass it to the parsing stuff\\n    if(file) {\\n      $tw.wiki.readFileContent(file, file.type, false, undefined, function (output) {\\n        if(output.length > 0) {\\n          const token = localStorage.getItem('ws-token')\\n          const message = {\\n            \\\"type\\\": \\\"newWikiFromTiddlers\\\",\\n            \\\"tiddlers\\\": output,\\n            \\\"wikisPath\\\": self.wikisPath,\\n            \\\"wikiName\\\": self.wikiName,\\n            \\\"wikiFolder\\\": self.wikiFolder,\\n            \\\"token\\\": token,\\n            \\\"wiki\\\": wikiName,\\n            \\\"overwrite\\\": self.overwrite\\n          }\\n          $tw.Bob.Shared.sendMessage(message, 0)\\n        } else {\\n          console.log(\\\"No tiddlers found in input file!\\\");\\n        }\\n      })\\n    }\\n    return true; // Action was invoked\\n  }\\n};\\n\\nexports[\\\"action-convertwiki\\\"] = ActionConvertWiki;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/OokTech/Bob/action-downloadwiki.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/action-downloadwiki.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/action-downloadwiki.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nAn action widget to download the current wiki with optinal filters on the\\noutput tiddlers.\\n\\n<$action-downloadwiki excludeFilter='excludeFilter' ignoreDefaultExclude=false/>\\n\\nyou can optionally give an include or exclude filter that lists tiddlers to\\ninclude/exclude from the built wiki. If none are given than all tiddlers in the\\nwiki are exported with the execption of the default exclude list (Bob and other\\nplugins that don't do anything for single file wikis.)\\n\\nalternatively you can give an include filter that lists all of the tiddlers to\\ninclude in the output wiki. If an include filter is given than the exclude\\nfilter input is ignored if it exists.\\n\\nIf you have some specific reason you can set ignoreDefaultExclude to true and\\nit will ignore the default set of tiddlers to exclude.\\n\\nUnless ignoreDefaultExclude is set than the default exclude list is used for\\nboth include and exclude filters.\\n\\n|!Parameter |!Description |\\n|!includeFilter |An optional filter that returns all tiddlers to inclued in the output wiki. If nothing is given than the whole wiki is included. |\\n|!excludeFilter |An optional filter that returns tiddlers to exclude from the downloaded wiki. If this lists a tiddler that is also returned by the includeFilter than the excludeFilter takes presidence. Defaults to an empty list so nothing is excluded. |\\n|!ignoreDefaultExclude |If this is set to `true` than the default exclude list is ignored. The default exclude list includes the Bob plugin and other things that either break single file wikis or do nothing in single file wikis, so don't set this unless you have a specific reason. |\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nconst ActionDownloadWiki = function(parseTreeNode,options) {\\n  this.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nActionDownloadWiki.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nActionDownloadWiki.prototype.render = function(parent,nextSibling) {\\n  this.computeAttributes();\\n  this.execute();\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nActionDownloadWiki.prototype.execute = function() {\\n  this.excludeFilter = this.getAttribute('excludeFilter',undefined)\\n  this.includeFilter = this.getAttribute('includeFilter',undefined)\\n  this.ignoreDefaultExclude = this.getAttribute('ignoreDefaultExclude', false)\\n  this.defaultName = this.getAttribute('defaultName', 'index.html')\\n  this.core = this.getAttribute('core', '$:/core')\\n};\\n\\n/*\\nRefresh the widget by ensuring our attributes are up to date\\n*/\\nActionDownloadWiki.prototype.refresh = function(changedTiddlers) {\\n  const changedAttributes = this.computeAttributes();\\n  if(Object.keys(changedAttributes).length) {\\n    this.refreshSelf();\\n    return true;\\n  }\\n  return this.refreshChildren(changedTiddlers);\\n};\\n\\n/*\\nInvoke the action associated with this widget\\n*/\\nActionDownloadWiki.prototype.invokeAction = function(triggeringWidget,event) {\\n  // Otherwise we want to ignore the server-specific plugins to keep things\\n  // small.\\n  let excludeList = ['$:/plugins/OokTech/Bob', '$:/plugins/tiddlywiki/filesystem', '$:/plugins/tiddlywiki/tiddlyweb'];\\n  if(this.excludeFilter) {\\n    excludeList = $tw.wiki.filterTiddlers(this.excludeFilter)\\n  }\\n\\n  if(this.ignoreDefaultExclude !== 'true') {\\n    const defaultExclude = $tw.wiki.filterTiddlers('[prefix[$:/plugins/OokTech/Bob/]][[$:/plugins/OokTech/Bob]][prefix[$:/WikiSettings]][prefix[$:/Bob/]][[$:/ServerIP]][[$:/plugins/tiddlywiki/filesystem]][[$:/plugins/tiddlywiki/tiddlyweb]]');\\n    excludeList = excludeList.concat(defaultExclude);\\n  }\\n\\n  let options = {};\\n  let tempWiki = new $tw.Wiki();\\n  // Load the boot tiddlers\\n  tempWiki.addTiddler($tw.wiki.getTiddler(this.core))\\n  tempWiki.addTiddler($tw.wiki.getTiddler('$:/boot/boot.css'))\\n  tempWiki.addTiddler($tw.wiki.getTiddler('$:/boot/boot.js'))\\n  tempWiki.addTiddler($tw.wiki.getTiddler('$:/boot/bootprefix.js'))\\n  tempWiki.addTiddler($tw.wiki.getTiddler('$:/themes/tiddlywiki/vanilla'))\\n  let includeList\\n  if(this.includeFilter) {\\n    includeList = $tw.wiki.filterTiddlers(this.includeFilter)\\n  } else {\\n    includeList = $tw.wiki.allTitles()\\n  }\\n  includeList.filter(function(item) {return excludeList.indexOf(item) === -1}).forEach(function(title) {\\n    tempWiki.addTiddler($tw.wiki.getTiddler(title))\\n  })\\n\\n  tempWiki.registerPluginTiddlers(\\\"plugin\\\", [this.core]);\\n  // Unpack plugin tiddlers\\n  tempWiki.readPluginInfo();\\n  tempWiki.unpackPluginTiddlers();\\n\\n  const text = tempWiki.renderTiddler(\\\"text/plain\\\", \\\"$:/core/save/all\\\", options);\\n\\n  let a = document.createElement('a');\\n  // This is the suggested file name for the download on systems that support\\n  // it.\\n  a.download = this.defaultName;\\n  const thisStr = 'data:text/html;base64,'+window.btoa(unescape(encodeURIComponent(text)));\\n  a.setAttribute('href', thisStr);\\n  document.body.appendChild(a);\\n  a.click();\\n  document.body.removeChild(a);\\n\\n\\n  return true; // Action was invoked\\n}\\n\\nexports[\\\"action-downloadwiki\\\"] = ActionDownloadWiki;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/OokTech/Bob/action-opensocket.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/action-opensocket.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/action-opensocket.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nAction widget that creates a new websocket connection to another server\\n\\n<$action-opensocket $url=<<someURL>> blah=halb/>\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nconst ActionOpenSocket = function(parseTreeNode,options) {\\n  this.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nActionOpenSocket.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nActionOpenSocket.prototype.render = function(parent,nextSibling) {\\n  this.computeAttributes();\\n  this.execute();\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nActionOpenSocket.prototype.execute = function() {\\n  this.remoteURL = this.getAttribute('$url', '');\\n};\\n\\n/*\\nRefresh the widget by ensuring our attributes are up to date\\n*/\\nActionOpenSocket.prototype.refresh = function(changedTiddlers) {\\n  const changedAttributes = this.computeAttributes();\\n  if(Object.keys(changedAttributes).length) {\\n    this.refreshSelf();\\n    return true;\\n  }\\n  return this.refreshChildren(changedTiddlers);\\n};\\n\\n/*\\nInvoke the action associated with this widget\\n*/\\nActionOpenSocket.prototype.invokeAction = function(triggeringWidget,event) {\\n  $tw.RemoteConnection  = $tw.RemoteConnection || {};\\n  if (this.remoteURL) {\\n    $tw.RemoteConnection.socket = new WebSocket(this.remoteURL);\\n    $tw.RemoteConnection.socket.onopen = openSocket;\\n    $tw.RemoteConnection.socket.onmessage = parseMessage;\\n    $tw.RemoteConnection.socket.binaryType = \\\"arraybuffer\\\";\\n  }\\n  return true; // Action was invoked\\n};\\n\\nfunction openSocket(event) {\\n  console.log(event.target)\\n  event.target.send('HI!')\\n}\\n\\nfunction parseMessage() {\\n\\n}\\n\\nexports[\\\"action-opensocket\\\"] = ActionOpenSocket;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/OokTech/Bob/action-reconnectwebsocket.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/action-reconnectwebsocket.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/action-reconnectwebsocket.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nAction widget that reconnects to a wiki server\\n\\n<$action-reconnectwebsocket/>\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nconst ActionReconnect = function(parseTreeNode,options) {\\n  this.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nActionReconnect.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nActionReconnect.prototype.render = function(parent,nextSibling) {\\n  this.computeAttributes();\\n  this.execute();\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nActionReconnect.prototype.execute = function() {\\n  this.sync = this.getAttribute('sync', 'false');\\n};\\n\\n/*\\nRefresh the widget by ensuring our attributes are up to date\\n*/\\nActionReconnect.prototype.refresh = function(changedTiddlers) {\\n  const changedAttributes = this.computeAttributes();\\n  if(Object.keys(changedAttributes).length) {\\n    this.refreshSelf();\\n    return true;\\n  }\\n  return this.refreshChildren(changedTiddlers);\\n};\\n\\n/*\\nInvoke the action associated with this widget\\n*/\\nActionReconnect.prototype.invokeAction = function(triggeringWidget,event) {\\n  $tw.Bob.Reconnect(this.sync);\\n  return true; // Action was invoked\\n};\\n\\nexports[\\\"action-reconnectwebsocket\\\"] = ActionReconnect;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/OokTech/Bob/action-savesettings.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/action-savesettings.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/action-savesettings.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nAction widget to save the settings to the server\\n\\n<$action-savesettings/>\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nconst ActionSaveSettings = function(parseTreeNode,options) {\\n  this.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nActionSaveSettings.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nActionSaveSettings.prototype.render = function(parent,nextSibling) {\\n  this.computeAttributes();\\n  this.execute();\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nActionSaveSettings.prototype.execute = function() {\\n};\\n\\n/*\\nRefresh the widget by ensuring our attributes are up to date\\n*/\\nActionSaveSettings.prototype.refresh = function(changedTiddlers) {\\n  const changedAttributes = this.computeAttributes();\\n  if(Object.keys(changedAttributes).length) {\\n    this.refreshSelf();\\n    return true;\\n  }\\n  return this.refreshChildren(changedTiddlers);\\n};\\n\\n/*\\nInvoke the action associated with this widget\\n*/\\nActionSaveSettings.prototype.invokeAction = function(triggeringWidget,event) {\\n  let self = this;\\n  const tiddler = $tw.wiki.getTiddler('$:/WikiSettings/split');\\n  const settings = JSON.stringify(buildSettings(tiddler), \\\"\\\", 2);\\n  const token = localStorage.getItem('ws-token');\\n  const wikiName = $tw.wiki.getTiddlerText(\\\"$:/WikiName\\\");\\n  const message = {\\n    \\\"type\\\": \\\"updateSetting\\\",\\n    \\\"settingsString\\\": settings,\\n    \\\"token\\\": token,\\n    \\\"wiki\\\": wikiName\\n  }\\n  $tw.Bob.Shared.sendMessage(message, 0)\\n  return true; // Action was invoked\\n};\\n\\nfunction buildSettings (tiddler) {\\n  let settings = {};\\n  if(tiddler) {\\n    if(tiddler.fields) {\\n      let object = (typeof tiddler.fields.text === 'string')?JSON.parse(tiddler.fields.text):tiddler.fields.text;\\n      Object.keys(object).forEach(function (field) {\\n        if(typeof object[field] === 'string' || typeof object[field] === 'number') {\\n          if(String(object[field]).startsWith('$:/WikiSettings/split')) {\\n            // Recurse!\\n            const newTiddler = $tw.wiki.getTiddler(object[field]);\\n            settings[field] = buildSettings(newTiddler);\\n          } else {\\n            // Actual thingy!\\n            settings[field] = object[field];\\n          }\\n        } else {\\n          settings[field] = \\\"\\\";\\n        }\\n      });\\n    }\\n  }\\n  return settings;\\n}\\n\\nexports[\\\"action-savesettings\\\"] = ActionSaveSettings;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/OokTech/Bob/action-setcookie.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/action-setcookie.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/action-setcookie.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nAction widget that sets a browser cookie\\n\\nSet the value to \\\"\\\" to clear the cookie.\\n\\n<$action-setcookie name=cookieName value=cookieValue/>\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nconst ActionSetCookie = function(parseTreeNode,options) {\\n  this.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nActionSetCookie.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nActionSetCookie.prototype.render = function(parent,nextSibling) {\\n  this.computeAttributes();\\n  this.execute();\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nActionSetCookie.prototype.execute = function() {\\n  this.name = this.getAttribute('name', '');\\n  this.value = this.getAttribute('value', '');\\n};\\n\\n/*\\nRefresh the widget by ensuring our attributes are up to date\\n*/\\nActionSetCookie.prototype.refresh = function(changedTiddlers) {\\n  const changedAttributes = this.computeAttributes();\\n  if(Object.keys(changedAttributes).length) {\\n    this.refreshSelf();\\n    return true;\\n  }\\n  return this.refreshChildren(changedTiddlers);\\n};\\n\\n/*\\nInvoke the action associated with this widget\\n*/\\nActionSetCookie.prototype.invokeAction = function(triggeringWidget,event) {\\n  $tw.setcookie(this.name, this.value);\\n  return true; // Action was invoked\\n};\\n\\nexports[\\\"action-setcookie\\\"] = ActionSetCookie;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/OokTech/Bob/action-updatesetting.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/action-updatesetting.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/action-updatesetting.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nAction widget to add or change one or more values in settings.json\\n\\n<$action-updatesetting setting1=value1 setting2=value2/>\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nconst ActionUpdateSetting = function(parseTreeNode,options) {\\n  this.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nActionUpdateSetting.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nActionUpdateSetting.prototype.render = function(parent,nextSibling) {\\n  this.computeAttributes();\\n  this.execute();\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nActionUpdateSetting.prototype.execute = function() {\\n};\\n\\n/*\\nRefresh the widget by ensuring our attributes are up to date\\n*/\\nActionUpdateSetting.prototype.refresh = function(changedTiddlers) {\\n  const changedAttributes = this.computeAttributes();\\n  if(Object.keys(changedAttributes).length) {\\n    this.refreshSelf();\\n    return true;\\n  }\\n  return this.refreshChildren(changedTiddlers);\\n};\\n\\n/*\\nInvoke the action associated with this widget\\n*/\\nActionUpdateSetting.prototype.invokeAction = function(triggeringWidget,event) {\\n  const token = localStorage.getItem('ws-token');\\n  const wikiName = $tw.wiki.getTiddlerText(\\\"$:/WikiName\\\");\\n  let update = {};\\n  let remove = false;\\n  $tw.utils.each(this.attributes,function(name,attribute) {\\n    if(attribute.startsWith(\\\"$\\\")) {\\n      if(attribute === \\\"$remove\\\") {\\n        remove = name;\\n      }\\n    } else {\\n      try {\\n        update[attribute] = JSON.parse(name);\\n      } catch {\\n        update[attribute] = name;\\n      }\\n    }\\n  });\\n  const message = {\\n    \\\"type\\\": \\\"updateSetting\\\",\\n    \\\"updateString\\\": update,\\n    \\\"remove\\\": remove,\\n    \\\"token\\\": token,\\n    \\\"wiki\\\": wikiName\\n  };\\n  $tw.Bob.Shared.sendMessage(message, 0);\\n  return true; // Action was invoked\\n};\\n\\nexports[\\\"action-updatesetting\\\"] = ActionUpdateSetting;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/OokTech/Bob/AutomaticBackups.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AutomaticBackups.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/AutomaticBackups.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThis module setups up automatic backups, if they are enabled.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = 'AutomaticBackups';\\nexports.after = [\\\"load-modules\\\"];\\nexports.platforms = [\\\"node\\\"];\\nexports.synchronous = true;\\n\\nif($tw.node) {\\n  $tw.ServerSide = $tw.ServerSide || require('$:/plugins/OokTech/Bob/ServerSide.js');\\n  // Make sure that $tw.settings is available.\\n  const settings = require('$:/plugins/OokTech/NodeSettings/NodeSettings.js')\\n  // require the fs module if we are running node\\n  const fs = require(\\\"fs\\\");\\n  const path = require(\\\"path\\\");\\n\\n  // Initialise objects\\n  $tw.Bob = $tw.Bob || {};\\n\\n  /*\\n    When a wiki is loaded save a backup, then save a backup at regular\\n    intervals as long as the wiki has been edited since the last backup\\n\\n    So when a wiki gets loaded save a backup and set a timeout, when the wiki gets edited set a timeout if one isn't already going, when the timeout runs out save a backup.\\n    Then if the wiki gets edited again start a new timeout.\\n\\n    So save a copy when loading always\\n\\n    when a wiki is edited and there isn't already a timer, start a timer, when\\n    the timer runs out save the wiki.\\n  */\\n  $tw.settings.backups = $tw.settings.backups || {};\\n  if($tw.settings.backups.enable === 'yes') {\\n    $tw.settings.backups.backupFolder = $tw.settings.backups.backupFolder || './backups';\\n    $tw.settings.backups.backupInterval = $tw.settings.backups.backupInterval || 600000;\\n    if($tw.settings.backups.saveOnLoad === 'yes') {\\n      $tw.hooks.addHook('wiki-loaded', function(wikiName) {\\n        saveWikiBackup(wikiName);\\n      });\\n      $tw.hooks.addHook('wiki-loaded', function(wikiName) {\\n        // For now just save a copy of the settings.json when the server starts\\n        saveSettingsBackup();\\n      });\\n    }\\n    if($tw.settings.backups.saveOnModified) {\\n      $tw.hooks.addHook('wiki-modified', function(wikiName) {\\n        if($tw.Bob.Wikis[wikiName].timer === false || typeof $tw.Bob.Wikis[wikiName].timer === 'undefined') {\\n          setTimeout(saveWikiBackup, $tw.settings.backups.backupInterval, wikiName);\\n        }\\n      });\\n    }\\n\\n    function saveWikiBackup(wikiName) {\\n      const folder = path.resolve($tw.ServerSide.getBasePath(), $tw.settings.backups.backupFolder, wikiName);\\n      const filePath = path.join(folder, 'backup-' + $tw.utils.stringifyDate(new Date()) + '.html');\\n      $tw.utils.createDirectory(folder);\\n      fs.writeFile(filePath, $tw.ServerSide.prepareWiki(wikiName, 'no', 'no'), function(err) {\\n        if(err) {\\n          $tw.Bob.logger.error('error saving backup:', err, {level: 1});\\n        }\\n        $tw.Bob.Wikis[wikiName].timer = false;\\n        if($tw.settings.backups.maxBackups > 0) {\\n          // make sure there are at most maxBackups wikis saved in the folder.\\n          fs.readdir(folder, function(err2, filelist) {\\n            if(err2) {\\n              $tw.Bob.logger.error('error reading backups folder', err2, {level: 1});\\n            } else {\\n              const backupsList = filelist.filter(function(item) {\\n                return item.startsWith('backup-')\\n              }).sort()\\n              if(backupsList.length > $tw.settings.backups.maxBackups) {\\n                for (let i = 0; i < backupsList.length - $tw.settings.backups.maxBackups; i++) {\\n                  fs.unlink(path.join(folder,backupsList[i]),function(err3){\\n                    if(err3) {\\n                      $tw.Bob.logger.error('error removing old backup:',err3)\\n                    }\\n                  });\\n                }\\n              }\\n            }\\n          });\\n        }\\n      });\\n    }\\n\\n    function saveSettingsBackup() {\\n      const folder = path.resolve($tw.ServerSide.getBasePath(), $tw.settings.backups.backupFolder, 'settings');\\n      const filePath = path.join(folder, 'settings-backup-' + $tw.utils.stringifyDate(new Date()) + '.json');\\n      $tw.utils.createDirectory(folder);\\n      fs.writeFile(filePath, JSON.stringify($tw.settings, \\\"\\\", 2), function(err) {\\n        if(err) {\\n          $tw.Bob.logger.error('error saving settings backup', err, {level: 1});\\n        }\\n        if($tw.settings.backups.maxBackups > 0) {\\n          fs.readdir(folder, function(err2, filelist) {\\n            if(err2) {\\n              $tw.Bob.logger.error('error reading backups folder', err2, {level: 1});\\n            } else {\\n              const backupsList = filelist.filter(function(item) {\\n                return item.startsWith('settings-backup')\\n              }).sort()\\n              if(backupsList.length > $tw.settings.backups.maxBackups) {\\n                for (let i = 0; i < backupsList.length - $tw.settings.backups.maxBackups; i++) {\\n                  fs.unlink(path.join(folder,backupsList[i]),function(err3){\\n                    if(err3) {\\n                      $tw.Bob.logger.error('error removing old backup:',err3)\\n                    }\\n                  });\\n                }\\n              }\\n            }\\n          });\\n        }\\n      })\\n    }\\n  }\\n}\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/BobLogger.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/BobLogger.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/BobLogger.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThis module creates a logger similar to the built-in tiddlywiki logger but with\\nmore options specific to Bob.\\n\\nIt is just a stopgap until I figure out how to make the logger for the core\\ntiddlywiki.\\n\\nLogger levels:\\n\\n-1 - (almost) no logging. There will still be output from loading the settings\\n  because the settings for the log levels have to be loaded before they can be\\n  used so they don't affect the module loading the settings.\\n0 - only necessary info (like the port being used) and errors that crash the server.\\n1 - basic information (wiki url paths, things that don't flood the terminal) also errors that would prevent actions from working\\n2 - listing every tiddler saved, deleted, renamed, etc. and any errors that would affect operation, noticable or not.\\n3 - lots of debugging information\\n4 - a truly ridiculous amount of stuff\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = 'BobLogger';\\nexports.after = [\\\"load-modules\\\"];\\nexports.platforms = [\\\"node\\\"];\\nexports.synchronous = true;\\n\\nif($tw.node) {\\n  $tw.ServerSide = $tw.ServerSide || require('$:/plugins/OokTech/Bob/ServerSide.js');\\n  // Make sure that $tw.settings is available.\\n  const settings = require('$:/plugins/OokTech/NodeSettings/NodeSettings.js')\\n  // require the fs module if we are running node\\n  const fs = require(\\\"fs\\\");\\n  const path = require(\\\"path\\\");\\n\\n  // Initialise objects\\n  $tw.Bob = $tw.Bob || {};\\n  $tw.settings.logger = $tw.settings.logger || {};\\n  $tw.Bob.logger = $tw.Bob.logger || {};\\n\\n  /*\\n    Set up file logging\\n  */\\n  if ($tw.settings.logger.useFileLogging === 'yes') {\\n    // Output gets written to a file\\n    const basePath = $tw.ServerSide.getBasePath();\\n    const outputFolder = $tw.settings.logger.outputFolder || './logs';\\n    const outputBaseFileName = $tw.settings.logger.outputBaseFileName || 'Log';\\n    const { Console } = require('console');\\n    const timeStamp = new Date().toISOString();\\n    //$tw.utils.createDirectory(path.resolve(basePath,outputFolder));\\n    fs.mkdirSync(path.resolve(basePath,outputFolder), {recursive: true});\\n    const outputFile = path.resolve(basePath,outputFolder,outputBaseFileName + ' - ' + timeStamp + '.log')\\n    const stdout = fs.createWriteStream(outputFile);\\n    let stderr = undefined;\\n    if ($tw.settings.logger.useSeparateErrorFile === 'yes') {\\n      const outputErrorFileName = $tw.settings.logger.outputErrorFileName || 'Error';\\n      const outputErrFile = path.resolve(basePath,outputFolder,outputErrorFileName + ' - ' + timeStamp + '.log')\\n      const outputErrorStream = '';\\n      stderr = fs.createWriteStream(outputErrFile);\\n    }\\n\\n    const ignoreErrors = $tw.settings.logger.ignoreErrors === 'no'?false:true;\\n\\n    const options = {\\n      stdout: stdout,\\n      stderr: stderr,\\n      ignoreErrors: ignoreErrors\\n    };\\n\\n    $tw.Bob.logger.file = new Console(options);\\n  }\\n  if ($tw.settings.logger.useBrowserLogging === 'yes') {\\n    // TODO this!!\\n    const browserLogTiddlerName = '$:/status/Bob/Logs'\\n    const browserErrorTiddlerName = '$:/status/Bob/Errors'\\n    $tw.Bob.logger.browser = {\\n      log: function(/* args */){\\n        // Take the message and put it into the logging tiddler\\n        // The key is the timestamp, the value is the message\\n        // Get the current json tiddler\\n\\n        // Add the new message to it\\n\\n        // Save the updated tiddler\\n\\n      },\\n      error: function(/* args */){\\n        // Take the message and put it into the error tiddler\\n        // The key is the timestamp, the value is the message\\n        // Get the current json tiddler\\n\\n        // Add the new message to it\\n\\n        // Save the updated tiddler\\n\\n      }\\n    }\\n  }\\n  if ($tw.settings.logger.useConsoleLogging !== 'no') {\\n    $tw.Bob.logger.console = console;\\n  }\\n\\n  // A convenience function that handles all of the logging types so you don't have to unless you have multiple enabled but only want to log something in one place.\\n  $tw.Bob.logger.log = function (/* args */) {\\n    let params = {}\\n    $tw.settings.logger = $tw.settings.logger || {};\\n    const argumentList = [].slice.apply(arguments);\\n    if (arguments.length > 1) {\\n      if (typeof arguments[arguments.length-1] === 'object') {\\n        params = argumentList.pop();\\n      }\\n    }\\n    if ($tw.settings.logger.useFileLogging === 'yes') {\\n      $tw.settings.logger.fileLogLevel = $tw.settings.logger.fileLogLevel || 2;\\n      // Output gets written to a file\\n      if (typeof params.level === 'undefined' || $tw.settings.logger.fileLogLevel >= params.level) {\\n        $tw.Bob.logger.file.log(argumentList.join(' '));\\n      }\\n    }\\n    if ($tw.settings.logger.useBrowserLogging === 'yes') {\\n      $tw.settings.logger.browserLogLevel = $tw.settings.logger.browserLogLevel || 2;\\n      // Output gets written to a tiddler so it is visible in the browser\\n      if (typeof params.level === 'undefined' || $tw.settings.logger.browserLogLevel >= params.level) {\\n        $tw.Bob.logger.browser.log(argumentList.join(' '));\\n      }\\n    }\\n    if ($tw.settings.logger.useConsoleLogging !== 'no') {\\n      $tw.settings.logger.consoleLogLevel = $tw.settings.logger.consoleLogLevel || 2;\\n      // If another option isn't set than output is logged to the console\\n      if (typeof params.level === 'undefined' || $tw.settings.logger.consoleLogLevel >= params.level) {\\n        $tw.Bob.logger.console.log(argumentList.join(' '));\\n      }\\n    }\\n  }\\n\\n  $tw.Bob.logger.error = function (/* args */) {\\n    let params = {}\\n    $tw.settings.logger = $tw.settings.logger || {};\\n    const argumentList = [].slice.apply(arguments);\\n    if (arguments.length > 1) {\\n      if (typeof arguments[arguments.length-1] === 'object') {\\n        params = argumentList.pop();\\n      }\\n    }\\n    if ($tw.settings.logger.useFileLogging === 'yes') {\\n      $tw.settings.logger.fileLogLevel = $tw.settings.logger.fileLogLevel || 2;\\n      // Output gets written to a file\\n      if (typeof params.level === 'undefined' || $tw.settings.logger.fileLogLevel >= params.level) {\\n        $tw.Bob.logger.file.error(argumentList.join(' '));\\n      }\\n    }\\n    if ($tw.settings.logger.useBrowserLogging === 'yes') {\\n      $tw.settings.logger.browserLogLevel = $tw.settings.logger.browserLogLevel || 2;\\n      // Output gets written to a tiddler so it is visible in the browser\\n      if (typeof params.level === 'undefined' || $tw.settings.logger.browserLogLevel >= params.level) {\\n        $tw.Bob.logger.browser.error(argumentList.join(' '));\\n      }\\n    }\\n    if ($tw.settings.logger.useConsoleLogging !== 'no') {\\n      $tw.settings.logger.consoleLogLevel = $tw.settings.logger.consoleLogLevel || 2;\\n      // If another option isn't set than output is logged to the console\\n      if (typeof params.level === 'undefined' || $tw.settings.logger.consoleLogLevel >= params.level) {\\n        $tw.Bob.logger.console.error(argumentList.join(' '));\\n      }\\n    }\\n  }\\n}\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/CONTRIBUTING.md\": {\n            \"title\": \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/CONTRIBUTING.md\",\n            \"text\": \"# If you are thinking about posting an issue\\n\\nThank you! More people being involved means we can make free software better\\nfor everyone.\\n\\nThere are some guidelines to help create and support a functioning and\\nrespectful environment.\\n\\n## To help with tech support type issues here are a few things to check before you post an issue:\\n\\n- Are you using the newest version? If not update to the newest version and see\\n  if the issue persists. If not than don't worry about creating a new issue for\\n  a resolved problem.\\n- Is your question already answered in the documentation? Check the\\n  [readme](https://github.com/OokTech/TW5-Bob),\\n  [configuration documentation](https://github.com/OokTech/TW5-Bob/blob/master/Configuration.md)\\n  and [general documentation](https://github.com/OokTech/TW5-Bob/tree/master/Documentation)\\n- Are you asking a question that is already part of another issue? If so add to\\n  the conversation in that issue instead of creating a new one to make it\\n  easier for people in the future to see progress being made.\\n- Is the question you are asking about this plugin or would it be better to ask\\n  it on the [TiddyWiki issues board?](https://github.com/Jermolene/TiddlyWiki5)\\n  This may not always be obvious so don't worry too much about this one, but\\n  take a moment to consider it before posting an issue.\\n\\n## Some other guidelines\\n\\n- Are you asking for free engineering work? The people who work on this project\\n  do so for their own reasons, please show them enough respect to not consider\\n  them your unpaid engineering department.\\n  - If you are part of a company with a team and are requesting some\\n    enterprise grade additions to help than we suggest you consider emailing\\n    info@ooktech.com and request a quote if you want a custom implementation.\\n  - One possible exception to this is education. We have a soft spot for\\n    education and often help where we can.\\n- @inmysocks, the lead on the project, is dyslexic. Please do not include text\\n  styling in your issues aside from code blocks if necessary. While using bold,\\n  italics, underlined or colored text may make certain parts of the text stand\\n  out more for you they are very difficult for some people, including the\\n  project lead, to read.\\n\",\n            \"type\": \"text/x-markdown\"\n        },\n        \"$:/plugins/OokTech/Bob/Changelog\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Changelog\",\n            \"text\": \"!! Version 1.6.0 Mopbucket, backup your data\\n\\nSpecial thanks to @joshuafontany for some much requested stability improvements.\\n\\nNote: Federation is disabled in the code because it doesn't have proper security yet\\n\\n* (BobEXE) switched to using nexe instead of pkg.\\n* Fixed uploading media to the RootWiki so it has the correct _canonical_uri\\n* improved the normalise tiddler function so tiddlers with no text fields are handled consistently\\n* Fixed a regression where draft tiddlers were saved to the server\\n* partially fixed a regression caused by switching to the built-in syncer, tiddlers you edit directly (like `$:/SiteTitle`) try to save on every keystroke and it chokes, before there was a throttling system in place for saving tiddlers that used the message queue. Instead of keeping it from saving, it is just slow to respond.\\n* Added a `$tiddler` attribute to `action-websocketmessage` to simplify a few things.\\n* Single file wikis that contain the Bob plugin shouldn't show the RSOE anymore\\n* Fixed some rare edge cases that could cause Bob to crash\\n* Moved more messages to use the Bob logger instead of console.log\\n* The file server now correctly supports video files\\n* Hopefully removed the need for the `proxyprefix` setting.\\n* All around better handling of draft tiddlers on the node side (thanks @joshuafontany)\\n* Add some error handling specific to windows (thanks @joshupfontany)\\n* Fix a race condition that could lead to ignoring file system paths filters. (thanks @joshuafontany)\\n* Fix a problem where canceling an edit on a shadow tiddler would leave the tiddler locked\\n* Federation - udp multicast works for discovering other Bob servers on the local network.\\n* Federation - pulling tiddlers from other Bob servers on the local network works\\n* Federation - federated chat on the local network works\\n* Federation - fixed a problem where some network configurations would prevent servers from finding each other using UDP multicast.\\n* Federation - there is a bug with dates when fetching tiddlers, sometimes dates come out as NaNaNa.... in the receiving wiki.\\n\\n!! Version 1.5.2 Scruffy, the Janitor\\n\\n* Made a change to saving settings that may prevent a rare bug\\n* The file server now tries to determine the mimetype of served files\\n* Many updates to the control panel tab layout and documentation\\n* Making a wiki from an html file should work again\\n* the action-updatesetting widget got an update so it can properly remove settings\\n* Big reorganisation of the $:/ControlPanel tab for Bob, added a lot of context help\\n* Fixed a problem automatic backups caused with serving Bob to child wikis\\n* Fixed adding existing node wikis to the Bob server\\n* Added an option that lets you set a persistent username in a wiki.\\n\\n!! Version 1.5.1 hy\\n\\n* Fixed a problem that would set the base path to the current folder as an absolute path instead of to `cwd` if no base path was given.\\n* Fixed the backup format so the wikis open up correctly as single file wikis\\n* (BobEXE) Updated to TiddlyWiki 5.1.22\\n\\n!! Version 1.5.0 Apat\\n\\n* Fixed some problems with action-updatesetting\\n* Add configuration UI for logging\\n* Tweaked some configuration instructions\\n* Added udp multicast to find other Bob servers on the local network\\n** For federation stuff\\n* Started UI for managing interactions with other servers\\n* Fixed problems with saving images to the server and some settings checkboxes that didn't work\\n* Fixed a problem with the syncer that could cause it to try and save files it shouldn't.\\n* Setting the `pathprefix` does what it should now.\\n** A brief explaination of the difference between `pathprefix` and `proxyprefix` is added to `Configuration.md`\\n* Added the `perWikiFiles` setting which makes files served with a specific wiki (by default in the `files` folder next to the wikis `tiddlers` folder) are only accessible by that wiki. Files served under `filePathRoot` are accessible to every wiki.\\n** globally accessible files are served with the `/files/` prefix, other wikis have their wiki specific files served with the `/wikiName/files/` prefix. For the RootWiki you have to reference wiki specific files with `/RootWiki/files/` as the prefix, for other wikis the `wikiName` part of the prefix is the same as the url path.\\n* On the back-end added a hook for wiki loaded and wiki modified to the server\\n* Added autobackups\\n* fixed a bug that would sometimes prevent wikis from connecting to the server if the RootWiki wasn't already loaded.\\n* Added a default settings file that contains a value for every setting.\\n\\n!! Version 1.4.0\\n\\n''Note:'' this version changes some parts of how tiddlers are saved to the file\\nsystem. There shouldn't be any problems but there is always a risk of data loss\\nwhen making changes like this. Make sure to backup your data.\\n\\n* Implemented lazy loading\\n** You can enable/disable lazy loading in the `Bob Settings` tab of the $:/ControlPanel\\n** Documentation is under the `Bob Settings` tab in the control panel with the other documentation\\n* Setup saving and loading in normal syncadaptors to work better with the core\\n** The dirty indicator is now handled by the core, so it should behave better now\\n*** Saving now takes longer, but 'longer' is about 1 second instead of about 1/10th of a second.\\n**** This is because of a delay built into the core, it isn't a bug. In future versions of tiddlywiki this will be configurable.\\n** The 'there are unsaved changes' message when you close a tab is also now handled by the core, so it should behave better as well.\\n* finished moving all of the functionality of the `ServerImages` plugin into Bob.\\n** This means that the `ServerImages` plugin is no longer necessary.\\n** Information about the new setup is available in the Bob Documentation called `Server Media`\\n** The server media part is enabled by default if you turn on the file server. It can be disable in the $:/ControlPanel under `Bob Settings` -> `Server` -> `File Server`\\n*** The server media component only works if the file server is enabled, if it isn't enabled than the server media component has no effect.\\n* Changed `WebsocketAdaptor.js` to `MultiWikiAdaptor.js` because it has nothing to do with websockets, it handles saving and loading when you have multiple wikis.\\n* Removed some unused template files\\n* Switch to using more asynchronous functions\\n** changing multiple functions in the file system monitor to use asynchronous versions\\n*** While this prevents some race conditions and reduces the places where writing tiddler changes can be delayed, it introduces another race condition that arises when you rename a tiddler or a file on the file system so that the tiddler file name does not follow the rules used by the wiki. The file system monitor deletes the incorrectly named file and creates a new file with the expected name. The file watcher starts acting before the file is completely deleted so it acts as though the file still exists which leads to an error being thrown. The error is handled but there may be unexpected behaviour is situations where tiddler titles or file names are changed in the file system. Back up your data.\\n* Modified the BobSaver so the server only accepts files with the extensions `.html`, `.htm` and `.hta`\\n** Changing the host for the BobSaver requires that you agree to not ask for tech support and understand that none will be given by filling out the acceptance part of the configuration\\n* Added a checkbox to the server tab to enable or disable saving media on the server and creating a tiddler with a `_canonical_uri` field when importing media into the wiki\\n* ''(BobEXE only)'' Added a checkbox to enable or disable automatically opening up a browser when BobEXE starts. This has no effect if you are using the plugin version.\\n* Checkboxes that change settings no longer require you to click a button to save the change\\n** Text entry boxes still require you to click a button to save the updated settings.\\n* Added/updated documentation about the saver server and the media server (the replacement for the `ServerImages` plugin.)\\n* ''(BobEXE only)'' Added command line arguments to set the location of the index wiki and the wikis folder.\\n* Added an option to disable the file system watcher\\n** This may help reduce memory usage further if you don't ever edit tiddlers on the file system\\n** ''Using syncing software with your wiki folders is not recommended, it can cause dulpicate files and data loss, Bob and the syncing software fight each other when changing files.'' This may help reduce conflicts if you are using syncing software for your wiki folders.\\n** This helps prevent bugs that arise from not being able to properly monitor network drives.\\n*** This is a limitation of networked drives, it is not specific to Bob. I may write an alternate filesystem monitor that can function with network drives but it will necessarily be slower and have the potential to miss changes made on the file system. This may be unavoidable on networked drives.\\n\\n!! Version 1.3.3 Kohlrabi\\n\\n* Added saver key to the single file saver\\n** This means that you can set a key and a wiki will only save if it you enter the correct key.\\n** Leaving the key blank means that no key is required.\\n* Added saver configuration tab under Bob settings\\n** Enable/disable saver server\\n** Set saver key\\n** Set host (WARNING: This can very easily break the saver)\\n** Set port (WARNING: This can very easily break the saver)\\n* internalFetch no longer causes a browser alert when you use resolution=force\\n* Browser alert tiddlers are now prefixed with `$:/temp/` so that they don't show up in the sidebar and don't get saved.\\n\\n!! Version 1.3.2 Sugar Beets\\n\\n* Update documentation in the server routes\\n* Hopefully fix the problem where BobEXE crashes if there is no GUI and `suppressBrowser` is not set to `yes`\\n* Fix some api routes used by TWederBob\\n* Fix a bug with `internalFetch` that would break when using `force` for conflicts\\n* Fix some other bugs with `internalFetch` that resulted in tiddlers being created in the wrong wikis.\\n* Make federated and local chat use the same format for messages\\n* Add saver for single-file wikis\\n** Works with the `BobSaver` plugin. Put the `BobSaver` plugin in your wiki then if you have Bob running on your computer the wiki will save as expected.\\n* Some tweaks to how browser alerts are sent to hopefully reduce the alert spamming.\\n\\n!! Version 1.3.1 Splenda\\n\\n* Make the expandable wiki listing default to closed\\n* Fix a rather serious bug where changes on some wiki wouldn't be saved back to the server.\\n* Fixed the local chat\\n\\n!! Version 1.3.0 Tofurkey\\n\\n* maybe actually set the SaverFilter tiddler correctly\\n* start documentation on inter-server federation and syncing\\n* Add local chat\\n** different people using the same wiki served by a Bob server can have a real-time chat.\\n* Add federated chat\\n** People on different servers can chat with each other\\n** Limited utility due to server discoverability and NAT shenanigans\\n* Hopefully fix the problems with saving .tid files that have unsorted tags\\n* split out routes into separate files\\n** this may allow doing things like enabling the file server without restarting the server.\\n* Started a hopefully better interface for federated things.\\n* Add some advanced settings\\n** local message queue timeout\\n** federated message queue timeout\\n** saveTiddlerDelay\\n* Added a server route for uploading files.\\n** The browser hook is still in the ServerImages plugin, I may move it into Bob later.\\n* Add a warning that the wiki hasn't connected to the server at startup\\n** the warning goes away as soon as the wiki connects to the server\\n* The dirty indicator is changed to show dirty when there are messages in the send queue and clean when the queue is empty.\\n* The resync has been modified, it may work inconsistently\\n* Added easier way to turn on/off serving on the local network\\n** Go to the control panel -> Bob Settings -> Server tab for instructions\\n* Added an easier way to turn on/off the static file server\\n** Go to the control panel -> Bob Settings -> Server tab -> File Server tab for instructions\\n* Added an interface for adding multiple folders to serve media, see `Serving Files and Images` in the Bob documentation.\\n* Improved the mediaScan so that it can scan any folder and serve the files in them.\\n** This breaks the previous `filePathRoot` setup method\\n\\n!! Version 1.2.4 Mashed Potatoes with a fine black pepper gravy\\n\\n* Cleaned up some code in `FileSystemMonitor.js` and `WebsocketAdaptor.js` to better partition what each does, no functional changes.\\n* Split out the start of the federation components for inter-server communication.\\n* Change all of the checks to see if a tiddler has changed to use the hash of the tiddler instead of matching fields. It should be less suceptable to bugs. It may be slightly faster but this probably isn't a place where that makes a difference.\\n** (unfinished) The hashes are cached where appropriate to make things a bit faster. Once again this may be unneeded but it was simple to implement.\\n* The normalizeTiddler and TiddlerHasChanged functions are used more consistently\\n** fix some incorrect handing of tags and list fields in normalizeTiddler\\n* Change code to use new core utility functions\\n** Used `$tw.utils.generateTiddlerFileInfo` where appropriate\\n** Used `$tw.utils.saveTiddlerToFileSync`,\\n* Added collapsing wiki listing\\n* Fixed a bug that sometimes prevented the file server from working correctly in the root wiki.\\n* Added the working framework for inter-server federation and messages.\\n* Added a check to see if Bob was running in an iframe and if so don't treat upgrade requests as websockets\\n** This is needed to make twederation work with Bob servers.\\n* Fixed a bug where the list field would be sorted when it shouldn't be.\\n* Added command to scan a folder for media and create _canonical_uri tiddlers for each thing found. (mediaScan)\\n* updated to tiddlywiki v5.1.21\\n* fixed a bug with how filter in $:/config/FileSystemPaths are handled\\n\\n!! Version 1.2.3 Boiled Potatoes\\n\\n  - Setting up the file server is simpler now\\n    - In the Bob Settings tab of the control panel there is a file server tab that lets you check a box to enable the server.\\n    - There are also text boxes that let you set the folder where files are served from and the path prefix for files\\n  - The makeImagesExternal message was added. It takes all of the embedded media in a wiki and copies it into the folder for the file server and replaces the media tiddlers with tiddlers that have a _canonical_uri field pointing to the media file.\\n    - An option lets you copy the files into the globally available file folder or into the wiki specific file folder.\\n  - Add interface to duplicate an existing wiki\\n    - You can optionally duplicate all of the child wikis that are contained in the folder of the wiki you are duplicating.\\n  - Add interface to rename/move a wiki\\n  - Add interface to delete a wiki, you can optionally delete all of a wikis children as well.\\n  - Fixed some potential bugs dealing with paths when creating new wikis.\\n  - Reordered some functions to make wiki creation more consistent.\\n  - Added browser alerts for server events (like confirmations of creating or deleting wikis, fetching tiddlers, etc.)\\n    - There is a control panel tab that lists a history of server messages.\\n  - Possibly fix a bug that could add incorrect path prefixes when using filters in $:/config/FileSystemPaths.\\n  - Reorder the control panel tab for Bob so it is more compact and organised.\\n  - Added the `proxyprefix` configuration option. It is needed for when you are behind a proxy that changes the path part of the url. See [[the documentation|$:/plugins/OokTech/Bob/UsingProxies]]\\n  - Added default values for the plugins, editions, languages and themes environment variables. They are './Plugins', './Editions', './Languages' and './Themes' respectivly.\\n  - You can see available editions, plugins, themes and languages in plugins called `$:/Bob/AvailablePlguinList`, `$:/Bob/AvailableLanguageList`, '$:/Bob/AvailableThemeList' and `$:/Bob/AvailableEditionList`.\\n  - Add an interface to set which editions are listed in the create wikis from editions interface.\\n  - Updating settings should work more consistently now\\n  - Hopefully fix the wiki listing so it works on wikis that are more than one layer deep in the names.\\n  - Empty settings should be properly removed now so the settinsg.json won't be full of things like \\\"foo\\\":{}\\n  - The 'Are you sure you want to leave without saving' message should be suppressed for real this time.\\n  - Deleting a wiki that has been previously loaded shouldn't cause trouble anymore.\\n  - Added many logging things\\n    - different logging levels to pick how much output is given\\n    - log to the console or a file, or both (logging to the browser coming soon)\\n    - independent logging levels for each logging type\\n    - Errors and other logging messages can put into separate files (stdout and stderr can be handled separately)\\n\\n!! Version 1.2.2r5 Fried Potatoes\\n\\n  - Wikis can now be hosted on paths to other wikis. You can have both '/students' and '/students/eve'\\n    - No wikis can have the name `__path`\\n    - The way that wiki paths are listed has changed, but settings files are updated automatically without needing any manual editing.\\n  - Lots of small back-end optimisations that hopefully reduce the memory usage.\\n  - Improvements for reconnecting to and resyncing with a server after being disconnected\\n  - Added an option to have verbose or compact help and documentation in the control panel.\\n  - Fix the manual settings losing focus problem\\n  - Improve the manual settings layout and interface a little\\n  - Fix some situations where the tiddlywiki/filesystem and tiddlywiki/tiddlyweb were included when they shouldn't be\\n  - Fix a bug that prevented internal fetch from working with a transform filter (and possibly in other situations)\\n  - (BobEXE) the Wikis, Plugins, Themes and Editions folders are all now created automatically in a default location in the same folder as the executable.\\n  - Fixed another bug that would sometimes allow a wiki with the same name as an existing wiki to be created\\n  - You can now access the full settings interface from any wiki by checking a box in the control panel.\\n  - Hopefully fix a race condition that could result in multiple wikis being created for a single command.\\n  - Automatically populating the wiki list will now properly find wikis inside other wiki folders.\\n  - Add an interface to manage themes like the manage plugins interface.\\n  - You can now fetch plugins directly from github. (VERY EXPERIMENTAL)\\n    - This required two external modules that are now included in the Bob plugin\\n      - An updated (and not backwards compatible) jszip\\n      - follow-redirects\\n    - On GitHub.com or GitLab.com you can give the repo url to get the plugin\\n      - For github the repo url will be something like this `https://github.com/OokTech/TW5-RandomValue`, there is some special handling to get the zip url from the repo url for github.\\n      - for gitlab the repo url will be something like this `https://gitlab.com/inmysocks/ookbot`, there is also special handling to get the url for the zip from gitlab.com repos.\\n    - Anywhere else you have to give the full url for the zip file itself.\\n  - Fix a bug where unicode or other uri encoded wiki names wouldn't work, this includes many south-east asian alphabets and character sets.\\n    - This also means that wikis can have spaces and emojis in their names\\n\\n!! Version 1.2.1 Timey Wimey\\n\\nI didn't track things here... Something happened I am sure.\\n\\n!! Version 1.2.0 Wibbly Wobbly\\n\\n  - Don't sync tiddlers that start with `$:/WikiSettings`\\n  - General improvements to message handling\\n  - You can now give a path (absolute or relative) for wikis instead of always\\n    making wikis in the `./Wikis` folder.\\n  - Bob can now automatically detect and list any wikis in the wikis folder or\\n    subfolders\\n    - Wikis that are listed but don't exist can also optionally be removed.\\n  - If you are logged in you can set new wikis to be prefixed by your username\\n    to prevent naming collisions on multi-user systems.(currently only relevant\\n    with the secure server)\\n  - You can make new wikis in subfolders by giving a name like\\n    path/to/wiki/wikiName\\n  - Fixed a bug that would sometimes prevent changes to the tags field from\\n    being properly synced.\\n  - Optionally set the server to automatically unload wikis that have no active\\n    connections to reduce ram usage (experimental)\\n  - Automatically close and remove socket objects that are no logner connected\\n  - If you have authentication only wikis you are authorised to view will be\\n    listed.\\n\\n!! Version 1.1.2 Unnamed Pastry\\n\\n  - The control panel tab has been refactored a bit (few visible changes)\\n  - Separate the function that lets you determine if a wiki exists or not from\\n    the load function\\n    - This lets us list only wikis that actually exist\\n    - This may let us automatically detect available wikis in the future\\n  - The available wikis listing now only shows wikis you have permissions to\\n    view.\\n  - You can now set the default folder for storing wikis\\n    - It can be relative to the tiddlywiki folder (or the folder with the\\n      executable) or an absolute path.\\n  - You can now automatically detect wikis that are inside your wikis folder\\n    - This can automatically populate settings.json for you\\n    - This can also detect wikis that are listed but don't exist and remove\\n      them from the list.\\n\\n!! Version 1.1.1 Pretzel Nubs\\n\\n  - Fixed a bug that would sometimes show shadow tiddlers as being edited after\\n    the edit was cancelled.\\n  - Add the start of what is necessary to have access control and\\n    authentication for Bob wikis without an external server\\n    - so far it does nothing with out an external server, but the access\\n      control is now consistent.\\n  - Bump compatibility to TiddlyWiki 5.1.18\\n  - Stop using $tw.boot.files\\n  - Everything that uses the internalFetch mechanism can now accept transform\\n    filters for fetched tiddlers.\\n    - This includes `internalFetch`, `buildHTMLWiki` and `newWikiFromTiddlers`\\n\\n!! Version 1.1.0 Actually Garlic Bagels (still)\\n\\n- Add `savePluginFolder` web socket message to save packaged plugins as folders\\n  on a server. These plugins can then be available to other served wikis and in\\n  the plugin library, if it is enabled.\\n- Add the `import` borwser message handler to make fetching nicer\\n- Add options for how to handle conflicts for `internalFetch`\\n- `internalFetch` now displays a list of imported tiddlers\\n- Added a way to change which plugins a wiki uses from inside the wiki\\n  - In the Bob Settings tab there is a Manage Plugins tab\\n- Added an interface to save plugins to the server and to select which plugins\\n  from the server should be used in the current wiki\\n  - It is still very crude and needs work\\n- Change the internals to make one $tw.Wiki object for each wiki instead of\\n  having them all in $tw.wiki\\n  - There are lots of internal changes to make this work\\n  - $tw.boot.files still uses the prefixed name\\n- Streamlined and simplified the file system monitor\\n  - It should now watch new subfolders inside the tiddlers folder\\n- Environment variables are now set from the plugin, themes, and languages paths\\n  given in the settings.\\n  - This is needed by the core to properly list available plugins\\n  - This means that you can set the location of one folder listing plugins,\\n    themes and languages in the settings instead of using environment\\n    variables. At the moment this is limited to one folder.\\n- The `unloadWiki` message now ensures that the connection to any browsers with\\n  that wiki open are closed correctly.\\n- Updates to the `buildHTMLWiki` message\\n  - You can now pull tiddlers in from any served wiki while making an html\\n    file. This means you can combine wikis in the output.\\n  - There is a default filter for excluding plugins like Bob and components\\n    that are only useful on a server\\n  - You can add an additional filter to exclude tiddlers from the exported html\\n    wiki\\n  - You can disable the default exclude list for more control\\n- The `$:/config/FileSystemPaths` settings should work now\\n- Added a check so it shouldn't crash when trying to load a wiki that doesn't\\n  work\\n- Fixed bug where the wrong port is listed in the control panel.\\n- Added download wiki action widget that downloads the current wiki as a single\\n  html file.\\n  - By default it removes the Bob plugin and some other plugins that only work\\n    with a server.\\n  - It can have an `includeFilter` for tiddlers to include, an `excludeFilter`\\n    for tiddlers to exclude and a suggested name for the downloaded file.\\n- Fixed bug where settings file wouldn't be properly created if it didn't exist\\n- Added an action widget that lets you convert a single file wiki into a wiki\\n  that can be used by Bob.\\n- Added interfaces for the importing/creating and exporting/saving wikis to the\\n  control panel.\\n\\n!! Version 1.0.6 Salt Bagels 2: Bagel Harder\\n\\n- Now the server only uses one port for both websockets and http(s) traffic\\n- Add paths for the plugin library to the normal Bob server\\n\\n!! Version 1.0.5 Salt Bagles\\n\\n- Added fetch and push routes to the `ws-server`\\n  - There are currently only placeholder functions for access control\\n- Updated external libraries to the newest versions (npm modules `ip`, `ws` and\\n  `async-limiter`)\\n  - `ip` is used to get the ip address of the server to make connecting\\n    multiple computers easier\\n  - `ws` adds a websocket interface to the server side\\n  - `async-limiter` is needed by `ws`\\n  - Now the external libraries correctly use `tiddlywiki.files` files instead\\n    of the previous fragile hacky way.\\n- Updated documentation and added a tab in the Bob section of the\\n  $:/ControlPanel for Bob documentation.\\n- Bob now prints out the TiddlyWiki and Bob versions being used in the terminal\\n  when you start the server.\\n- The Save Wiki button is disabled because it isn't useful (later I may make it\\n  download a non-bob single file wiki)\\n\\n!! Version 1.0.4 Sourdough Pizza\\n\\n- The disconnected message is now much smaller because you can keep working on\\n  the wiki and reconnect.\\n- Added the internalFetch message to match the --fetch command in the core.\\n  - It fetches tiddlers from another wiki on the same Bob server\\n  - Tiddlers to import are selected by a filter\\n  - There is an optional transform filter that can modify the imported tiddlers\\n    titles (you can add prefixes/suffixes, etc.)\\n  - Conflict resolution uses the same system as resyncing to the server.\\n\\n!! Version 1.0.3 Sourdough Crumpets\\n\\n- Fixed/Updated documentation\\n  - Added note about buildHTMLWiki message\\n- Fixed a bug that would keep old tiddlers after they were renamed.\\n  - It also sometimes kept old tiddlers that were deleted and then the wiki was\\n    reloaded.\\n- Partially fixed a related bug that would sometimes keep old versions of\\n  tiddlers if they were renamed on the file system while the wiki is running.\\n  - This is only partially fixed. The behaviour is inconsistent. I need to find\\n    reproducible ways to cause it.\\n- Added the 'unloadWiki' message that unloads a loaded wiki.\\n  - This can be used to change the plugins loaded in a wiki and to just remove\\n    wikis from memory if they aren't being used. That second one may not be\\n    very useful because wikis don't take much memory.\\n  - There is currently no handling for what happens when you unload a wiki\\n    while someone is using it. So beware.\\n- Added a hook to be used by external servers when you create a new wiki\\n  - This lets you set the correct access permissions on wikis created from\\n    within tiddlywiki when you are using an external server.\\n- Added detection and recovery of lost websocket messages to ensure that all\\n  changes to a wiki are properly saved on the server and that all changes on\\n  the server make it to all of the browsers.\\n  - This update also gives much more consistent handling to all messages\\n  - There is a short delay before sending saveTiddler messages, this prevents a\\n    bug that would cause errors saving changes to tiddler edited without using\\n    the normal edit tiddler.\\n- Only messages for the wiki a connection is using get sent to that connection,\\n  potentially reducing the network load of a wiki.\\n  - This also improves security and privacy because people who don't have\\n    access to a wiki can't see that there is editing activity taking place or\\n    see tiddler titles.\\n- On the back-end the waiting list is removed which simplifies a lot\\n- Hopefully there is correct handling for date fields now.\\n  - This needs further testing.\\n- Serve cached wikis if nothing has changed since the last time it was built\\n- Added includePluginList and excludePluginList to the configuration.\\n  - `includePluginList` is a list of plugins that should be served to every\\n    wiki served by Bob, regardless of if they are in the tiddlywiki.info file.\\n  - `excludePluginList` is a list of plugins that should not be served on any\\n    wiki served by Bob regardless of if they are listed in the tiddlywiki.info\\n    file.\\n  - `excludePluginList` takes precidence over the `includePluginList` so if a\\n    plugin is listed in both it will not be included. `excludePluginList` can\\n    also override the `servePlugin` setting if you have that set to true, so it\\n    can be used to make Bob serve normal tiddlywikis without any multi-user or\\n    other Bob functionality.\\n- The default file server url path is now `files` instead of `file` to match\\n  the proposed updates to the core --listen command.\\n- The deleteTiddler, editingTiddler and, cancelEditingTiddler messages are now\\n  consistent with the saveTiddler message.\\n  - Now removeTiddler is deleteTiddler\\n- The wiki can now reconnect to a server after being disconnected\\n- The wiki now keeps track of unsent messages when disconnected from the server\\n  - The browser sends any unsent changes to the server when it reconnects\\n  - The changes are also saved in a tiddler that can be exported for future\\n    manual inclusion\\n  - The server sends any changes that have happened since the browser was\\n    disconnected\\n  - Conflicts need to be taken care of in the browser.\\n- The connection health is now determined by the socket state in the browser,\\n  not the time it takes to receive a response to the heartbeat\\n\\n!! Version 1.0.2 Sourdough Biscuits\\n\\n- Fixed/Updated documentation\\n  - for the getSetting macro (fixed typo)\\n  - for the buildHTMLWiki message (added excludeList info)\\n  - fixed the message about shutting down the server in the server actions tab\\n- Fixed a bug where output single file html wikis would always be called\\n  `index.html`\\n- Added an optional excludeFilter attribute to the buildHTMLWiki message that\\n  lists tiddlers that shouldn't be added to the exported wiki.\\n- Added the option to set the location of editions using the editionsPath\\n  setting.\\n  - This shouldn't affect the environment variable method of setting the location.\\n- Fixed a bug that would let the server try and load a wiki that didn't exist\\n- Updated instructions to point to TiddlyWiki version 5.1.17\\n\\n!! Version 1.0.1 Sourdough\\n\\n- The Bob settings tab only has contents on the root wiki.\\n\\n!! Changed name to Bob and bumped version to 1.0.0\\n\\n!! Version 0.1.11\\n\\n- Improved handling for setting the websockets port number\\n- Make all wikis use the settings from the root wiki (otherwise all served wikis would have to have the same port and host information set individually)\\n- The dirty indicator no longer flashes on and off when it doesn't need to. It isn't perfect yet.\\n\\n!! Initial State\\n\\nThis is working as the initial state\\n\\n- Two-way real-time syncing between the browser and file system\\n  - Updates the wiki in the browser immediately when any changes are made to the file system\\n  - Immediately save changes to tiddlers made in the browser to the file system\\n  - Syncing can ignore tiddlers based on an editable exclude filter\\n- Multi-User support\\n  - Allows any number of people/computers/browser tabs to connect to the wiki\\n    server and use or edit the same wiki(s) simultaneously.\\n  - Prevents multiple people from editing the same tiddler at the same time by\\n    disabling the edit button for tiddlers currently being edited\\n- Multi-Wiki support, the plugin can serve multiple wikis at once, each served\\n  wiki has all the features listed here.\\n- Websockets!! (used on the back-end, can be used by other plugins in the\\n  future)\\n  - Adds a websocket interface to tiddlywiki (currently only used by this\\n    plugin, a git plugin is currently being developed as well as plugins to run\\n    scripts on the local computer from tiddlywiki)\\n  - Adds an action widget that allows you to send arbitrary websocket messages\\n    to the server. This can be used to do things like trigger shell scripts\\n    from inside the wiki.\\n- Adds a new command `wsserver` that starts up a minimal http and websocket\\n  server used for the real-time communication between the browser and server.\\n- Adds a new command `externalserver` which starts up the wiki without a server\\n  so that you can use an external server, like an expressjs server.\\n- Allows you to reset the tiddlywiki server from the browser using a websocket\\n  message.\\n- Lets you run shell scripts from inside the wiki\\n- Everything is configurable from inside the wiki\\n- Your connection to the server is monitored and you are warned if there is a\\n  problem\\n- Serve files from the local file system (like images) so that they can be\\n  used in the wiki.\\n- Build a single file version of any served wikis from within the wiki.\\n- Websocket messages send a token from localstorage if one exists for authentication.\\n\"\n        },\n        \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/Configuration.md\": {\n            \"title\": \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/Configuration.md\",\n            \"text\": \"# Configuration\\n\\nConfiguration for the plugin is set in the `settings.json` file in the\\n`settings` sub-folder of the folder where the `tiddlywiki.info` file is\\nlocated.\\n\\nEverything is optional, if there are any missing pieces default values will be\\nused. If the json isn't formatted correctly than default values will be used.\\n\\n## Example settings.json file\\n\\n```\\n{\\n  \\\"editionsPath\\\": \\\"./Editions\\\",\\n  \\\"pluginsPath\\\": \\\"./Plugins\\\",\\n  \\\"themesPath\\\": \\\"./Themes\\\"\\n  \\\"wikisPath\\\": \\\"./Wikis\\\",\\n  \\\"wikiPathBase\\\": \\\"cwd\\\",\\n  \\\"includePluginList\\\": [],\\n  \\\"excludePluginList\\\": [],\\n  \\\"autoUnloadWikis\\\": \\\"false\\\",\\n  \\\"disableBrowserAlerts\\\": \\\"false\\\",\\n  \\\"disableFileWatchers\\\": \\\"no\\\",\\n  \\\"fileURLPrefix\\\": \\\"files\\\",\\n  \\\"namespacedWikis\\\": \\\"false\\\",\\n  \\\"saveMediaOnServer\\\": \\\"yes\\\",\\n  \\\"suppressBrowser\\\": \\\"false\\\",\\n  \\\"enableFederation\\\": \\\"no\\\",\\n  \\\"enableFileServer\\\": \\\"no\\\",\\n  \\\"filePathRoot\\\": \\\"./files\\\",\\n  \\\"perWikiFiles\\\": \\\"no\\\",\\n  \\\"enableBobSaver\\\": \\\"yes\\\",\\n  \\\"persistentUsernames\\\": \\\"no\\\",\\n  \\\"scripts\\\": {\\n    \\\"NewWiki\\\": \\\"tiddlywiki #wikiName --init #editionName\\\"\\n  },\\n  \\\"wikis\\\": {\\n    \\\"OneWiki\\\": \\\"/home/inmysocks/TiddlyWiki/Wikis/OneWiki\\\",\\n    \\\"TwoWiki\\\": \\\"/home/inmysocks/TiddlyWiki/Wikis/TwoWiki\\\",\\n    \\\"OokTech\\\": {\\n      \\\"TestWiki\\\": \\\"/home/inmysocks/TiddlyWiki/Wikis/TestWiki\\\"\\n    }\\n  },\\n  \\\"ws-server\\\": {\\n    \\\"port\\\": 8080,\\n    \\\"host\\\": \\\"127.0.0.1\\\",\\n    \\\"autoIncrementPort\\\": \\\"false\\\",\\n    \\\"servePlugin\\\": \\\"true\\\",\\n    \\\"pathprefix\\\": \\\"\\\"\\n  },\\n  \\\"heartbeat\\\": {\\n    \\\"interval\\\": 1000,\\n    \\\"timeout\\\": 5000\\n  },\\n  \\\"mimeMap\\\": {\\n    \\\".aac\\\": \\\"audio/aac\\\",\\n    \\\".avi\\\": \\\"video/x-msvideo\\\",\\n    \\\".bmp\\\": \\\"image/bmp\\\",\\n    \\\".css\\\": \\\"text/css\\\",\\n    \\\".csv\\\": \\\"text/csv\\\",\\n    \\\".doc\\\": \\\"application/msword\\\",\\n    \\\".epub\\\": \\\"application/epub+zip\\\",\\n    \\\".gif\\\": \\\"image/gif\\\",\\n    \\\".html\\\": \\\"text/html\\\",\\n    \\\".htm\\\": \\\"text/html\\\",\\n    \\\".ico\\\": \\\"image/x-icon\\\",\\n    \\\".jpg\\\": \\\"image/jpeg\\\",\\n    \\\".jpeg\\\": \\\"image/jpeg\\\",\\n    \\\".mp3\\\": \\\"audio/mpeg\\\",\\n    \\\".mp4\\\": \\\"video/mp4\\\",\\n    \\\".mpeg\\\": \\\"video/mpeg\\\",\\n    \\\".odp\\\": \\\"application/vnd.oasis.opendocument.presentation\\\",\\n    \\\".ods\\\": \\\"application/vnd.oasis.opendocument.spreadsheet\\\",\\n    \\\".odt\\\": \\\"application/vnd.oasis.opendocument.text\\\",\\n    \\\".oga\\\": \\\"audio/ogg\\\",\\n    \\\".ogv\\\": \\\"video/ogg\\\",\\n    \\\".ogx\\\": \\\"application/ogg\\\",\\n    \\\".otf\\\": \\\"font/otf\\\",\\n    \\\".pdf\\\": \\\"application/pdf\\\",\\n    \\\".ppt\\\": \\\"application/vnd.ms-powerpoint\\\",\\n    \\\".png\\\": \\\"image/png\\\",\\n    \\\".svg\\\": \\\"image/svg+xml\\\",\\n    \\\".tif\\\": \\\"image/tiff\\\",\\n    \\\".tiff\\\": \\\"image/tiff\\\",\\n    \\\".ttf\\\": \\\"font/ttf\\\",\\n    \\\".txt\\\": \\\"text/plain\\\",\\n    \\\".wav\\\": \\\"audio/wav\\\",\\n    \\\".weba\\\": \\\"audio/weba\\\",\\n    \\\".webm\\\": \\\"video/webm\\\",\\n    \\\".webp\\\": \\\"image/webp\\\",\\n    \\\".woff\\\": \\\"font/woff\\\",\\n    \\\".woff2\\\": \\\"font/woff2\\\",\\n    \\\".xml\\\": \\\"text/xml\\\"\\n  },\\n  \\\"API\\\": {\\n    \\\"enableFetch\\\": \\\"no\\\",\\n    \\\"enablePush\\\": \\\"no\\\",\\n    \\\"pluginLibrary\\\": \\\"no\\\"\\n  },\\n  \\\"logger\\\": {\\n    \\\"useFileLogging\\\":\\\"no\\\",\\n    \\\"fileLogLevel\\\": \\\"2\\\",\\n    \\\"outputFolder\\\": \\\"./logs\\\",\\n    \\\"outputBaseFileName\\\": \\\"Log\\\",\\n    \\\"useSeparateErrorFile\\\": \\\"no\\\",\\n    \\\"outputErrorFileName\\\": \\\"Error\\\",\\n    \\\"ignoreErrors\\\": \\\"yes\\\",\\n    \\\"useBrowserLogging\\\": \\\"no\\\",\\n    \\\"browserLogLevel\\\": \\\"2\\\",\\n    \\\"useConsoleLogging\\\": \\\"yes\\\",\\n    \\\"consoleLogLevel\\\": \\\"2\\\"\\n  },\\n  \\\"federation\\\": {\\n    \\\"serverName\\\": \\\"Noh Neigh-m\\\",\\n    \\\"mobile\\\": \\\"no\\\",\\n    \\\"enableChat\\\": \\\"no\\\",\\n    \\\"udpPort\\\": \\\"3232\\\",\\n    \\\"enableMulticast\\\": \\\"yes\\\",\\n    \\\"multicastAddress\\\": \\\"224.0.0.114\\\",\\n    \\\"broadcast\\\": \\\"yes\\\",\\n    \\\"rebroadcastInterval\\\": \\\"30000\\\",\\n    \\\"checkConnections\\\": \\\"yes\\\"\\n  },\\n  \\\"advanced\\\": {\\n    \\\"localMessageQueueTimeout\\\": 500,\\n    \\\"federatedMessageQueueTimeout\\\": 1500,\\n    \\\"saveTiddlerDelay\\\": 200\\n  },\\n  \\\"servingFiles\\\": {\\n    \\\"name\\\": \\\"/path/to/files\\\"\\n  },\\n  \\\"saver\\\": {\\n    \\\"host\\\": \\\"localhost\\\",\\n    \\\"port\\\": \\\"61192\\\",\\n    \\\"key\\\": \\\"\\\",\\n    \\\"disable\\\": \\\"no\\\"\\n  },\\n  \\\"backups\\\": {\\n    \\\"enable\\\": \\\"no\\\",\\n    \\\"backupFolder\\\": \\\"./backups\\\",\\n    \\\"backupInterval\\\": 600000,\\n    \\\"saveOnLoad\\\": \\\"yes\\\",\\n    \\\"saveOnModified\\\": \\\"yes\\\",\\n    \\\"maxBackups\\\": 10\\n  }\\n}\\n```\\n\\n''Note:'' All paths can be either absolute or relative. Relative paths are\\nrelative to the path listed in `wikiPathBase`, if none is listed they are\\nrelative to the folder with tiddlywiki.js in it if you are using the plugin\\nversion or the folder with the executable file if you are using the BobEXE\\nversion.\\n\\n''Note for windows:'' All the example paths here are how they would appear on\\nlinux or osx. On windows the paths would look like\\n`C:\\\\Users\\\\inmysocks\\\\TiddlyWiki\\\\Wikis`. To make the examples what you would use\\nin windows replace `/home` with `C:\\\\Users` and change the `/` into `\\\\`.\\n\\n## What each part is\\n\\n- `editionsPath` is the folder that holds any custom editions you want to be\\n  able to use when making wikis using the control panel.  If relative it is\\n  relative to `wikiPathBase`.\\n- `pluginsPath` is the path to the plugins folder if you are using the as a\\n  plugin library.  If relative it is relative to `wikiPathBase`.\\n- `themesPath` is the path to the folder where you have your themes.  If\\n  relative it is relative to `wikiPathBase`.\\n- `wikisPath` the name of the default wikis folder to use. If relative it is\\n  relative to `wikiPathBase`.\\n- `wikiPathBase` relative paths for everything other than serving files are\\n  relative to this path. If you want a portable setup this must be set to\\n  `cwd`, if you set it as `./` the paths are relative to the users home\\n  directory. It defaults to the current working directory. If this is set to a\\n  relative path it is relative to the user home directory.\\n- `includePluginList` is an array of plugin names that will be included in\\n  every wiki served. You do not have to include Bob in this list.\\n- `excludePluginList` is an array of plugin names that will not be included in\\n  any wiki served, even if it is listed in the tiddlywiki.info file. This does\\n  not prevent someone from installing the plugin via drag-and-drop or from a\\n  plugin library, it just affects plugins listed in `tiddlywiki.info` files.\\n- `autoUnloadWikis` if this is set to `true` than wikis with no active\\n  connections will be automatically unloaded from memory. (experimental, may\\n  cause problems)\\n- `disableBrowserAlerts` if this is set to `true` than no alerts are sent to\\n  the browser wikis. This can also be set on a per-wiki basis in the control\\n  panel.\\n- `disableFileWatchers` if this is set to `yes` than the file system monitor\\n  component is disabled. This may help with some setups that use network drives\\n  to store tiddlers.\\n- `fileURLPrefix` is the prefix used to distinguish file links from wikis. This\\n  has the normal restrictions on names as any URL, so avoid special characters.\\n  This defaults to `files` and only have an affect if you have also set\\n  `filePathRoot`.\\n  Note: If you set this to an empty string it will use the default value of\\n  `files` unless you set the `acceptance` value described below. This will break\\n  things and no tech support will be provided.\\n- `namespacedWikis` this only has an effect if you are using an external\\n  server with a login. If so this prefixes the wiki path with the currently\\n  logged in persons name when creating a wiki.\\n- `saveMediaOnServer` if this is set to `yes` any files with a type listed in\\n  the mime map are uploaded to the server and a `_canonical_uri` tiddler is\\n  created for the file instead of importing the file directly into the wiki.\\n  - This only takes effect if `enableFileServer` is also set to `yes`.\\n- `suppressBrowser` is only used if you are using the single executable\\n  version. If it is set to `true` than the browser isn't opened automatically\\n  when the server is started.\\n- `enableFederation` setting this to `yes` enables federation with remote\\n  servers.\\n- `enableFileServer` setting this to `yes` enables the static file server.\\n- `filePathRoot` this is the base path for files that are globally available.\\n- `perWikiFiles` setting this to `yes` means that files specific to a wiki\\n  (that is files in the wikis `files` folder next to the wikis `tiddlers`\\n  folder) are only available in that wiki, so no hotlinking.\\n- `enableBobSaver` setting this to `no` disables the Bob saver for single file\\n  wikis. By default this is enabled.\\n- `persistentUsernames` setting this to `yes` stores the user name entered for\\n  the wiki in a cookie so it is saved the next time you open the wiki using the\\n  same browser. As long as cookies aren't cleared and the cookie doesn't expire\\n  first.\\n- `scripts` a list of scripts that you can call from inside the wiki using the\\n  `runScript` websocket message.\\n- `wikis` a list of child wikis to serve. The path to the wikis is determined\\n  by the name given. In the example above the wiki located at\\n  `/home/inmysocks/TiddlyWiki/Wikis/OneWiki` would be served on\\n  `localhost:8080/OneWiki` and the wiki located at\\n  `/home/inmysocks/TiddlyWiki/Wikis/TestWiki` would be served on\\n  `localhost:8080/OokTech/TestWiki`. You may have as many levels and wikis as\\n  you want.\\n- `ws-server` settings for the `wsserver` command.\\n  - `port`\\n  - `host`\\n  - `rootTiddler` changing this will probably break everything\\n  - `renderType` changing this will probably break everything\\n  - `serveType` changing this will probably break everything\\n  - `pathprefix` a prefix for the path that wikis are served on.\\n  - `autoIncrementPort` if not set to `false` than the server\\n    will try using the given port (`8080` by default) and if it is in use it\\n    will try the next port up and continue until it finds an open port to use.\\n    If this is set to false than if the given port is in use an error is thrown\\n    and the process fails.\\n  - `servePlugin` is not `false` than any child wiki served will include the\\n    Bob plugin. So you can serve wikis that don't normally have the plugin and\\n    edit them as though they did.\\n- `heartbeat` settings for the heartbeat that makes sure the browser and server\\n  are still connected. You can almost certainly ignore these settings.\\n  - `interval` the heartbeat message is sent every `interval` milliseconds\\n  (1000 milliseconds = 1 second).\\n  - `timeout` is the length of time to wait for a heartbeat signal before\\n  assuming that the connection is no longer working.\\n- `mimeMap` lists the file extensions and their associated mime-types that the\\n  server is allowed to serve. This only has an effect if `filePathRoot` is set.\\n- `API` things in this group are used for the api used for inter-server\\n  communication using the TWederBob plugin. This is only active if you use the\\n  `--wsserver` command, if you use an external server than these don't do\\n  anything.\\n  - `enablePush` if this is set to `yes` than the server will accept tiddlers\\n    pushed using the TWederBob plugin.\\n  - `enableFetch` if this is set to `yes` than the server will let people fetch\\n    tiddlers from the server using the TWederBob plugin.\\n  - `pluginLibrary` if this is set to `yes` than the server will act as a\\n    plugin library. (you also have to set the `pluginsPath`, see above)\\n- `logger` settings for the logger Bob uses\\n  - `useFileLogging` set to `yes` to enable writing logs to files\\n  - `fileLogLevel` set this to an integer from `0` to `4` to indicate how\\n    much logging you want in the log files. `0` is none, `4` is everything.\\n  - `outputFolder` set to the folder name to use for the log files\\n  - `outputBaseFileName` logs will use this as the base name\\n  - `useSeparateErrorFile` set to `yes` if you want to have separte files for\\n    logs and error messages (stdout vs stderr)\\n  - `outputErrorFileName` set this to the base file name to use for error log files\\n  - `ignoreErrors` set this to `yes` to ignore logger errors (recommended!)\\n  - `useBrowserLogging` set this to `yes` to have log messages sent to the\\n    browser\\n  - `browserLogLevel` set this to an integer from `0` to `4` to indicate how\\n    much logging you want in the browser. `0` is none, `4` is everything.\\n  - `useConsoleLogging` set this to `yes` to log output to the console\\n  - `consoleLogLevel` set this to an integer from `0` to `4` to indicate how\\n    much logging you want in the console. `0` is none, `4` is everything.\\n- `federation` settings for inter-server federation and connections\\n  - `serverName` is the human readable name that the server uses to identify\\n    itself. It does not need to be unique, but having it be unique is less\\n    confusing.\\n  - `mobile` set this to `yes` if the server isn't going to have the same url\\n    or ip address all the time.\\n  - `enableChat` set this to `yes` to enable the federated chat server.\\n  - `udpPort` this is the port used by the udp socket used to connect to other\\n    servers.\\n  - `multicastAddress` this is the multicast ip used for using multicast on the\\n    local network to find other servers.\\n  - `broadcast` if `yes` Bob will periodically send udp multicast messages to announce its presence to other Bob servers.\\n  - `rebroadcastInterval` if `broadcast` is set to `yes` this is the interval between udp multicast messages\\n  - `checkConnections` if set to `yes` the server will send a ping trying to contact any known servers to maintain\\n- `advanced` these are advanced settings that should almost never have to be\\n  changed. Changing these values can cause undesired or unexpected behaviour.\\n  - `localMessageQueueTimeout` for local messages, the maximum time the server\\n    will wait for an acknowledgement before assuming that a message has been\\n    lost and the server tries to resend the message. The value is in ms.\\n    Default `500`. Smaller values may cause lots of retries even when a message\\n    is sent correctly, larger values make the server take longer to respond to\\n    errors.\\n  - `federatedMessageQueueTimeout` for federated messages, the maximum time\\n    that the server will wait for an acknowledgement before assuming that a\\n    message has been lost and tries to resend the message. The value is in ms.\\n    Default `1500`. Smaller values may cause lots of retries even when a\\n    message is sent correctly, larger values make the server take longer to\\n    respond to errors.\\n  - `saveTiddlerDelay` the minimum delay between when a save tiddler message is\\n    added to the message queue and when it is sent. This prevents save tiddler\\n    messages from being sent with each keystroke when editing certain tiddlers\\n    causing a race condition and giving unexpected results or an infinite\\n    update loop. The value is in ms. Default: `200`. Smaller values may cause\\n    more race conditions. Larger values make the server wait longer before\\n    saving a tiddler.\\n- `servingFiles` this lists the prefixes and folders that hold files that can\\n  be served.\\n  - The items in this are in the form `prefix: /path/to/folder`, see the file\\n    server documentation for more.\\n- `saver` this holds settings for the single file saver\\n  - `host` the host for the saver server. You should never change this. if you\\n    change this you will get no assistance for anything that you lose, break or\\n    have stolen from you. Changing this requires you to fill out the\\n    `acceptance` field below.\\n  - `port` the port that the saver listens on. Changing this can break the\\n    saver, so only change it if you know what you are doing.\\n  - `key` an optional key, if this is set than the same key has to be entered\\n    in each of the single file wikis in order for the server to save them.\\n  - `disable` set this to `yes` to disable the single file saver sever\\n- `backups` this holds settings for automatic backups\\n  - `enable` if this is set to `yes` automatic backups are enabled\\n  - `backupFolder` the folder to store the backups in.\\n  - `backupInterval` how long to wait after a change to make a backup in ms.\\n    Default is `600000`, which is 10 minutes,\\n  - `saveOnLoad` if this is set to `yes` a backup will be saved when a wiki is\\n    loaded.\\n  - `saveOnModified`if this is set to `yes` a backups will be triggered by\\n    edits to the wiki (see the documentation for important notes about this)\\n  - `maxBackups` is the maximum number of backups to keep for any wiki. If\\n    there are more than this the oldest are removed until there are at most\\n    this number of backups.\\n- `acceptance` this is a setting for accepting that you will get no help if you\\n  do something that requires it to be set. These are things that are either\\n  insecure or have a very good chance of breaking your wiki. You will get no\\n  tech support if you do any of them. If you want to do it anyway than you need\\n  to give this the value `I Will Not Get Tech Support For This`.\\n- `allowUnsafeMimeTypes` setting this to `true` lets you serve anything\\n  ignoring the mimeMap. This is a bad idea but it was consistently requested so\\n  you have to fill out the `acceptance` key and you will receive no support for\\n  any problems that arise.\\n\\n''Note:'' Only changes to the `scripts` and `wikis` will be available without\\nrestarting the server. You still need to save the settings using the\\n`Update Settings` button after making changes in the `Manual Settings` tab\\nunder the `Bob Settings` tab in the $:/ControlPanel. If you change a wiki name\\nor path you also need to click on the `Update Routes` button after you click on\\nthe `Update Settings` button for your changes to take effect.\\n\\nAny other changes require a full server restart.\\n\",\n            \"type\": \"text/x-markdown\"\n        },\n        \"$:/plugins/Bob/ConflictList\": {\n            \"title\": \"$:/plugins/Bob/ConflictList\",\n            \"caption\": \"Conflict List\",\n            \"text\": \"These are the tiddlers that currently have conflicts from resyncing with the server:\\n\\n<$list\\n  filter='[prefix[$:/state/Bob/Conflicts/]]'\\n  variable='dummy'\\n  emptyMessage=\\\"''There are no syncing conflicts, you can close this tiddler''\\\"\\n>\\n  <table\\n    style='width:100%'\\n  >\\n    <tr>\\n      <th>\\n        Server Version\\n      </th>\\n      <th>\\n        Conflicted Version\\n      </th>\\n    </tr>\\n    <$list\\n      filter='[prefix[$:/state/Bob/Conflicts/]]'\\n    >\\n      <tr>\\n        <td>\\n        <$list\\n          filter='[<currentTiddler>removeprefix[$:/state/Bob/Conflicts/]]'\\n        >\\n          <$link>\\n            <<currentTiddler>>\\n          </$link>\\n        </$list>\\n        </td>\\n        <td>\\n          <$link\\n            to=<<currentTiddler>>\\n          >\\n            Conflicted Version\\n          </$link>\\n        </td>\\n      </tr>\\n    </$list>\\n  </table>\\n</$list>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/BackupsTab\": {\n            \"title\": \"$:/plugins/OokTech/Bob/BackupsTab\",\n            \"caption\": \"Backups\",\n            \"text\": \"\\\\define settingAction(name, value) <$action-updatesetting backups=\\\"\\\"\\\"{<<__name__>>: <<__value__>>}\\\"\\\"\\\"/>\\n\\nBob can automatically save backups of wikis.\\nThe backups are saved as single file html wikis without Bob, they can be opened\\nand used like a normal single file wiki.\\n\\nThis is a global setting and applies to all the wikis that Bob serves.\\n\\n<$checkbox\\n  tiddler=\\\"$:/WikiSettings/split/backups\\\"\\n  index=enable\\n  checked=yes\\n  unchecked=no\\n  checkactions='<$action-updatesetting backups=\\\"\\\"\\\"{\\\"enable\\\": \\\"yes\\\"}\\\"\\\"\\\"/>'\\n  uncheckactions='<$action-updatesetting backups=\\\"\\\"\\\"{\\\"enable\\\": \\\"no\\\"}\\\"\\\"\\\"/>'\\n>\\n  Enable backups\\n</$checkbox> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutEnableBackups\\\">>\\n\\n!! Advanced\\n\\nThese are advanced settings for the automatic backups.\\nUnless you have a specific need that isn't addressed by the way the backups\\nwork by default you shouldn't change any of this.\\n\\nPlease read and understand\\n[[the documentation|$:/plugins/OokTech/Bob/Documentation/AutomaticBackup]]\\nbefore submitting a bug report about anything in this section.\\n\\n<$checkbox\\n  tiddler=\\\"$:/WikiSettings/split/backups\\\"\\n  index=\\\"saveOnLoad\\\"\\n  checked=\\\"yes\\\"\\n  unchecked=\\\"no\\\"\\n  checkactions=\\\"\\\"\\\"<$action-updatesetting backups='{\\\"saveOnLoad\\\": \\\"yes\\\"}'/>\\\"\\\"\\\"\\n  uncheckactions=\\\"\\\"\\\"<$action-updatesetting backups='{\\\"saveOnLoad\\\": \\\"no\\\"}'/>\\\"\\\"\\\"\\n>\\n  Save backup when wiki is loaded\\n</$checkbox> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutSaveBackupOnLoad\\\">>\\n\\n<$checkbox\\n  tiddler=\\\"$:/WikiSettings/split/backups\\\"\\n  index=saveOnModified\\n  checked=yes\\n  unchecked=no\\n  checkactions='<$action-updatesetting backups=\\\"\\\"\\\"{\\\"saveOnModified\\\": \\\"yes\\\"}\\\"\\\"\\\"/>'\\n  uncheckactions='<$action-updatesetting backups=\\\"\\\"\\\"{\\\"saveOnModified\\\": \\\"no\\\"}\\\"\\\"\\\"/>'\\n>\\n  Trigger backup when wiki is modified\\n</$checkbox>  <<helpButton \\\"$:/plugins/OokTech/Bob/AboutSaveBackupOnEdit\\\">>\\n\\nSave interval for backups: <$edit-text\\n    tiddler='$:/state/Bob/BackupSettings'\\n    field='backup_interval'\\n    placeholder={{$:/WikiSettings/split/backups##backupInterval}}\\n  />\\n<$button>\\n  Save setting\\n  <$macrocall\\n    $name=settingAction\\n    name=backupInterval\\n    value={{$:/state/Bob/BackupSetting!!backup_interval}}\\n  />\\n</$button> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutBackupSaveInterval\\\">>\\n\\nBackups folder: <$edit-text\\n    tiddler='$:/state/Bob/BackupSettings'\\n    field='backups_folder'\\n    placeholder={{$:/WikiSettings/split/backups##backupFolder}}\\n  />\\n<$button>\\n  Save setting\\n  <$macrocall\\n    $name=settingAction\\n    name=backupsFolder\\n    value={{$:/state/Bob/BackupSetting!!backups_folder}}\\n  />\\n</$button> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutBackupsFolder\\\">>\\n\\nMaximum Backups per wiki: <$edit-text\\n    tiddler='$:/state/Bob/BackupSettings'\\n    field='max_backups'\\n    placeholder={{$:/WikiSettings/split/backups##maxBackups}}\\n  />\\n<$button>\\n  Save setting\\n  <$macrocall\\n    $name=settingAction\\n    name=maxBackups\\n    value={{$:/state/Bob/BackupSetting!!max_backups}}\\n  />\\n</$button> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutMaximumBackupsPerWiki\\\">>\"\n        },\n        \"$:/plugins/OokTech/Bob/ControlPanelTab\": {\n            \"title\": \"$:/plugins/OokTech/Bob/ControlPanelTab\",\n            \"tags\": \"$:/tags/ControlPanel\",\n            \"caption\": \"Bob\",\n            \"text\": \"Wiki Server Address (<$reveal type='nomatch' state='$:/ServerIP!!host' text='0.0.0.0'>not </$reveal>available on local network):\\n<pre>{{$:/ServerIP}}:{{$:/ServerIP!!port}}</pre>\\n\\nClick the ^^(?)^^ next to options for more information.\\n\\n<$linkcatcher\\n  to='$:/state/Bob/ShowSettingTab'\\n>\\n\\n* [[Setup This Wiki|$:/plugins/OokTech/Bob/ThisWikiTab]] - manage plugins and themes for this wiki\\n* [[Backups|$:/plugins/OokTech/Bob/BackupsTab]] - enable and setup automatic backups\\n* [[Wiki Management|$:/plugins/OokTech/Bob/ManageWikis]] - create, delete and rename wikis\\n* [[Saver Server|$:/plugins/OokTech/Bob/SaverServer]] - enable and configure the saver for single file wikis\\n* [[File Server|$:/plugins/OokTech/Bob/FileServerSetup]] - setup file server so that you can access local media files\\n* [[Server Settings|$:/plugins/OokTech/Bob/ServerTab]] - logging and manual settings\\n<!--* [[Federation|$:/plugins/OokTech/Bob/FederationTab]] - federated chat and set up wiki syncing between this server and other Bob servers-->\\n* [[Written Documentation|$:/plugins/OokTech/Bob/Documentation/Bob Documentation]] - more details\\n* [[About OokTech/Support Development|$:/plugins/OokTech/Bob/OokTechInfo]] - About the people who make Bob\\n\\n</$linkcatcher>\\n\\n<$button>\\n  Download HTML version of this wiki\\n  <$action-downloadwiki/>\\n</$button> <<helpButton $:/plugins/OokTech/Bob/AboutDownloadHTMLVersion>>\\n\\n---\\n\\n<$list\\n  filter='[{$:/state/Bob/ShowSettingTab}]'\\n>\\n\\n  <h2>\\n    <$view\\n      field='caption'\\n    >\\n      <$view\\n        field='title'\\n      >\\n      </$view>\\n    </$view>\\n  </h2>\\n\\n  <$transclude/>\\n\\n</$list>\\n\\n<!--\\n<$reveal type='nomatch' state='$:/settings/Bob/Verbose' text='false'>\\n\\n  If you are comfortable with Bob and don't need long labels you can set this to `Compact Help` and remove many of the help labels to make the interface more compact.\\n\\n</$reveal>\\n\\n<$radio\\n  tiddler='$:/settings/Bob/Verbose'\\n  field='text'\\n  value='false'\\n>\\n  Compact Help\\n</$radio>\\n<$radio\\n  tiddler='$:/settings/Bob/Verbose'\\n  field='text'\\n  value='true'\\n>\\n  Verbose Help\\n</$radio>\\n\\n<$reveal\\n  type='nomatch'\\n  state='$:/WikiName!!text'\\n  text='RootWiki'\\n>\\n  <$checkbox\\n    tiddler='$:/settings/Bob/DisplayOnChildWikis'\\n    field='text'\\n    checked='yes'\\n    unchecked='no'\\n  >\\n    Show Full Settings\\n  </$checkbox>\\n</$reveal>\\n\\n<$reveal\\n  type='nomatch'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n\\n  See [[exporting wikis|$:/plugins/OokTech/Bob/Documentation/Exporting Wikis]] for information\\n  about different ways to save or export your wikis.\\n\\n  This saves the wiki to the server, it doesn't download it.\\n  <$button>\\n    Save Single File Wiki\\n    <$action-websocketmessage\\n      $type='buildHTMLWiki'\\n    />\\n  </$button>\\n\\n  This downloads the current wiki as a single file wiki.\\n  <$button>\\n    Download Single File Version\\n    <$action-downloadwiki\\n    />\\n  </$button>\\n\\n</$reveal>\\n\\n<$reveal type='match' state='$:/settings/Bob/Verbose' text='false'>\\n\\n  <$button>\\n    Save HTML Wiki to Server\\n    <$action-websocketmessage\\n      $type='buildHTMLWiki'\\n    />\\n  </$button>\\n  <$button>\\n    Download HTML Version\\n    <$action-downloadwiki\\n    />\\n  </$button>\\n\\n</$reveal>\\n\\n<$list\\n  filter='[[$:/WikiName]text[RootWiki]][[$:/settings/Bob/DisplayOnChildWikis]text[yes]] +[limit[1]]'\\n  emptyMessage=\\\"\\\"\\\"<<tabs \\\"[[$:/plugins/OokTech/Bob/ManageWikis]][[$:/plugins/OokTech/Bob/ThisWikiTab]][[$:/plugins/OokTech/Bob/ServerMessageHistory]][[$:/plugins/OokTech/Bob/SaverServer]][[$:/plugins/OokTech/Bob/OokTechInfo]]\\\" \\\"$:/plugins/OokTech/Bob/Wiki Listing\\\">>\\\"\\\"\\\"\\n>\\n  <<tabs \\\"[[$:/plugins/OokTech/Bob/ManageWikis]][[$:/plugins/OokTech/Bob/ThisWikiTab]][[$:/plugins/OokTech/Bob/ServerTab]][[$:/plugins/OokTech/Bob/FederationTab]][[$:/plugins/OokTech/Bob/SaverServer]][[$:/plugins/OokTech/Bob/BackupsTab]][[$:/plugins/OokTech/Bob/Documentation/Bob Documentation]][[$:/plugins/OokTech/Bob/OokTechInfo]]\\\" \\\"$:/plugins/OokTech/Bob/ManageWikis\\\">>\\n</$list>\\n-->\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/CreateWikiFromEdition\": {\n            \"title\": \"$:/plugins/OokTech/Bob/CreateWikiFromEdition\",\n            \"caption\": \"Create Wiki From Edition\",\n            \"text\": \"<$set\\n  name=ListedEditions\\n  filter='[[$:/ListedEditions]has[text]]'\\n  emptyValue=\\\"[[$:/Bob/AvailableEditionList]indexes[]]\\\"\\n  value=\\\"[enlist{$:/ListedEditions}]\\\"\\n  select=0\\n>\\n  Select Wiki Edition:\\n  <$select\\n    tiddler='$:/temp/NewWiki'\\n    field='edition'\\n  >\\n    <$list\\n      filter=<<ListedEditions>>\\n    >\\n      <option>\\n        <<currentTiddler>>\\n      </option>\\n    </$list>\\n  </$select>\\n</$set> ([[Change Listed Editions|$:/plugins/OokTech/Bob/CreateWikiFromEdition/SetListedEditions]])\\n<br>\\nGive the wiki a name:\\n<$edit-text\\n  tiddler='$:/temp/NewWiki'\\n  field='wiki_name'\\n/>\\n\\n<$button>\\n  Make Wiki\\n  <$action-websocketmessage\\n    $type='createNewWiki'\\n    path={{$:/temp/NewWiki!!wiki_name}}\\n    wikiName={{$:/temp/NewWiki!!wiki_name}}\\n    edition={{$:/temp/NewWiki!!edition}}\\n  />\\n  <$action-setfield\\n    $tiddler='$:/temp/NewWiki'\\n    wiki_name=''\\n  />\\n</$button>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/CreateWikiFromFile\": {\n            \"title\": \"$:/plugins/OokTech/Bob/CreateWikiFromFile\",\n            \"caption\": \"Create Wiki From File\",\n            \"text\": \"Select file: <input type='file' accepts='.html,.htm' id='#fileInput'/>\\n<br>\\nGive the wiki a name:\\n<$edit-text\\n  tiddler='$:/temp/NewWiki'\\n  field='wiki_name'\\n/>\\n\\n<$button>\\n  Make Wiki {{$:/temp/NewWiki!!wiki_name}}\\n  <$action-convertwiki\\n    fileInput='#fileInput'\\n    wikiName={{$:/temp/NewWiki!!wiki_name}}\\n  />\\n  <!--\\n  <$action-setfield\\n    $tiddler='$:/temp/NewWiki'\\n    wiki_name=''\\n  />\\n  <$action-websocketmessage\\n    $type='findAvailableWikis'\\n    update='true'\\n    saveSettings='true'\\n  />\\n  -->\\n</$button>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/CreateWikiFromNode\": {\n            \"title\": \"$:/plugins/OokTech/Bob/CreateWikiFromNode\",\n            \"caption\": \"Create Wiki From Node\",\n            \"text\": \"Note: After adding a wiki like this you may have to click the `Add Wiki`\\nbutton, wait a few seconds and then click on it again without entering a name\\nor a path in order to make the wiki load correctly.\\n<br>\\nGive the wiki a name:\\n<$edit-text\\n  tiddler='$:/temp/NewWiki'\\n  field='wiki_name'\\n/>\\n<br>\\nPath to wiki folder:\\n<$edit-text\\n  tiddler='$:/temp/NewWiki'\\n  field='wiki_folder_path'\\n/>\\n<br>\\n<$button>\\n  Add Wiki\\n  <$list\\n    filter='[[$:/temp/NewWiki]has[wiki_name]has[wiki_folder_path]]'\\n  >\\n    <$action-websocketmessage\\n      $type='createNewWiki'\\n      wikiName={{$:/temp/NewWiki!!wiki_name}}\\n      nodeWikiPath={{$:/temp/NewWiki!!wiki_folder_path}}\\n    />\\n    <!--\\n    <$action-setfield\\n      $tiddler='$:/WikiSettings/split/wikis'\\n      $index={{$:/temp/NewWiki!!wiki_name}}\\n      $value={{$:/temp/NewWiki!!wiki_folder_path}}\\n    />\\n    <$action-savesettings/>\\n    <$action-websocketmessage\\n      $type=updateRoutes\\n    />\\n    <$action-websocketmessage\\n      $type='findAvailableWikis'\\n      update='true'\\n      saveSettings='true'\\n    />\\n    -->\\n    <$action-setfield\\n      $tiddler='$:/temp/NewWiki'\\n      wiki_name=''\\n      wiki_folder_path=''\\n    />\\n  </$list>\\n</$button>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/CreateWikiFromTiddlers\": {\n            \"title\": \"$:/plugins/OokTech/Bob/CreateWikiFromTiddlers\",\n            \"caption\": \"Create Wiki From Tiddlers\",\n            \"text\": \"The transfrom field is entirely optional. See\\n[[transform filters|$:/plugins/OokTech/Bob/Transform Filters]] for more\\ninformation.\\n<br>\\nGive the wiki a name:\\n<$edit-text\\n  tiddler='$:/temp/NewWiki'\\n  field='wiki_name'\\n  default=''\\n  placeholder='Wiki Name'\\n/>\\n\\n<table>\\n  <tr>\\n    <th>\\n      Wiki <<helpButton \\\"$:/plugins/OokTech/Bob/AboutWikiFromTiddlersSource\\\">>\\n    </th>\\n    <th>\\n      Filter <<helpButton \\\"$:/plugins/OokTech/Bob/AboutWikiFromTiddlersFilter\\\">>\\n    </th>\\n    <th>\\n      Transfrom <<helpButton \\\"$:/plugins/OokTech/Bob/AboutWikiFromTiddlersTransfrom\\\">>\\n    </th>\\n    <th>\\n    </th>\\n  </tr>\\n  <$list\\n    filter='[[$:/temp/NewWiki]indexes[]]'\\n  >\\n    <tr>\\n      <td>\\n        <$view\\n          field='title'\\n        />\\n      </td>\\n      <td>\\n        <$edit-text\\n          tiddler='$:/temp/NewWiki'\\n          index=<<currentTiddler>>\\n          tag=input\\n        />\\n      </td>\\n      <td>\\n        <$edit-text\\n          tiddler='$:/temp/NewWiki/Transforms'\\n          index=<<currentTiddler>>\\n          tag=input\\n        />\\n      </td>\\n      <td>\\n        <$button>\\n          Remove Filter\\n          <$action-setfield\\n            $tiddler='$:/temp/NewWiki'\\n            $index=<<currentTiddler>>\\n          />\\n          <$action-setfield\\n            $tiddler='$:/temp/NewWiki/Transforms'\\n            $index=<<currentTiddler>>\\n          />\\n        </$button>\\n      </td>\\n    </tr>\\n  </$list>\\n</table>\\n\\nFrom Wiki: <$edit-text\\n  tiddler='$:/temp/NewWiki'\\n  field='from_wiki_name'\\n/>\\nFilter: <$edit-text\\n  tiddler='$:/temp/NewWiki'\\n  field='tiddler_filter'\\n/>\\nTransform: <$edit-text\\n  tiddler='$:/temp/NewWiki'\\n  field='transform_filter'\\n  tag=input\\n/>\\n\\n<$button>\\n  Add Filter\\n  <$action-setfield\\n    $tiddler='$:/temp/NewWiki'\\n    $index={{$:/temp/NewWiki!!from_wiki_name}}\\n    $value={{$:/temp/NewWiki!!tiddler_filter}}\\n  />\\n  <$action-setfield\\n    $tiddler='$:/temp/NewWiki/Transforms'\\n    $index={{$:/temp/NewWiki!!from_wiki_name}}\\n    $value={{$:/temp/NewWiki!!transform_filter}}\\n  />\\n  <$action-setfield\\n    $tiddler='$:/temp/NewWiki'\\n    from_wiki_name=''\\n    tiddler_filter=''\\n    transform_filter=''\\n  />\\n</$button>\\n<br>\\n<$button>\\n  Make Wiki\\n  <$action-websocketmessage\\n    $type=newWikiFromTiddlers\\n    wikiName={{$:/temp/NewWiki!!wiki_name}}\\n    externalTiddlers={{$:/temp/NewWiki!!text}}\\n    transformFilters={{$:/temp/NewWiki/Transforms!!text}}\\n  />\\n  <$action-setfield\\n    $tiddler='$:/temp/NewWiki'\\n    from_wiki_name=''\\n    tiddler_filter=''\\n    text='{}'\\n  />\\n  <$action-setfield\\n    $tiddler='$:/temp/NewWiki/Transforms'\\n    text='{}'\\n  />\\n  <!--\\n  <$action-websocketmessage\\n    $type='findAvailableWikis'\\n    update='true'\\n    saveSettings='true'\\n  />\\n  -->\\n</$button>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/DuplicateExisitingWiki\": {\n            \"title\": \"$:/plugins/OokTech/Bob/DuplicateExisitingWiki\",\n            \"caption\": \"Create a copy of an existing wiki\",\n            \"text\": \"<$reveal\\n  type='nomatch'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n  Using this you can make a duplicate of any existing wiki. It is like creating\\n  a wiki from an edition but it the list is wikis you use, not editions.\\n\\n  Select the wiki you want to duplicate from the drop-down menu, then enter a\\n  name for the new wiki and click `Create Duplicate Wiki`.\\n\\n  If you also want to duplicate all of the wikis child wikis check\\n  `Copy Child Wikis`, this creates copies of all of the child wikis from the\\n  original wiki and makes them children of the newly created wiki.\\n\\n  If no wiki is selected than this will create a new copy of the empty edition.\\n  If no name is given than this will generate an unused name for it.\\n\\n  If the name given for the new wiki is already in use than a number will be\\n  appended to the end to make the name unique.\\n</$reveal>\\n<br>\\nSelect Wiki:\\n<$select\\n  tiddler='$:/state/DuplicateWiki'\\n>\\n  <option\\n    value=''\\n  >\\n    Select Wiki\\n  </option>\\n  <$list\\n    filter='[list[$:/state/ViewableWikis]]'\\n  >\\n    <option>\\n      <<currentTiddler>>\\n    </option>\\n  </$list>\\n</$select>\\n<$checkbox\\n  tiddler='$:/state/DuplicateWiki'\\n  field='include_children'\\n  checked='yes'\\n  unchecked='no'\\n>\\n  Copy child wikis\\n</$checkbox>\\n<br>\\nNew Wiki Name: <$edit-text tiddler='$:/state/DuplicateWiki' field='wiki_name'/>\\n<br>\\n<$button>\\n  <$action-websocketmessage\\n    $type='duplicateWiki'\\n    fromWiki={{$:/state/DuplicateWiki}}\\n    newWiki={{$:/state/DuplicateWiki!!wiki_name}}\\n    copyChildren={{$:/state/DuplicateWiki!!include_children}}\\n  />\\n  Create Duplicate Wiki\\n</$button>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/CreateWikiFromEdition/SetListedEditions\": {\n            \"title\": \"$:/plugins/OokTech/Bob/CreateWikiFromEdition/SetListedEditions\",\n            \"text\": \"\\\\define thisPrefix() [[\\n\\n\\\\define thisSuffix() ]]\\n\\nEditions listed here will appear in the drop-down menu for creating new\\nwikis from editions. If no editions are listed here than all available editions\\nwill be listed for creating new wikis.\\n\\nAdd Edition To List:\\n<$select\\n  tiddler='$:/state/Bob/AddEditionToList'\\n>\\n  <option value=''>\\n    Select Edition\\n  </option>\\n  <$list\\n    filter='[[$:/Bob/AvailableEditionList]indexes[]search{$:/state/Bob/AddEditionToList!!search}] -[enlist{$:/ListedEditions!!text}]'\\n  >\\n    <$set\\n      name=Annoying\\n      filter='[<currentTiddler>]'\\n      emptyValue=<<currentTiddler>>\\n    >\\n      <option\\n        value=<<Annoying>>\\n      >\\n        <<currentTiddler>>\\n      </option>\\n    </$set>\\n  </$list>\\n</$select>\\n<$button>\\n  Add\\n  <$action-listops\\n    $tiddler='$:/ListedEditions'\\n    $field='text'\\n    $subfilter='+[append{$:/state/Bob/AddEditionToList}]'\\n  />\\n</$button>\\nNarrow List:\\n<$edit-text\\n  tiddler='$:/state/Bob/AddEditionToList'\\n  field='search'\\n/>\\n\\nCurrently Listed (uncheck to remove from list):\\n\\n<$list\\n  filter='[enlist{$:/ListedEditions!!text}]'\\n>\\n  <$button\\n    class='tc-btn-invisible'\\n  >\\n    <$list\\n      filter='[enlist{$:/ListedEditions!!text}title<currentTiddler>addprefix<thisPrefix>addsuffix<thisSuffix>]'\\n      emptyMessage=\\\"\\\"\\\"\\n        <input\\n          type='checkbox'\\n        />\\n        <$action-listops\\n          $tiddler='$:/ListedEditions'\\n          $field='text'\\n          $subfilter='+[append<currentTiddler>]'\\n        />\\\"\\\"\\\"\\n    >\\n      <input\\n        type='checkbox'\\n        checked\\n      />\\n      <$action-listops\\n        $tiddler='$:/ListedEditions'\\n        $field='text'\\n        $subfilter='+[remove<currentTiddler>]'\\n      />\\n    </$list>\\n    <$view\\n      tiddler=<<currentTiddler>>\\n      field=title\\n    />\\n  </$button>\\n  <br/>\\n</$list>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/CreateWikis\": {\n            \"title\": \"$:/plugins/OokTech/Bob/CreateWikis\",\n            \"caption\": \"Create Wikis\",\n            \"text\": \"You can create new wikis here. Select the edition and then enter a name.\\n\\nWiki names should be able to contain any unicode characters, although there may\\nbe errors in some browsers which do not support unicode urls.\\nSo  is a valid wiki name.\\n\\nSee\\n[[creating new wikis|$:/plugins/OokTech/Bob/Documentation/Creating New Wikis]]\\nfor more information about making wikis.\\n\\nCreate a wiki from\\n\\n<$radio\\n  tiddler='$:/temp/NewWiki'\\n  field='method'\\n  value='edition'\\n>\\n  an edition\\n</$radio> <<helpButton $:/plugins/OokTech/Bob/AboutCreateFromEdition>>\\n<br>\\n<$radio\\n  tiddler='$:/temp/NewWiki'\\n  field='method'\\n  value='file'\\n>\\n  an html file\\n</$radio> <<helpButton $:/plugins/OokTech/Bob/AboutCreateFromHTML>>\\n<br>\\n<$radio\\n  tiddler='$:/temp/NewWiki'\\n  field='method'\\n  value='tiddlers'\\n>\\n  existing tiddlers\\n</$radio> <<helpButton $:/plugins/OokTech/Bob/AboutCreateFromTiddlers>>\\n<br>\\n<$radio\\n  tiddler='$:/temp/NewWiki'\\n  field='method'\\n  value='node'\\n>\\n  a node wiki\\n</$radio> <<helpButton $:/plugins/OokTech/Bob/AboutCreateFromNode>>\\n<br>\\n<$radio\\n  tiddler='$:/temp/NewWiki'\\n  field='method'\\n  value='duplicate'\\n>\\n  duplicate an existing wiki\\n</$radio> <<helpButton $:/plugins/OokTech/Bob/AboutDuplicateWiki>>\\n\\n<$list\\n  filter='[[$:/temp/NewWiki]!has[method]][[$:/temp/NewWiki]method[edition]]+[limit[1]]'\\n  variable=null\\n>\\n  {{$:/plugins/OokTech/Bob/CreateWikiFromEdition}}\\n</$list>\\n\\n\\n<$list\\n  filter='[[$:/temp/NewWiki]method[file]]'\\n  variable=null\\n>\\n  {{$:/plugins/OokTech/Bob/CreateWikiFromFile}}\\n</$list>\\n\\n<$list\\n  filter='[[$:/temp/NewWiki]method[tiddlers]]'\\n  variable=null\\n>\\n  {{$:/plugins/OokTech/Bob/CreateWikiFromTiddlers}}\\n</$list>\\n\\n<$list\\n  filter='[[$:/temp/NewWiki]method[node]]'\\n  variable=null\\n>\\n  {{$:/plugins/OokTech/Bob/CreateWikiFromNode}}\\n</$list>\\n\\n<$list\\n  filter='[[$:/temp/NewWiki]method[duplicate]]'\\n  variable=null\\n>\\n  {{$:/plugins/OokTech/Bob/DuplicateExisitingWiki}}\\n</$list>\\n\\n<!--\\n---\\n\\nClick this button to automatically list all wikis in your wikis folder.\\nChecking the box will also remove any links to wikis that don't exist.\\n\\n<$button>\\n  Auto-populate list from Wikis folder\\n  <$action-websocketmessage\\n    $type='findAvailableWikis'\\n    remove={{$:/state/Bob/removemissingwikis!!text}}\\n    update='true'\\n    saveSettings='true'\\n  />\\n</$button>\\n\\n<$checkbox\\n  tiddler='$:/state/Bob/removemissingwikis'\\n  checked='true'\\n  unchecked='false'\\n  field='text'\\n>\\n  Remove links to missing wikis\\n</$checkbox>\\n</$reveal>\\n\\n<$reveal\\n  type='match'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n\\n  Create wiki from\\n\\n  <$radio\\n    tiddler='$:/temp/NewWiki'\\n    field='method'\\n    value='edition'\\n  >\\n    an edition\\n  </$radio>\\n  <br>\\n  <$radio\\n    tiddler='$:/temp/NewWiki'\\n    field='method'\\n    value='file'\\n  >\\n    an html file\\n  </$radio>\\n  <br>\\n  <$radio\\n    tiddler='$:/temp/NewWiki'\\n    field='method'\\n    value='tiddlers'\\n  >\\n    existing tiddlers\\n  </$radio>\\n  <br>\\n  <$radio\\n    tiddler='$:/temp/NewWiki'\\n    field='method'\\n    value='node'\\n  >\\n    a node wiki\\n  </$radio>\\n\\n  <$list\\n    filter='[[$:/temp/NewWiki]!has[method]][[$:/temp/NewWiki]method[edition]]+[limit[1]]'\\n    variable=null\\n  >\\n    {{$:/plugins/OokTech/Bob/CreateWikiFromEdition}}\\n  </$list>\\n\\n\\n  <$list\\n    filter='[[$:/temp/NewWiki]method[file]]'\\n    variable=null\\n  >\\n    {{$:/plugins/OokTech/Bob/CreateWikiFromFile}}\\n  </$list>\\n\\n  <$list\\n    filter='[[$:/temp/NewWiki]method[tiddlers]]'\\n    variable=null\\n  >\\n    {{$:/plugins/OokTech/Bob/CreateWikiFromTiddlers}}\\n  </$list>\\n\\n  <$list\\n    filter='[[$:/temp/NewWiki]method[node]]'\\n    variable=null\\n  >\\n    {{$:/plugins/OokTech/Bob/CreateWikiFromNode}}\\n  </$list>\\n\\n---\\n\\n  <$button>\\n    Auto-populate list\\n    <$action-websocketmessage\\n      $type='findAvailableWikis'\\n      remove={{$:/state/Bob/removemissingwikis!!text}}\\n      update='true'\\n      saveSettings='true'\\n    />\\n  </$button>\\n  <$checkbox\\n    tiddler='$:/state/Bob/removemissingwikis'\\n    checked='true'\\n    unchecked='false'\\n    field='text'\\n  >\\n    Remove missing wikis\\n  </$checkbox>\\n</$reveal>\\n\\n{{$:/plugins/OokTech/Bob/Wiki Listing}}\\n-->\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/DeleteWikis\": {\n            \"title\": \"$:/plugins/OokTech/Bob/DeleteWikis\",\n            \"caption\": \"Delete Wikis\",\n            \"text\": \"\\\\define updateNameActions()\\n<$action-websocketmessage\\n  $type='deleteWiki'\\n  deleteWiki={{$:/state/DeleteWiki!!delete_wiki}}\\n  deleteChildren={{$:/state/DeleteWiki!!delete_children}}\\n/>\\n<$action-setfield\\n  $tiddler='$:/state/DeleteWiki'\\n  delete_wiki=''\\n  delete_children=''\\n/>\\n\\\\end\\n\\n<$reveal\\n  type='nomatch'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n\\n</$reveal>\\n\\nSelect Wiki:\\n<$select\\n  tiddler='$:/state/DeleteWiki'\\n  field='delete_wiki'\\n>\\n  <option\\n    value=''\\n  >\\n    Select Wiki\\n  </option>\\n  <$list\\n    filter='[list[$:/state/ViewableWikis]]'\\n  >\\n    <option>\\n      <<currentTiddler>>\\n    </option>\\n  </$list>\\n</$select> <<helpButton $:/plugins/OokTech/Bob/AboutDeleteWikiSelect>>\\n\\n<$checkbox\\n  tiddler='$:/state/DeleteWiki'\\n  field='delete_children'\\n  checked='yes'\\n  unchecked='no'\\n>\\n  Delete Children\\n</$checkbox> <<helpButton $:/plugins/OokTech/Bob/AboutDeleteWikiSelect>>\\n\\n<$button\\n  actions=<<updateNameActions>>\\n>\\n  Delete Wiki\\n</$button>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/FederationTab/ActiveConnections\": {\n            \"title\": \"$:/plugins/OokTech/Bob/FederationTab/ActiveConnections\",\n            \"caption\": \"Active Connections\",\n            \"tags\": \"FederationTab\",\n            \"text\": \"These are the currently active connections between your server and remote\\nservers.\\n\\n<table>\\n  <tr>\\n    <th>\\n      Node Name\\n    </th>\\n    <th>\\n      IP:PORT\\n    </th>\\n  </tr>\\n  <$list\\n    filter='[list[$:/Bob/ActiveConnections]]'\\n  >\\n    <tr>\\n      <td>\\n        <$view\\n          index=serverName\\n        >\\n          <<currentTiddler>>\\n        </$view>\\n      </td>\\n      <td>\\n        //something//\\n      </td>\\n    </tr>\\n  </$list>\\n</table>\"\n        },\n        \"$:/plugins/OokTech/Bob/FederationTab/ChatInterface\": {\n            \"title\": \"$:/plugins/OokTech/Bob/FederationTab/ChatInterface\",\n            \"caption\": \"Chat Interface\",\n            \"tags\": \"FederationTab\",\n            \"text\": \"This is the basic chat interface that uses the federated connections.\\n\\nCurrent Name:\\n<$edit-text\\n  tiddler='$:/temp/Bob/Federation/ChatMessage'\\n  field='from'\\n  default=''\\n/>\\n\\n<$chatview\\n  tiddler='$:/chat/DefaultChat'\\n/>\\n\\n<$list\\n  filter='[[$:/chats/DefaultChat]indexes[]]'\\n  variable=CurrentTimestamp\\n>\\n  <<CurrentTimeStamp>>\\n  <$view\\n    tiddler='$:/chats/DefaultChat'\\n    index=<<currentTimeStamp>>\\n  />\\n  <br/>\\n</$list>\\n\\n<$keyboard\\n  actions=\\\"\\\"\\\"\\n    <$action-websocketmessage\\n      $type='chatMessage'\\n      message={{$:/temp/Bob/Federation/ChatMessage}}\\n      from={{$:/temp/Bob/Federation/ChatMessage!!from}}\\n    />\\n    <$action-setfield\\n      $tiddler='$:/temp/Bob/Federation/ChatMessage'\\n      text=''\\n    />\\n  \\\"\\\"\\\"\\n  key=enter\\n>\\n  <$edit-text\\n    tiddler='$:/temp/Bob/Federation/ChatMessage'\\n    class='tc-edit-texteditor'\\n    tag='input'\\n    default=''\\n  />\\n</$keyboard>\\n\\n<$button>\\n  Send\\n  <$action-websocketmessage\\n    $type='chatMessage'\\n    message={{$:/temp/Bob/Federation/ChatMessage}}\\n  />\\n  <$action-setfield\\n    $tiddler='$:/temp/Bob/Federation/ChatMessage'\\n    text=''\\n  />\\n</$button>\\n\\n''TODO'' make the input field detect the length of the input and if the input\\nis too long have it change from a single line input to a multi-line input.\\nThe difficult part may be making it not lose focus and cursor position.\\nIt may have to be a new javascript widget.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/FederationTab/KnownServers\": {\n            \"title\": \"$:/plugins/OokTech/Bob/FederationTab/KnownServers\",\n            \"caption\": \"Known Servers\",\n            \"tags\": \"FederationTab\",\n            \"text\": \"Manage connections\\n\\nThese are the remote servers you currently have information about.\\n\\nEach server gets a JSON tiddler named in the form\\n\\n`$:/Bob/KnownServers/ServerKey`\\n\\n<table>\\n  <tr>\\n    <th>\\n      Name\\n    </th>\\n    <th>\\n      Login?\\n    </th>\\n    <th>\\n      Wikis\\n    </th>\\n    <th>\\n      Chats\\n    </th>\\n  </tr>\\n  <$list\\n    filter='[prefix[$:/Bob/KnownServers/]]'\\n  >\\n    <tr>\\n      <th>\\n        <$view\\n          field='name'\\n        />\\n      </th>\\n      <td>\\n        <$view\\n          field='allows_login'\\n        />\\n      </td>\\n      <td>\\n        <$count filter='[enlist{!!available_wikis}]'/> wikis available\\n      </td>\\n      <td>\\n        <$count filter='[enlist{!!available_chats}]'/> chats available\\n      </td>\\n    </tr>\\n  </$list>\\n</table>\"\n        },\n        \"$:/plugins/OokTech/Bob/FederationTab/WikiSyncing\": {\n            \"title\": \"$:/plugins/OokTech/Bob/FederationTab/WikiSyncing\",\n            \"caption\": \"Wiki Syncing\",\n            \"tags\": \"FederationTab\",\n            \"text\": \"Select Server:\\n<$select\\n  tiddler='$:/state/Federation/SelectedRemoteServer'\\n  default='Add Server'\\n>\\n  <option\\n    value='Add Server'\\n  >\\n    Add Server\\n  </option>\\n  <$list\\n    filter='[tag[Remote Server]]'\\n  >\\n    <option\\n      value=<<currentTiddler>>\\n    >\\n      <$view\\n        field='name'\\n      >\\n        <$view\\n          field='title'\\n        />\\n      </$view>\\n    </option>\\n  </$list>\\n</$select>\\n\\n<$list\\n  filter='[{$:/state/Federation/SelectedRemoteServer}has[title]]-[[Add Server]]'\\n  emptyMessage={{$:/plugins/OokTech/Bob/Federation/AddRemoteServerTemplate}}\\n>\\n\\n  {{||$:/plugins/OokTech/Bob/Federation/RemoteServerTemplate}}\\n</$list>\"\n        },\n        \"$:/plugins/OokTech/Bob/FederationTab\": {\n            \"title\": \"$:/plugins/OokTech/Bob/FederationTab\",\n            \"caption\": \"Federation\",\n            \"text\": \"These are things for inter-server federation\\n\\n<$checkbox>\\n  Enable Federation\\n</$checkbox> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutEnableFederation\\\">>\\n\\n<$checkbox>\\n  Announce on the local network\\n</$checkbox> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutAnnounceOnLocalNetwork\\\">>\\n\\n<<tabs \\\"[all[tiddlers+shadows]tag[FederationTab]]\\\">>\"\n        },\n        \"$:/plugins/OokTech/Bob/FileServerSetup\": {\n            \"title\": \"$:/plugins/OokTech/Bob/FileServerSetup\",\n            \"caption\": \"File Server\",\n            \"text\": \"\\\\define enableFileServerCheckActions()\\n  <$list\\n    filter='[[$:/WikiSettings/split]getindex[filePathRoot]]'\\n    emptyMessage=\\\"\\\"\\\"<$action-websocketmessage\\n      $type='updatesetting'\\n      filePathRoot='./files'\\n    />\\\"\\\"\\\"\\n  >\\n  </$list>\\n  <$action-updatesetting\\n    enableFileServer='yes'\\n  />\\n\\\\end\\n\\n\\\\define enableFileServerUncheckActions()\\n  <$action-updatesetting\\n    enableFileServer='no'\\n  />\\n\\\\end\\n\\n\\\\define saveMediaOnServerCheckActions()\\n  <$action-updatesetting\\n    saveMediaOnServer='yes'\\n  />\\n\\\\end\\n\\n\\\\define saveMediaOnServerUncheckActions()\\n  <$action-updatesetting\\n    saveMediaOnServer='no'\\n  />\\n\\\\end\\n\\nThese are options for how to turn on and configure the file server included in\\nBob.\\n\\n''Big Note of Doom:'' You can, of course, set these options to whatever you\\nchoose. But if you don't know what you are doing I strongly urge you to follow\\nthe advice for each setting. If this is improperly configured than you could be\\ngiving everyone in the coffee shop access to you tax documents and photos.\\n\\n''Smaller Note of Caution:'' If you have Bob setup to be accessible on the\\nlocal network than any files Bob is serving are also accessible on the local\\nnetwork. So be careful to not put sensitive personal information in any wikis\\nand make Bob available to the local network away from your home network.\\n\\n---\\n\\n<$checkbox\\n  checkactions=<<enableFileServerCheckActions>>\\n  uncheckactions=<<enableFileServerUncheckActions>>\\n  tiddler='$:/WikiSettings/split'\\n  index='enableFileServer'\\n  checked='yes'\\n  unchecked='no'\\n  default='no'\\n>\\n  Enable File Server\\n</$checkbox>\\n\\nFiles Folder: <<helpButton $:/plugins/OokTech/Bob/AboutFilePathRoot>>\\n\\n<$radio\\n  tiddler='$:/WikiSettings/split'\\n  index='filePathRoot'\\n  value='./files'\\n>\\n  `./files` (Default Setting)\\n</$radio>\\n<br>\\n<$radio\\n  tiddler='$:/WikiSettings/split'\\n  index='filePathRoot'\\n  value='cwd'\\n>\\n  Current Working Directory\\n</$radio>\\n<br>\\n<$radio\\n  tiddler='$:/WikiSettings/split'\\n  index='filePathRoot'\\n  value='homedir'\\n>\\n  Home Folder\\n</$radio>\\n\\nCurrent Default Folder:\\n<$reveal\\n  type='nomatch'\\n  state='$:/state/SetFilePathRoot'\\n  text='show'\\n>\\n  <$view\\n    tiddler='$:/WikiSettings/split'\\n    index='filePathRoot'\\n  />\\n  <$button\\n    class='tc-btn-invisible'\\n    tooltip='Manualy set the file path root'\\n  >\\n    <$action-setfield $tiddler=\\\"$:/temp/SetFilePathRoot\\\" path={{$:/WikiSettings/split##filePathRoot}}/>\\n    <$action-setfield $tiddler='$:/state/SetFilePathRoot' text='show'/>\\n    {{$:/core/images/edit-button}}\\n  </$button>\\n</$reveal>\\n<$reveal\\n  type='match'\\n  state='$:/state/SetFilePathRoot'\\n  text='show'\\n>\\n  <$edit-text\\n    tiddler='$:/temp/SetFilePathRoot'\\n    field='path'\\n    tag='input'\\n  />\\n  <$button\\n    class='tc-btn-invisible'\\n    tooltip='Save file path root'\\n  >\\n    {{$:/core/images/save-button}}\\n    <$action-updatesetting\\n      filePathRoot={{$:/temp/SetFilePathRoot}}\\n    />\\n    <$action-setfield $tiddler='$:/state/SetFilePathRoot' text='hide'/>\\n  </$button>\\n  <$button\\n    class='tc-btn-invisible'\\n    tooltip='Cancel'\\n  >\\n    {{$:/core/images/cancel-button}}\\n    <$action-setfield $tiddler='$:/state/SetFilePathRoot' text='hide'/>\\n  </$button>\\n</$reveal>\\n\\n<$button>\\n  Save File Path Root\\n  <$action-updatesetting\\n    filePathRoot={{$:/WikiSettings/split##filePathRoot}}\\n  />\\n</$button>\\n\\nNote: Enabling saving media on the server has no effect unless the file server\\nis enabled. So if the checkbox above is not checked than this checkbox does\\nnothing.\\n\\n<$checkbox\\n  checkactions=<<saveMediaOnServerCheckActions>>\\n  uncheckactions=<<saveMediaOnServerUncheckActions>>\\n  tiddler='$:/WikiSettings/split'\\n  index='saveMediaOnServer'\\n  checked='yes'\\n  unchecked='no'\\n  default='yes'\\n>\\n  Save media on server\\n</$checkbox> ([[what is this?|$:/plugins/OokTech/Bob/Documentation/ServerMedia]])\\n\\n!! Media in the FilePathRoot <<helpButton $:/plugins/OokTech/Bob/AboutListMediaInFilePathRoot>>\\n\\n<$button>\\n  Fetch list of media in the filePathRoot folder\\n  <$action-websocketmessage\\n    type='listFiles'\\n    folder='/files'\\n  />\\n</$button>\\n<$button>\\n  <$reveal\\n    type='match'\\n    state='$:/state/showFiles/files!!show'\\n    text='yes'\\n  >\\n    Hide List\\n    <$action-setfield\\n      $tiddler='$:/state/showFiles/files'\\n      show=no\\n    />\\n  </$reveal>\\n  <$reveal\\n    type='nomatch'\\n    state='$:/state/showFiles/files!!show'\\n    text='yes'\\n  >\\n    Show List\\n    <$action-setfield\\n      $tiddler='$:/state/showFiles/files'\\n      show=yes\\n    />\\n  </$reveal>\\n</$button>\\n<br>\\n<$reveal\\n  type='match'\\n  state='$:/state/showFiles/files!!show'\\n  text='yes'\\n>\\n  <$list\\n    filter='[enlist{$:/state/fileList/files!!list}]'\\n  >\\n    <$button>\\n      <<currentTiddler>>\\n      <$action-setfield\\n        $tiddler=<<currentTiddler>>\\n        _canonical_uri={{{ [[$:/WikiSettings/split]getindex[fileURLPrefix]addsuffix[/]addsuffix<currentTiddler>] }}}\\n      />\\n      <$action-navigate\\n        $to=<<currentTiddler>>\\n      />\\n    </$button>\\n  </$list>\\n</$reveal>\\n\\n!! Serve files from additional folders <<helpbutton $:/plugins/OokTech/Bob/AboutServeMediaFromAdditionalFolders>>\\n\\nEnter the prefix and path you want to use, then click `Add Folder` button\\n\\n<table\\n  style='width:100%;'\\n>\\n  <tr>\\n    <th>\\n      Prefix\\n    </th>\\n    <th>\\n      Path\\n    </th>\\n  </tr>\\n  <tr>\\n    <td>\\n      <$edit-text\\n        tiddler='$:/temp/Bob/AddServedFiles'\\n        field='prefix'\\n      />\\n    </td>\\n    <td>\\n      <$edit-text\\n        tiddler='$:/temp/Bob/AddServedFiles'\\n        field='path'\\n      />\\n    </td>\\n  </tr>\\n</table>\\n\\n<$button>\\n  Add Folder\\n  <$action-updatesetting\\n    servingFiles={{{ [[{\\\"]addsuffix{$:/temp/Bob/AddServedFiles!!prefix}addsuffix[\\\":\\\"]addsuffix{$:/temp/Bob/AddServedFiles!!path}addsuffix[\\\"}]] }}}\\n  />\\n  <$list\\n    filter=\\\"\\\"\\\"[[$:/temp/Bob/AddServedFiles]has[scan]scan[yes]]\\\"\\\"\\\"\\n  >\\n    and scan for media\\n    <$action-websocketmessage\\n      $type='mediaScan'\\n      folder={{$:/temp/Bob/AddServedFiles!!path}}\\n      prefix={{$:/temp/Bob/AddServedFiles!!prefix}}\\n    />\\n  </$list>\\n  <$action-setfield\\n    $tiddler='$:/temp/Bob/AddServedFiles'\\n    prefix=''\\n    path=''\\n  />\\n</$button>\\n\\n<$checkbox\\n  tiddler='$:/temp/Bob/AddServedFiles'\\n  field='scan'\\n  checked='yes'\\n  unchecked='no'\\n>\\n  Also Scan Folder\\n</$checkbox>\\n\\n!! File Folders:\\n\\nThese are the additional folders that are currently serving media.\\n\\n<table\\n  style='width:100%;'\\n>\\n  <tr>\\n    <th\\n      style='width:2em;'\\n    >\\n    </th>\\n    <th\\n      style='width:2em;'\\n    >\\n    </th>\\n    <th>\\n      Prefix\\n    </th>\\n    <th>\\n      Path\\n    </th>\\n  </tr>\\n  <$list\\n    filter='[[$:/WikiSettings/split/servingFiles]indexes[]]'\\n    variable=servePath\\n  >\\n    <$set\\n      name=theState\\n      filter='[[$:/state/servedPaths/]addsuffix[files/]addsuffix<servePath>]'\\n    >\\n      <tr>\\n        <td>\\n          <$button\\n            class='tc-btn-invisible'\\n          >\\n            {{$:/core/images/delete-button}}\\n            <$action-updatesetting\\n              $remove={{{ [[servingFiles.]addsuffix<servePath>] }}}\\n            />\\n          </$button>\\n        </td>\\n        <td>\\n          <$button\\n            class='tc-btn-invisible'\\n          >\\n            <$list\\n              filter='[<theState>get[show]prefix[yes]]'\\n              emptyMessage=\\\"\\\"\\\"{{$:/core/images/preview-closed}}<$action-setfield $tiddler=<<theState>> show=yes/>\\\"\\\"\\\"\\n            >\\n              {{$:/core/images/preview-open}}\\n              <$action-setfield\\n                $tiddler=<<theState>>\\n                show=no\\n              />\\n            </$list>\\n          </$button>\\n        </td>\\n        <td>\\n          <$view\\n            tiddler='$:/WikiSettings/split'\\n            index='fileURLPrefix'\\n          />/<<servePath>>\\n        </td>\\n        <td>\\n          <$view\\n            tiddler='$:/WikiSettings/split/servingFiles'\\n            index=<<servePath>>\\n          />\\n        </td>\\n      </tr>\\n      <$set\\n        name=revealThing\\n        filter='[<theState>addsuffix[!!show]]'\\n      >\\n        <$reveal\\n          type='match'\\n          state=<<revealThing>>\\n          text=yes\\n          tag=tr\\n        >\\n          <$list\\n            filter='[{$:/WikiSettings/split##fileURLPrefix}addsuffix[/]addsuffix<servePath>]'\\n            variable=path\\n          >\\n            <td\\n              colspan=4\\n              style='text-align:center;'\\n            >\\n              <$button>\\n                Show files in <<path>>\\n                <$action-websocketmessage\\n                  type='listFiles'\\n                  folder=<<path>>\\n                />\\n              </$button>\\n            </td>\\n          </$list>\\n        </$reveal>\\n        <$list\\n          filter='[<theState>get[show]prefix[yes]]'\\n          variable=unused\\n        >\\n          <$set\\n            name=someTid\\n            filter='[[$:/state/fileList/]addsuffix{$:/WikiSettings/split##fileURLPrefix}addsuffix[/]addsuffix<servePath>]'\\n          >\\n            <$set\\n              name=theList\\n              filter='[<someTid>get[list]]'\\n            >\\n              <$list\\n                filter='[list<someTid>]'\\n              >\\n                <tr>\\n                  <td\\n                    colspan=4\\n                  >\\n                    <$button>\\n                      <<currentTiddler>>\\n                      <$set name=ext filter=\\\"[<currentTiddler>split[.]!is[blank]last[]addprefix[.]]\\\">\\n                        <$action-setfield\\n                          $tiddler=<<currentTiddler>>\\n                          _canonical_uri={{{ [[$:/WikiSettings/split]getindex[fileURLPrefix]addsuffix[/]addsuffix<servePath>addsuffix[/]addsuffix<currentTiddler>] }}}\\n                          type={{{ [[$:/WikiSettings/split/mimeMap]getindex<ext>] }}}\\n                        />\\n                      </$set>\\n                      <$action-navigate\\n                        $to=<<currentTiddler>>\\n                      />\\n                    </$button>\\n                  </td>\\n                </tr>\\n              </$list>\\n            </$set>\\n          </$set>\\n        </$list>\\n      </$set>\\n    </$set>\\n  </$list>\\n</table>\\n\\n''Note:'' Changes take effect without having to restart the server, but if you\\nhave a _canonical_uri tiddler open and changing the settings here would change\\nwhat is displayed than the tiddler must be closed and re-opened before you will\\nsee the media.\\n\\n''Note 2:'' You don't need to do anything special after adding a new folder, but\\nafter removing one you have to click the `Update Settings` button below or the\\nchange will not take effect or be saved.\\n\\nAfter enabling or disabling the file server by checking or unchecking the box\\nabove you must shutdown the server and then restart it before using the file\\nserver.\\n\\nYou must also have to do this if you change the Files folder\\n\\nFirst click this button:\\n<$button>\\n  Update Settings\\n  <$action-savesettings/>\\n</$button>\\n\\nThen click this button:\\n<$button>\\n  Shutdown Wiki\\n  <$action-websocketmessage $type=shutdownServer/>\\n</$button>\\n\\nThen restart Bob, this is not what the 'reconnect' button is for, refresh\\nthe entire page.\\n\\n! Advanced (Here there be Dragons)\\n\\n<$reveal\\n  type='nomatch'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n\\nThe file URL prefix is used to build the paths to the files on your computer.\\nBob is not the same as using a single file wiki, it is a server. When you put\\nin a path to a file it isn't a path on your file system, it is a url that the\\nserver uses to determine how to respond.\\n\\nSee [[serving files|$:/plugins/OokTech/Bob/Documentation/Serving Files]] for more.\\n\\nChanging this may break everything and plunge the earth into a 1000 year reign\\nof darkness. Or it may work just fine and cause no trouble.\\n\\n</$reveal>\\n\\nFile URL Prefix:\\n<$edit-text\\n  tiddler='$:/WikiSettings/split'\\n  index='fileURLPrefix'\\n  tag='input'\\n  class='tc-edit-texteditor'\\n  default='files'\\n/>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutBackupSaveInterval\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutBackupSaveInterval\",\n            \"text\": \"If `Trigger backup when wiki is modified` is checked the wiki will be saved\\nafter this much time has passed after an edit.\\nThe value is in ms, 1000ms = 1 second.\\n\\nThe timer isn't reset by edits, so by default the wiki is saved 10 minutes\\nafter the first edit you make, regardless of any edits you make in the 10\\nminute interval.\\n\\nAfter the wiki is saved it waits until there is another edit before starting\\nanother countdown to save a new backup.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutBackupsFolder\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutBackupsFolder\",\n            \"text\": \"This is the folder where wikis backups are stored. If a relative path is used\\nit is relative to the `wikiPathBase` in the settings.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutCreateFromEdition\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutCreateFromEdition\",\n            \"text\": \"This creates a wiki with no content using an existing edition.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutCreateFromHTML\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutCreateFromHTML\",\n            \"text\": \"Create a wiki in Bob using a single file html wiki.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutCreateFromNode\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutCreateFromNode\",\n            \"text\": \"Add an existing node wiki, this will not move the wiki folders, just list it\\nhere so you can open it and use it with Bob.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutCreateFromTiddlers\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutCreateFromTiddlers\",\n            \"text\": \"Create a wiki using tiddlers taken from one or more existing wikis.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutDeleteWikiDeleteChildren\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutDeleteWikiDeleteChildren\",\n            \"text\": \"If you check this box all wikis that are children of the deleted wiki will also\\nbe deleted.\\nSo if the wiki is `bar` any wikis that start with `bar/` will also be deleted.\\n\\nIf you select this all of the backups for the deleted wikis will also be\\ndeleted.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutDeleteWikiSelect\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutDeleteWikiSelect\",\n            \"text\": \"This is the wiki that will be deleted.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutDownloadHTMLVersion\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutDownloadHTMLVersion\",\n            \"text\": \"This button downloads a single file html version of this wiki.\\nThe downloaded wiki will not have Bob or any of Bobs features, it can be shared\\nand used just like any other single file wiki.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutDuplicateWiki\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutDuplicateWiki\",\n            \"text\": \"Create a new wiki by duplicating an existing wiki with a new name.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutEnableBackups\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutEnableBackups\",\n            \"text\": \"If this is checked Bob will automatically save backups of your wikis.\\nBy default it saves a copy when you first load a wiki after starting Bob and\\nthen every 10 minutes if you are editing a wiki.\\n\\nYou can change this behaviour in the `Advanced` section.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutFilePathRoot\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutFilePathRoot\",\n            \"text\": \"The `Files Folder` is the folder on your computer where you place files to make\\nthem available to wikis. By default it is a folder called `files` in the same\\nfolder as the executable (if you are using BobEXE) or where you run the script\\nfrom (if you are using the plugin version). If you don't have a specific reason\\nto change this than you shouldn't change it.\\n\\nOne reasonable alternative option is your documents folder:\\n\\n* On Windows this is normally `C:\\\\Users\\\\USERNAME\\\\Documents`\\n* On many Linux distributions this is normally `/home/USERNAME/Documents`\\n* On OSX this is `/Users/USERNAME/Documents`\\n\\nmake sure to change `USERNAME` in the above examples to match your actual\\nusername on the computer you are using.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutListMediaInFilePathRoot\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutListMediaInFilePathRoot\",\n            \"text\": \"First click the `Fetch list of media in the filePathRoot folder` to get a list\\nof the media available, then click `Show List` to see a listing of all of the\\nmedia that you can display in the wiki.\\nClicking on a file name will create a tiddler that displays the media file, it\\ncan then be transcluded into other tiddlers to display the media like a normal\\nimage tiddler.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutMaximumBackupsPerWiki\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutMaximumBackupsPerWiki\",\n            \"text\": \"This sets the maximum number of backups that will be saved for each wiki. Once\\nthe number of backups reaches this value the oldest backup will be removed each\\ntime a new one is saved.\"\n        },\n        \"$:/plugins/Bob/AboutPersistentUsernames\": {\n            \"title\": \"$:/plugins/Bob/AboutPersistentUsernames\",\n            \"text\": \"If you check this box you will be able to set the username for signing edits on\\nthe wiki and it will be saved for this browser.\\n\\nIf you use another browser you can save another name for that browser.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutRefreshPage\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutRefreshPage\",\n            \"text\": \"This link just reloads the current page, the same as if you clicked the reload\\nbutton in your browser. This is not the same as the `reconnect` button in the\\nred banner at the top.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutRenameWikiNewName\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutRenameWikiNewName\",\n            \"text\": \"This is the new name for the wiki. You can also change the wikis location using\\nthis, for example if you had a wiki `foo` and you set the name to `foo/bar` the\\nwiki would be moved into the appropriate folder on the file system.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutRenameWikiSelect\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutRenameWikiSelect\",\n            \"text\": \"This is the wiki that you want to rename.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutSaveBackupOnEdit\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutSaveBackupOnEdit\",\n            \"text\": \"If this is checked editing the wiki will trigger a backup timer. See the note\\nfor the `Save interval for backups` for more.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutSaveBackupOnLoad\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutSaveBackupOnLoad\",\n            \"text\": \"If this is checked a backup is saved when you load a wiki for the first time\\nafter starting Bob.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutSavePluginSelection\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutSavePluginSelection\",\n            \"text\": \"This will save the current plugin selection and unload this wiki.\\nAfter clicking this button you must reload the page, either with the browser\\nreload button or by clicking the `Refresh Page` link.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutSelectPluginAuthor\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutSelectPluginAuthor\",\n            \"text\": \"Selecting a plugin author here will filter the list of plugins so only plugins\\nby that author are shown.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutServeMediaFromAdditionalFolders\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutServeMediaFromAdditionalFolders\",\n            \"text\": \"In addition to the default folder above, you can serve media from other\\nfolders. To set up a folder first give the prefix you want to use to identify\\nthat folder in the prefix text box, then enter the path to the folder in the\\npath text box.\\nIf you want to automatically make a tiddler for each media file in the folder\\nyou can check the `Also Scan Folder` check box.\\nThis will create a tiddler for each of the media files in the folder.\\nYou can then click `Add Folder` and the folder will be added as a possible\\nsource of served media.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutUnloadWiki\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutUnloadWiki\",\n            \"text\": \"This button will unload the current wiki. This means that it will be\\ndisconnected from the server and any changes you make will not be saved.\\n\\nIn order to reconnect you have to reload the wiki page, the `reconnect` button\\nwill not work, this is not what it is made for.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutUpdatePluginList\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutUpdatePluginList\",\n            \"text\": \"You have to click this button to populate the list of plugins available on the\\nBob server.\\nThis is like a local plugin library, the plugins listed here are saved and are\\navailable without any connection to the internet or other plugin library.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutWikiFromTiddlersFilter\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutWikiFromTiddlersFilter\",\n            \"text\": \"This filter is applied to the tiddlers in the source wiki, tiddlers returned by\\nthis filter are included in the new wiki.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutWikiFromTiddlersSource\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutWikiFromTiddlersSource\",\n            \"text\": \"This is the source wiki for tiddlers. The filter will be run in this wiki and\\nany tiddlers returned will be included in the newly created wiki.\"\n        },\n        \"$:/plugins/OokTech/Bob/AboutWikiFromTiddlersTransfrom\": {\n            \"title\": \"$:/plugins/OokTech/Bob/AboutWikiFromTiddlersTransfrom\",\n            \"text\": \"This is a transfrom filter, the title of each tiddler from this wiki will be\\ntransformed by this filter before it is added to the newly created wiki.\"\n        },\n        \"$:/plugins/OokTech/Bob/ManageWikis\": {\n            \"title\": \"$:/plugins/OokTech/Bob/ManageWikis\",\n            \"caption\": \"Manage Wikis\",\n            \"text\": \"<$reveal\\n  type='nomatch'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n\\nThese are different things you can do for managing wikis.\\n\\n* `Wiki Listing` shows all of the wikis that are currently available. You can display this list in the sidebar.\\n* `Create Wikis` has different methods for creating or adding new wikis to Bob.\\n* `Rename Wikis` lets you rename or move existing wikis.\\n* `Delete Wikis` lets you delete existing wikis. This is permanent and can not be undone.\\n\\n</$reveal>\\n\\n<$checkbox\\n  tiddler='$:/settings/Bob/removemissingwikis'\\n  field='text'\\n  checked='true'\\n  unchecked='false'\\n>\\n  Remove missing wikis when updating list\\n</$checkbox>\\n\\n<<tabs \\\"[[$:/plugins/OokTech/Bob/Wiki Listing]][[$:/plugins/OokTech/Bob/CreateWikis]][[$:/plugins/OokTech/Bob/RenameWikis]][[$:/plugins/OokTech/Bob/DeleteWikis]]\\\" \\\"$:/plugins/OokTech/Bob/Wiki Listing\\\">>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/RenameWikis\": {\n            \"title\": \"$:/plugins/OokTech/Bob/RenameWikis\",\n            \"caption\": \"Rename Wikis\",\n            \"text\": \"\\\\define updateNameActions()\\n<$action-websocketmessage\\n  $type='renameWiki'\\n  newWiki={{$:/state/RenameWiki!!new_name}}\\n  oldWiki={{$:/state/RenameWiki!!old_name}}\\n/>\\n<$action-setfield\\n  $tiddler='$:/state/RenameWiki'\\n  new_name=''\\n  old_name=''\\n/>\\n\\\\end\\n\\n<$reveal\\n  type='nomatch'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n\\n</$reveal>\\n\\nSelect Wiki:\\n<$select\\n  tiddler='$:/state/RenameWiki'\\n  field='old_name'\\n>\\n  <option\\n    value=''\\n  >\\n    Select Wiki\\n  </option>\\n  <$list\\n    filter='[list[$:/state/ViewableWikis]]'\\n  >\\n    <option>\\n      <<currentTiddler>>\\n    </option>\\n  </$list>\\n</$select> <<helpButton $:/plugins/OokTech/Bob/AboutRenameWikiSelect>>\\n\\nNew Name:\\n<$edit-text\\n  tiddler='$:/state/RenameWiki'\\n  field='new_name'\\n/> <<helpButton $:/plugins/OokTech/Bob/AboutRenameWikiNewName>>\\n\\n<$button\\n  actions=<<updateNameActions>>\\n>\\n  Update Name\\n</$button>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/SaverServer\": {\n            \"title\": \"$:/plugins/OokTech/Bob/SaverServer\",\n            \"caption\": \"Saver Server\",\n            \"text\": \"\\\\define enableDisableSaver()\\n<$reveal\\n  type='nomatch'\\n  state='$:/WikiSettings/split##enableBobSaver'\\n  text='no'\\n>\\n  <$action-websocketmessage\\n    $type='updatesetting'\\n    enableBobSaver='no'\\n  />\\n</$reveal>\\n<$reveal\\n  type='match'\\n  state='$:/WikiSettings/split##enableBobSaver'\\n  text='no'\\n>\\n  <$action-websocketmessage\\n    $type='updatesetting'\\n    enableBobSaver='yes'\\n  />\\n</$reveal>\\n\\\\end\\n\\n!! Configuration for the single html file saver\\n\\nThis is configuration for using Bob with the BobSaver. BobSaver is a plugin\\nfor single file wikis that lets Bob act as the saving mechanism. When you have\\nBobSaver installed in your wiki you can open the file normally anywhere on your\\ncomputer and it can save and autosave as long as the BobSaver plugin is\\nenabled.\\n\\nNo configuration is required, but the single file wikis do have to have the\\nBobSaver plugin installed.\\n\\nThe saver is enabled by default, check this box to disable the saver.\\n\\n<$checkbox\\n  actions=<<enableDisableSaver>>\\n  tiddler='$:/WikiSettings/split'\\n  index='enableBobSaver'\\n  checked='yes'\\n  unchecked='no'\\n>\\n  Disable Saver\\n</$checkbox>\\n\\nAfter changing any of the options below click <$button>\\n  Save Settings\\n  <$action-savesettings/>\\n</$button>\\nOtherwise they will not take effect.\\n\\nThis is not required, leave it blank if you don't want to use a key.\\nIf you want to you can set the key here, it is a password that you set here and\\nenter on your single file wikis in the BobSaver configuration (on your single\\nfile wiki go to the $:/ControlPanel then the `Saving` tab then the `Bob Saver`\\ntab to enter the key)\\n\\nChanging the key takes effect as soon as the settings are saved.\\n\\nSaver Key: <$edit-text\\n  tiddler='$:/WikiSettings/split/saver'\\n  index='key'\\n  tag=input\\n  placeholder=''\\n/>\\n\\n!! Here there be dragons\\n\\nChanging this will break the saver very easily unless you know exactly what\\nyou are doing. You shouldn't change this.\\n\\nSaver Port: <$edit-text\\n  tiddler='$:/WikiSettings/split/saver'\\n  index='port'\\n  tag=input\\n  placeholder='61192'\\n/>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/FetchPlugins\": {\n            \"title\": \"$:/plugins/OokTech/Bob/FetchPlugins\",\n            \"caption\": \"Fetch Plugins\",\n            \"text\": \"!WARNING - This is very experimental back up your wikis and use at your own risk\\n\\nTo use this you get the url of a zipped plugin, enter the url into the plugin url field and then click Save Plugin to Server. Afterward you should be able to access that plugin like any other from Bob's plugin manager.\\n\\nPlugin URL:\\n<$edit-text\\n  tiddler='$:/state/Bob/GetGitPlugin'\\n  field='url'\\n  class='tc-edit-texteditor'\\n/>\\n\\n<$button>\\n  Save Plugin to Server\\n  <$action-websocketmessage\\n    $type='getGitPlugin'\\n    url={{$:/state/Bob/GetGitPlugin!!url}}\\n  />\\n  <$action-setfield\\n    $tiddler='$:/state/Bob/GetGitPlugin'\\n    url=''\\n  />\\n</$button>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/ManualSettingsTab\": {\n            \"title\": \"$:/plugins/OokTech/Bob/ManualSettingsTab\",\n            \"caption\": \"Manual Settings\",\n            \"text\": \"''IMPORTANT:'' there are a lot of settings here. Almost all of them have\\ninterfaces in other parts of the control panel that are much safer to use\\nbecause they ensure that everything is formatted correctly so it doesn't get\\nbroken, and they have instructions specific to what they change.\\n\\nChanging things here may break parts of Bob, and may have unexpected results.\\nIf you decide to edit a part of this that has an interface elsewhere do not\\nexpect support if things break.\\n\\nClick on a value to edit it. After clicking on a value the trashcan icon will\\ndelete that field.\\nTo add a new value click on the\\n<$button class='tc-btn-invisible'>{{$:/core/images/new-button}}</$button> then\\nselect if you want to add a simple property or an object that can hold further\\nproperties, then give a name to the property and if it is a simple property\\nalso give a value. When you are done click\\n<$button class='tc-btn-invisible'>{{$:/core/images/save-button}}</$button> to\\nsave it, or click\\n<$button class='tc-btn-invisible'>{{$:/core/images/cancel-button}}</$button> to\\ndiscard the new property.\\n\\nAfter modifying the settings here you have to click `Update Settings` below or\\nthey will not be saved.\\n\\n<$checkbox\\n  tiddler='$:/state/Bob/EditManualSettings'\\n  field='text'\\n  checked='true'\\n  unchecked='false'\\n>\\n  Enable Editing\\n</$checkbox>\\n\\n{{$:/WikiSettings/split||$:/plugins/OokTech/Bob/EditableJSONViewTemplate}}\\n\\n<$button>\\n  Update Settings\\n  <$action-savesettings/>\\n</$button>\\n\\n<$button>\\n  Update Routes\\n  <$action-websocketmessage $type=updateRoutes/>\\n</$button>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/ServerMessageHistory\": {\n            \"title\": \"$:/plugins/OokTech/Bob/ServerMessageHistory\",\n            \"caption\": \"Server Messages and Logging\",\n            \"text\": \"\\\\define consoleLoggingCheck()\\n<$action-updatesetting\\n  logger='{\\\"useConsoleLogging\\\":\\\"yes\\\"}'\\n/>\\n\\\\end\\n\\n\\\\define consoleLoggingUncheck()\\n<$action-updatesetting\\n  logger='{\\\"useConsoleLogging\\\":\\\"no\\\"}'\\n/>\\n\\\\end\\n\\n\\\\define fileLoggingCheck()\\n<$action-updatesetting\\n  logger='{\\\"useFileLogging\\\":\\\"yes\\\"}'\\n/>\\n\\\\end\\n\\n\\\\define fileLoggingUncheck()\\n<$action-updatesetting\\n  logger='{\\\"useFileLogging\\\":\\\"no\\\"}'\\n/>\\n\\\\end\\n\\n\\\\define browserLoggingCheck()\\n<$action-updatesetting\\n  logger='{\\\"useBrowserLogging\\\":\\\"yes\\\"}'\\n/>\\n\\\\end\\n\\n\\\\define browserLoggingUncheck()\\n<$action-updatesetting\\n  logger='{\\\"useBrowserLogging\\\":\\\"no\\\"}'\\n/>\\n\\\\end\\n\\n!! Logger setup\\n\\nLog levels above 2 are not implemented in many places.\\n\\nAll of the log levels default to 2, so if nothing is checked on the radio\\nbuttons it is 2.\\n\\n!!! Console Logging\\n\\n<$checkbox\\n  checkactions=<<consoleLoggingCheck>>\\n  uncheckactions=<<consoleLoggingUncheck>>\\n  tiddler=\\\"$:/WikiSettings/split/logger\\\"\\n  index=\\\"useConsoleLogging\\\"\\n  checked=\\\"yes\\\"\\n  unchecked=\\\"no\\\"\\n  default=\\\"yes\\\"\\n>\\n  Enable Console Logging\\n</$checkbox>\\n\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='consoleLogLevel'\\n  value=1\\n>\\n  1\\n</$radio>\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='consoleLogLevel'\\n  value=2\\n>\\n  2\\n</$radio>\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='consoleLogLevel'\\n  value=3\\n>\\n  3\\n</$radio>\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='consoleLogLevel'\\n  value=4\\n>\\n  4\\n</$radio>\\n<$button\\n>\\n  Update Console Logging Level\\n  <$action-updatesetting\\n    logger= {{{ [[{\\\"consoleLogLevel\\\":]addsuffix{$:/WikiSettings/split/logger##consoleLogLevel}addsuffix[}]] }}}\\n  />\\n</$radio>\\n\\n!!! File Logging\\n\\n<$checkbox\\n  checkactions=<<fileLoggingCheck>>\\n  uncheckactions=<<fileLoggingUncheck>>\\n  tiddler=\\\"$:/WikiSettings/split/logger\\\"\\n  index=\\\"\\\"\\n  checked=\\\"yes\\\"\\n  unchecked=\\\"no\\\"\\n  default=\\\"no\\\"\\n>\\n  Enable File Logging\\n</$checkbox>\\n\\nFile Log Level:\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='fileLogLevel'\\n  value=1\\n>\\n  1\\n</$radio>\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='fileLogLevel'\\n  value=2\\n>\\n  2\\n</$radio>\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='fileLogLevel'\\n  value=3\\n>\\n  3\\n</$radio>\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='fileLogLevel'\\n  value=4\\n>\\n  4\\n</$radio>\\n<$button>\\n  Update File Logging Level\\n  <$action-updatesetting\\n    logger= {{{ [[{\\\"fileLogLevel\\\":]addsuffix{$:/WikiSettings/split/logger##fileLogLevel}addsuffix[}]] }}}\\n  />\\n</$button>\\n\\nLog folder:\\n<$edit-text\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='outputFolder'\\n  default='./logs'\\n/>\\n(update button for log folder)\\n\\nLog file name (update button for log file name)\\n\\n!!! Browser Logging\\n\\n''Browser Logging isn't completely implemented yet, don't expect any of this to\\nwork''\\n\\nThings here probably won't do anything.\\n\\nBrowser logging is not the same as the server alerts that pop up after some\\nactions.\\nThe browser alerts let you know the status of actions like creating wikis or\\nsaving settings.\\nBrowser logging takes all of the output that you would see in the console and\\nmakes it visible in the browser.\\n\\n<$checkbox\\n  checkactions=<<browserLoggingCheck>>\\n  uncheckactions=<<browserLoggingUncheck>>\\n  tiddler=\\\"$:/WikiSettings/split/logger\\\"\\n  index=\\\"\\\"\\n  checked=\\\"yes\\\"\\n  unchecked=\\\"no\\\"\\n  default=\\\"no\\\"\\n>\\n  Enable File Logging\\n</$checkbox>\\n\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='browserLogLevel'\\n  value=1\\n>\\n  1\\n</$radio>\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='browserLogLevel'\\n  value=2\\n>\\n  2\\n</$radio>\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='browserLogLevel'\\n  value=3\\n>\\n  3\\n</$radio>\\n<$radio\\n  tiddler='$:/WikiSettings/split/logger'\\n  index='browserLogLevel'\\n  value=4\\n>\\n  4\\n</$radio>\\n<$button>\\n  Update Browser Logging Level\\n  <$action-updatesetting\\n    logger= {{{ [[{\\\"browserLogLevel\\\":]addsuffix{$:/WikiSettings/split/logger##browserLogLevel}addsuffix[}]] }}}\\n  />\\n</$button>\\n\\n!!Server Messages\\n\\n<$checkbox\\n  tiddler='$:/settings/Bob/ServerMessageHistoryLimit'\\n  field='hide_messages'\\n  checked='true'\\n  unchecked='false'\\n>\\n  Hide server alerts in this wiki\\n</$checkbox>\\n\\n<$button>\\n  <$list\\n    filter='[[$:/Bob/AlertHistory]indexes[]]'\\n  >\\n    <$action-setfield\\n      $tiddler='$:/Bob/AlertHistory'\\n      $index=<<currentTiddler>>\\n    />\\n  </$list>\\n  Clear Message History\\n</$button>\\n\\n<$checkbox\\n  tiddler='$:/settings/Bob/ServerMessageHistoryLimit'\\n  field='limit'\\n  checked='true'\\n  uncheced='false'\\n>\\n  Limit to the most recent\\n</$checkbox>\\n<$edit-text\\n  tiddler='$:/settings/Bob/ServerMessageHistoryLimit'\\n  field='limit_number'\\n  size=4\\n/>\\nmessages.\\n\\nThis is the history of server messages:\\n\\n<$reveal\\n  type='match'\\n  text='true'\\n  state='$:/settings/Bob/ServerMessageHistoryLimit!!limit'\\n>\\n\\n  <ol>\\n    <$list\\n      filter='[[$:/Bob/AlertHistory]indexes[]reverse[]limit{$:/settings/Bob/ServerMessageHistoryLimit!!limit_number}]'\\n      emptyMessage='No Server Messages Yet.'\\n    >\\n      <li>\\n        <$view\\n          tiddler='$:/Bob/AlertHistory'\\n          index=<<currentTiddler>>\\n        />\\n      </li>\\n    </$list>\\n  </ol>\\n\\n</$reveal>\\n\\n<$reveal\\n  type='nomatch'\\n  text='true'\\n  state='$:/settings/Bob/ServerMessageHistoryLimit!!limit'\\n>\\n\\n  <ol>\\n    <$list\\n      filter='[[$:/Bob/AlertHistory]indexes[]reverse[]]'\\n      emptyMessage='No Server Messages Yet.'\\n    >\\n      <li>\\n        <$view\\n          tiddler='$:/Bob/AlertHistory'\\n          index=<<currentTiddler>>\\n        />\\n      </li>\\n    </$list>\\n  </ol>\\n\\n</$reveal>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/ServerTab\": {\n            \"title\": \"$:/plugins/OokTech/Bob/ServerTab\",\n            \"caption\": \"Server\",\n            \"text\": \"\\\\define checkActions()\\n  <$action-updatesetting\\n    suppressBrowser=true\\n  />\\n\\\\end\\n\\n\\\\define uncheckActions()\\n<$action-updatesetting\\n  suppressBrowser=false\\n/>\\n\\\\end\\n\\\\define toggleLazyLoadingCheckActions()\\n  <$action-updatesetting\\n    ws-server='{\\\"rootTiddler\\\":\\\"$:/core/save/lazy-all\\\"}'\\n  />\\n\\\\end\\n\\n\\\\define toggleLazyLoadingUncheckActions()\\n  <$action-updatesetting\\n    ws-server='{\\\"rootTiddler\\\":\\\"$:/core/save/all\\\"}'\\n  />\\n\\\\end\\n\\n\\\\define checkFileMonitor()\\n  <$action-updatesetting\\n    disableFileWatchers='yes'\\n  />\\n\\\\end\\n\\n\\\\define uncheckFileMonitor()\\n  <$action-updatesetting\\n    disableFileWatchers='no'\\n  />\\n\\\\end\\n\\n<$reveal\\n  type='nomatch'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n\\n  These are actions that affect the server and may affect all wikis served.\\n\\n</$reveal>\\n\\n<$reveal\\n  type='nomatch'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n\\n  Checking this box will keep BobEXE from opening the index wiki in the browser\\n  automatically each time it is started.\\n\\n</$reveal>\\n\\n<$checkbox\\n  checkactions=<<checkActions>>\\n  uncheckactions=<<uncheckActions>>\\n  tiddler='$:/WikiSettings/split'\\n  index='suppressBrowser'\\n  checked='yes'\\n  unchecked='no'\\n  default='yes'\\n>\\n  Automatically open browser when ~BobEXE starts\\n</$checkbox>\\n\\n<$reveal\\n  type='nomatch'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n  This button takes any embedded images or other media that are already in the\\n  wiki and save them in the files folder and replace the embedded media with\\n  tiddlers that use a `_canonical_uri` field to embed the external media. This\\n  is a one-time process and only for the current wiki, other wikis are\\n  unaffected.\\n</$reveal>\\n\\n<$button>\\n  Make Images External\\n  <$action-websocketmessage\\n    $type='makeImagesExternal'\\n    storeIn={{$:/state/ExternaliseImages/storeIn}}\\n  />\\n</$button>\\n<$checkbox\\n  tiddler='$:/state/ExternaliseImages/storeIn'\\n  checked='true'\\n  unchecked='false'\\n>\\n  Store specific to wiki\\n</$checkbox>\\n\\nSee [[big note of DOOM|$:/plugins/OokTech/Bob/Documentation/BigNoteOfDoom]] before doing this.\\n\\n<$reveal type='nomatch' state='$:/ServerIP!!host' text='0.0.0.0'>\\n\\nTo make Bob available on the local network:\\n\\n# Read the [[big note of DOOM|$:/plugins/OokTech/Bob/Documentation/BigNoteOfDoom]]\\n# click the `Make wikis available on the local network` button\\n# click the `Shutdown Wiki` button\\n# Close this tab\\n# Restart Bob (or BobEXE)\\n\\n<$button>\\n  <$action-updatesetting\\n    ws-server='{\\\"host\\\": \\\"0.0.0.0\\\"}'\\n  />\\n  Make wikis available on the local network\\n</$button>\\n\\n</$reveal>\\n\\n<$reveal\\n  type='match'\\n  state='$:/ServerIP!!host'\\n  text='0.0.0.0'\\n>\\n\\nTo make Bob available only on the computer running Bob or BobEXE:\\n\\n# first click the `Make wikis available only on this computer` button\\n# click the `Shutdown Wiki` button\\n# Close this tab\\n# Restart Bob (or BobEXE)\\n\\n<$button>\\n  <$action-updatesetting\\n    ws-server='{\\\"host\\\": \\\"127.0.0.1\\\"}'\\n  />\\n  Make wikis available only on this computer\\n</$button>\\n\\n</$reveal>\\n\\n<$reveal\\n  type='nomatch'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n  Checking this will enable lazy loading.\\n  Lazy loading only loads the tiddler metadata for tiddlers that haven't been\\n  used yet.\\n  This can make a wiki load faster if there are a lot of tiddlers that have a\\n  lot of text.\\n\\n  See [ext[https://tiddlywiki.com/#LazyLoading]] for more information.\\n\\n  Changes to this setting will not take effect until you reload the wiki.\\n  You do not have to restart Bob, just reload the browser tab.\\n</$reveal>\\n\\n<$checkbox\\n  checkactions=<<toggleLazyLoadingCheckActions>>\\n  uncheckactions=<<toggleLazyLoadingUncheckActions>>\\n  tiddler='$:/WikiSettings/split/ws-server'\\n  index='rootTiddler'\\n  checked='$:/core/save/lazy-all'\\n  unchecked='$:/core/save/all'\\n  default='$:/core/save/all'\\n>\\n  Enable Lazy Loading\\n</$checkbox>\\n\\n<$reveal\\n  type='nomatch'\\n  state='$:/settings/Bob/Verbose'\\n  text='false'\\n>\\n  Checking this will disable the file watchers. This means that changes made to\\n  the .tid files on the file system will not be pushed to the browser. This\\n  means that adding or removing tiddlers using something other than the browser\\n  will not have any effect on the wiki in the browser until it is unloaded and\\n  reloaded or Bob is restarted.\\n</$reveal>\\n\\n<$checkbox\\n  checkactions=<<checkFileMonitor>>\\n  uncheckactions=<<uncheckFileMonitor>>\\n  tiddler='$:/WikiSettings/split'\\n  index='disableFileWatchers'\\n  checked='yes'\\n  unchecked='no'\\n  default='no'\\n>\\n  Disable File System Monitor\\n</$checkbox>\\n\\n\\nWARNING: This button will shutdown the wiki server. None of the wikis will be\\navailable until it is restarted.\\n\\n<$button>\\n  Shutdown Wiki\\n  <$action-websocketmessage\\n    $type=shutdownServer\\n  />\\n</$button>\\n\\n<<tabs \\\"[[$:/plugins/OokTech/Bob/ManualSettingsTab]][[$:/plugins/OokTech/Bob/FetchPlugins]][[$:/plugins/OokTech/Bob/FileServerSetup]][[$:/plugins/OokTech/Bob/ServerMessageHistory]]\\\" \\\"$:/plugins/OokTech/Bob/ManualSettingsTab\\\">>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/SelectPlugins\": {\n            \"title\": \"$:/plugins/OokTech/Bob/SelectPlugins\",\n            \"caption\": \"Manage Plugins\",\n            \"text\": \"<$button>\\n  Update Plugin List\\n  <$action-websocketmessage\\n    $type='getPluginList'\\n  />\\n</$button> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutUpdatePluginList\\\">> <-- Click here first!\\n\\n<$button>\\n  Save Plugin Selection\\n  <$action-websocketmessage\\n    $type='updateTiddlyWikiInfo'\\n    pluginList={{$:/Bob/ActivePluginList!!list}}\\n  />\\n  <$action-websocketmessage\\n    $type='unloadWiki'\\n    wikiName={{$:/WikiName}}\\n  />\\n</$button> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutSavePluginSelection\\\">>\\n\\n<a href='javascript:history.go(0)'>Refresh Page</a> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutRefreshPage\\\">>\\n\\n<br>\\nSelect Plugin Author: <$select\\n  tiddler='$:/state/Bob/SelectedAuthor'\\n  default='all'\\n>\\n  <option\\n    value='all'\\n  >\\n    All\\n  </option>\\n  <$list\\n    filter='[list[$:/Bob/AvailablePluginList]splitbefore[/]]'\\n    variable='pluginAuthor'\\n  >\\n    <option>\\n      <<pluginAuthor>>\\n    </option>\\n  </$list>\\n</$select> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutSelectPluginAuthor\\\">>\\n\\nSearch: <$edit-text\\n  tiddler='$:/state/Bob/SearchPlugins'\\n  default=''\\n  placeholder='Search Plugins'\\n  tag='input'\\n/>\\n\\n<$list\\n  filter='[[$:/state/Bob/SelectedAuthor]has[text]!text[all]]'\\n  variable='unused'\\n>\\n  <$set\\n    name=pluginAuthor\\n    value={{$:/state/Bob/SelectedAuthor}}\\n  >\\n    <h2><$text text=<<pluginAuthor>>></$text></h2>\\n    <$list\\n      filter='[list[$:/Bob/AvailablePluginList]search{$:/state/Bob/SearchPlugins}prefix<pluginAuthor>]'\\n    >\\n      <$list\\n        filter='[list[$:/Bob/ActivePluginList]is[current]]'\\n        emptyMessage=\\\"\\\"\\\"\\n        <$button\\n          class='tc-btn-invisible'\\n        >\\n          <input\\n            type='checkbox'\\n          />\\n          <$view\\n            field='title'\\n          />\\n          <$action-listops\\n            $tiddler='$:/Bob/ActivePluginList'\\n            $subfilter='+[append<currentTiddler>]'\\n          />\\n        </$button>\\n        <br>\\\"\\\"\\\"\\n      >\\n        <$button\\n          class='tc-btn-invisible'\\n        >\\n          <input\\n            type='checkbox'\\n            checked\\n          />\\n          <$view\\n            field='title'\\n          />\\n          <$action-listops\\n            $tiddler='$:/Bob/ActivePluginList'\\n            $subfilter='+[remove<currentTiddler>]'\\n          />\\n        </$button>\\n        <br>\\n      </$list>\\n    </$list>\\n  </$set>\\n</$list>\\n\\n<$list\\n  filter='[[$:/state/Bob/SelectedAuthor]text[all]][[$:/state/Bob/SelectedAuthor]!has[text]] +[limit[1]]'\\n  variable='unused'\\n>\\n  <$list\\n    filter='[list[$:/Bob/AvailablePluginList]splitbefore[/]]'\\n    variable='pluginAuthor'\\n  >\\n    <h2><$text text=<<pluginAuthor>>></$text></h2>\\n    <$list\\n      filter='[list[$:/Bob/AvailablePluginList]prefix<pluginAuthor>search{$:/state/Bob/SearchPlugins}]'\\n    >\\n      <$list\\n        filter='[list[$:/Bob/ActivePluginList]is[current]]'\\n        emptyMessage=\\\"\\\"\\\"\\n        <$button\\n          class='tc-btn-invisible'\\n        >\\n          <input\\n            type='checkbox'\\n          />\\n          <$view\\n            field='title'\\n          />\\n          <$action-listops\\n            $tiddler='$:/Bob/ActivePluginList'\\n            $subfilter='+[append<currentTiddler>]'\\n          />\\n        </$button>\\n        <br>\\\"\\\"\\\"\\n      >\\n        <$button\\n          class='tc-btn-invisible'\\n        >\\n          <input\\n            type='checkbox'\\n            checked\\n          />\\n          <$view\\n            field='title'\\n          />\\n          <$action-listops\\n            $tiddler='$:/Bob/ActivePluginList'\\n            $subfilter='+[remove<currentTiddler>]'\\n          />\\n        </$button>\\n        <br>\\n      </$list>\\n    </$list>\\n  </$list>\\n</$list>\"\n        },\n        \"$:/plugins/OokTech/Bob/SelectThemes\": {\n            \"title\": \"$:/plugins/OokTech/Bob/SelectThemes\",\n            \"caption\": \"Manage Themes\",\n            \"text\": \"<$button>\\n  Update Theme List\\n  <$action-websocketmessage\\n    $type='getThemeList'\\n  />\\n</$button> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutUpdatePluginList\\\">> <-- Click here first!\\n\\n<$button>\\n  Save Theme Selection\\n  <$action-websocketmessage\\n    $type='updateTiddlyWikiInfo'\\n    themeList={{$:/Bob/ActiveThemeList!!list}}\\n  />\\n  <$action-websocketmessage\\n    $type='unloadWiki'\\n    wikiName={{$:/WikiName}}\\n  />\\n</$button> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutSavePluginSelection\\\">>\\n\\n<a href='javascript:history.go(0)'>Refresh Page</a> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutRefreshPage\\\">>\\n\\n<br>\\nSelect Theme Author: <$select\\n  tiddler='$:/state/Bob/SelectedAuthor'\\n  default='all'\\n>\\n  <option\\n    value='all'\\n  >\\n    All\\n  </option>\\n  <$list\\n    filter='[list[$:/Bob/AvailableThemeList]splitbefore[/]]'\\n    variable='themeAuthor'\\n  >\\n    <option>\\n      <<themeAuthor>>\\n    </option>\\n  </$list>\\n</$select> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutSelectPluginAuthor\\\">>\\n\\nSearch: <$edit-text\\n  tiddler='$:/state/Bob/SearchThemes'\\n  default=''\\n  placeholder='Search Themes'\\n  tag='input'\\n/>\\n\\n<$list\\n  filter='[[$:/state/Bob/SelectedAuthor]has[text]!text[all]]'\\n  variable='unused'\\n>\\n  <$set\\n    name=themeAuthor\\n    value={{$:/state/Bob/SelectedAuthor}}\\n  >\\n    <h2><$text text=<<themeAuthor>>></$text></h2>\\n    <$list\\n      filter='[list[$:/Bob/AvailableThemeList]search{$:/state/Bob/SearchThemes}prefix<themeAuthor>]'\\n    >\\n      <$list\\n        filter='[list[$:/Bob/ActiveThemeList]is[current]]'\\n        emptyMessage=\\\"\\\"\\\"\\n        <$button\\n          class='tc-btn-invisible'\\n        >\\n          <input\\n            type='checkbox'\\n          />\\n          <$view\\n            field='title'\\n          />\\n          <$action-listops\\n            $tiddler='$:/Bob/ActiveThemeList'\\n            $subfilter='+[append<currentTiddler>]'\\n          />\\n        </$button>\\n        <br>\\\"\\\"\\\"\\n      >\\n        <$button\\n          class='tc-btn-invisible'\\n        >\\n          <input\\n            type='checkbox'\\n            checked\\n          />\\n          <$view\\n            field='title'\\n          />\\n          <$action-listops\\n            $tiddler='$:/Bob/ActiveThemeList'\\n            $subfilter='+[remove<currentTiddler>]'\\n          />\\n        </$button>\\n        <br>\\n      </$list>\\n    </$list>\\n  </$set>\\n</$list>\\n\\n<$list\\n  filter='[[$:/state/Bob/SelectedAuthor]text[all]][[$:/state/Bob/SelectedAuthor]!has[text]] +[limit[1]]'\\n  variable='unused'\\n>\\n  <$list\\n    filter='[list[$:/Bob/AvailableThemeList]splitbefore[/]]'\\n    variable='themeAuthor'\\n  >\\n    <h2><$text text=<<themeAuthor>>></$text></h2>\\n    <$list\\n      filter='[list[$:/Bob/AvailableThemeList]search{$:/state/Bob/SearchThemes}prefix<themeAuthor>]'\\n    >\\n      <$list\\n        filter='[list[$:/Bob/ActiveThemeList]is[current]]'\\n        emptyMessage=\\\"\\\"\\\"\\n        <$button\\n          class='tc-btn-invisible'\\n        >\\n          <input\\n            type='checkbox'\\n          />\\n          <$view\\n            field='title'\\n          />\\n          <$action-listops\\n            $tiddler='$:/Bob/ActiveThemeList'\\n            $subfilter='+[append<currentTiddler>]'\\n          />\\n        </$button>\\n        <br>\\\"\\\"\\\"\\n      >\\n        <$button\\n          class='tc-btn-invisible'\\n        >\\n          <input\\n            type='checkbox'\\n            checked\\n          />\\n          <$view\\n            field='title'\\n          />\\n          <$action-listops\\n            $tiddler='$:/Bob/ActiveThemeList'\\n            $subfilter='+[remove<currentTiddler>]'\\n          />\\n        </$button>\\n        <br>\\n      </$list>\\n    </$list>\\n  </$list>\\n</$list>\"\n        },\n        \"$:/plugins/OokTech/Bob/ThisWikiTab\": {\n            \"title\": \"$:/plugins/OokTech/Bob/ThisWikiTab\",\n            \"caption\": \"This Wiki\",\n            \"text\": \"!!! Options that are specific to this wiki. They don't affect any other wikis.\\n\\n\\n<$button>\\n  Unload Wiki\\n  <$action-websocketmessage\\n    $type='unloadWiki'\\n    wikiName={{$:/WikiName}}\\n  />\\n</$button> <<helpButton \\\"$:/plugins/OokTech/Bob/AboutUnloadWiki\\\">>\\n\\n<$checkbox\\n  tiddler='$:/WikiSettings/split'\\n  index='persistentUsernames'\\n  actions=\\\"<$action-updatesetting persistentUsernames={{$:/WikiSettings/split##persistentUsernames}}/>\\\"\\n  checked=\\\"yes\\\"\\n  unchecked=\\\"no\\\"\\n  default=\\\"no\\\"\\n>\\n  Use Persistent Usernames\\n</$checkbox> <<helpButton \\\"$:/plugins/Bob/AboutPersistentUsernames\\\">>\\n\\nYou can set which plugins and themes are installed on this wiki here.\\nInstalling plugins this way is not the same as dragging and dropping plugins\\ninto the wiki, this can not remove plugins you have added that way, you have to\\ndelete the plugin tiddlers. Deleting the plugin tiddlers for plugins installed\\nusing this interface will not remove them, they have to be removed using this\\ninterface.\\n\\n<<tabs \\\"[[$:/plugins/OokTech/Bob/SelectPlugins]][[$:/plugins/OokTech/Bob/SelectThemes]]\\\" \\\"$:/plugins/OokTech/Bob/SelectPlugins\\\">>\\n\"\n        },\n        \"$:/core/ui/Buttons/save-wiki\": {\n            \"title\": \"$:/core/ui/Buttons/save-wiki\",\n            \"tags\": \"$:/tags/PageControls\",\n            \"caption\": \"{{$:/core/images/save-button}} {{$:/language/Buttons/SaveWiki/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/SaveWiki/Hint}}\",\n            \"text\": \"<$button tooltip={{$:/language/Buttons/SaveWiki/Hint}} aria-label={{$:/language/Buttons/SaveWiki/Caption}} class=<<tv-config-toolbar-class>>>\\n<span class=\\\"tc-dirty-indicator\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>prefix[yes]]\\\">\\n{{$:/core/images/save-button}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>prefix[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/SaveWiki/Caption}}/></span>\\n</$list>\\n</span>\\n</$button>\\n\"\n        },\n        \"$:/core/ui/Buttons/edit\": {\n            \"title\": \"$:/core/ui/Buttons/edit\",\n            \"tags\": \"$:/tags/ViewToolbar\",\n            \"caption\": \"{{$:/core/images/edit-button}} {{$:/language/Buttons/Edit/Caption}}\",\n            \"description\": \"{{$:/language/Buttons/Edit/Hint}}\",\n            \"text\": \"<$list filter='[all[current]listed[]field:title[$:/state/Bob/EditingTiddlers]]'\\nemptyMessage=\\\"\\\"\\\"<$button message=\\\"tm-edit-tiddler\\\" tooltip={{$:/language/Buttons/Edit/Hint}} aria-label={{$:/language/Buttons/Edit/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>prefix[yes]]\\\">\\n{{$:/core/images/edit-button}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>prefix[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text=\\\" \\\"/>\\n<$text text={{$:/language/Buttons/Edit/Caption}}/>\\n</span>\\n</$list>\\n</$button>\\\"\\\"\\\">{{$:/core/images/locked-padlock}}</$list>\\n\"\n        },\n        \"$:/config/SaveFilter\": {\n            \"title\": \"$:/config/SaveFilter\",\n            \"text\": \"[is[tiddler]] -[[$:/HistoryList]] -[[$:/Import]] -[[$:/isEncrypted]] -[prefix[$:/status/]] -[prefix[$:/state/]] -[prefix[$:/temp/]] -[prefix[$:/Bob/]] -[prefix[$:/WikiSettings/]] -[[$:/plugins/OokTech/Bob/Server Warning]] -[[$:/WikiSettings]] -[[$:/ServerIP]] -[[$:/StoryList]] -[[$:/WikiName]]\\n\"\n        },\n        \"$:/config/SyncFilter\": {\n            \"title\": \"$:/config/SyncFilter\",\n            \"text\": \"[is[tiddler]] -[[$:/HistoryList]] -[[$:/Import]] -[[$:/isEncrypted]] -[prefix[$:/status/]] -[prefix[$:/state/]] -[prefix[$:/temp/]] -[prefix[$:/Bob/]] -[prefix[$:/WikiSettings/]] -[[$:/plugins/OokTech/Bob/Server Warning]] -[[$:/WikiSettings]] -[[$:/ServerIP]] -[[$:/StoryList]] -[[$:/WikiName]] -[prefix[$:/Federation/RemoteServer/]] -[has[draft.of]]\\n\"\n        },\n        \"$:/config/SyncThrottleInterval\": {\n            \"title\": \"$:/config/SyncThrottleInterval\",\n            \"text\": \"1\\n\"\n        },\n        \"$:/config/TaskTimerInterval\": {\n            \"title\": \"$:/config/TaskTimerInterval\",\n            \"text\": \"1\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/ActionConvertWiki\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/ActionConvertWiki\",\n            \"tags\": \"ActionWidgets Widgets [[Bob Documentation]]\",\n            \"caption\": \"ActionConvertWiki\",\n            \"description\": \"An action widget that takes an html file as input and makes a new wiki on the server using it\",\n            \"text\": \"! Introduction\\n\\nThis action widget lets you pick a single file wiki from your computer and\\nconvert it into a wiki that Bob can use.\\n\\nThis action widget requires a file input to go along with whatever triggers the\\naction widget (normally a button widget). The file input is used to select\\nwhich html file you want to convert into a wiki for Bob.\\n\\n! Content and Attributes\\n\\nAny content of the `action-convertwiki` widget is ignored.\\n\\n`<$action-convertwiki fileInput='#fileInput' wikiFolder='SomeFolder' wikisPath='/look/a/path' wikiName='AwesomeWiki' overwrite='true'/>`\\n\\n|!Parameter |!Description |\\n|!fileInput |This is the html id attribute given to the file picker used to select which html file to use. Default: `#fileInput` |\\n|!wikiName |The name to give the created wiki. Unless overwrite is set to `true` this name is made unique by appending a number onto the end. Default: `NewWiki` |\\n|!overwrite |If this is set to `true` and a wiki with the name given by wikiName exists than the tiddlers from the html file will be added to that wiki instead of a new wiki being created. Default: `false` |\\n|!wikisPath |The path to the folder that contains the wikis folder. Default: whatever is set in settings.json |\\n|!wikiFolder |The folder that holds the wikis. Default: whatever is set in settings.json, normally `Wikis` |\\n\\n''Note:'' only fileInput is needed. It is suggested that you give the wiki a\\ndescriptive name with wikiName, but you can safely ignore wikisPath and\\nwikiFolder.\\n\\n! Example\\n\\n```\\n<$button>\\nMake wiki from HTML file\\n<$action-convertwiki fileInput='aFileInput'/>\\n</$button>\\n<input type='file' id='aFileInput' accept='.html,.htm'/>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/ActionDownloadWiki\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/ActionDownloadWiki\",\n            \"tags\": \"ActionWidgets Widgets [[Bob Documentation]]\",\n            \"caption\": \"ActionDownloadWiki\",\n            \"description\": \"An action widget that downloads the current wiki as a single file html wiki without any of the Bob components.\",\n            \"text\": \"! Introduction\\n\\nThe `action-downloadwiki` widget is an action widget that downloads the current\\nwiki as a single file html wiki with optinal filters on the\\noutput tiddlers.\\n\\nyou can optionally give an include or exclude filter that lists tiddlers to\\ninclude/exclude from the built wiki. If none are given than all tiddlers in the\\nwiki are exported with the execption of the default exclude list (Bob and other\\nplugins that don't do anything for single file wikis.)\\n\\nalternatively you can give an include filter that lists all of the tiddlers to\\ninclude in the output wiki. If an include filter is given than the exclude\\nfilter input is ignored if it exists.\\n\\nIf you have some specific reason you can set ignoreDefaultExclude to true and\\nit will ignore the default set of tiddlers to exclude.\\n\\nUnless ignoreDefaultExclude is set than the default exclude list is used for\\nboth include and exclude filters.\\n\\n! Content and Attributes\\n\\nAny content of the `action-downloadwiki` widget is ignored.\\n\\n<$action-downloadwiki excludeFilter='excludeFilter' ignoreDefaultExclude=false/>\\n\\n|!Parameter |!Description |\\n|!includeFilter |An optional filter that returns all tiddlers to inclued in the output wiki. If nothing is given than the whole wiki is included. |\\n|!excludeFilter |An optional filter that returns tiddlers to exclude from the downloaded wiki. If this lists a tiddler that is also returned by the includeFilter than the excludeFilter takes presidence. Defaults to an empty list so nothing is excluded. |\\n|!ignoreDefaultExclude |If this is set to `true` than the default exclude list is ignored. The default exclude list includes the Bob plugin and other things that either break single file wikis or do nothing in single file wikis, so don't set this unless you have a specific reason. |\\n\\nThe default exclude filter is\\n\\n```\\n[prefix[$:/plugins/OokTech/Bob/]][[$:/plugins/OokTech/Bob]][prefix[$:/WikiSettings]][prefix[$:/Bob/]][[$:/ServerIP]][[$:/plugins/tiddlywiki/filesystem]][[$:/plugins/tiddlywiki/tiddlyweb]]\\n```\\n\\n''Note:'' When you give an include filter you only include tiddlers that are returned by the filter with a few exceptions. Because everything in tiddlywiki is a tiddler if you only include what in in the filter than you would either have to include these or the wiki would not function at all.\\n\\nThe tiddlers that are always included are:\\n\\n* `$:/core` - without this we can't have a working wiki\\n* `$:/boot/boot.css` - without this the wiki isn't styled and is unrecognisable and possibly unusable\\n* `$:/boot/boot.js` - without this the wiki doesn't load correctly\\n* `$:/boot/bootprefix.js` - without this the wiki doesn't load correctly\\n* `$:/themes/tiddlywiki/vanilla` - without this there is no theme for the wiki and it is very difficult, maybe impossible, to use\\n\\nThis means that, if you give an include filter, the encryption library isn't included in the wiki unless you explictly list it. The same is true for any\\nplugins or libraries you use.\\n\\n! Examples\\n\\n```\\n<$button>\\nDownload HTML File\\n<$action-downloadwiki/>\\n</$button>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/ActionReconnectWebsockets\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/ActionReconnectWebsockets\",\n            \"tags\": \"ActionWidgets Widgets [[Bob Documentation]]\",\n            \"caption\": \"ActionReconnectWebsockets\",\n            \"description\": \"A widget for reconnecting to a websocket server if you have been disconnected.\",\n            \"text\": \"! Introduction\\n\\nThe `action-reconnectwebsocket` widget is an action widget that tries to\\nre-establish your connection to the Bob server component after being\\ndisconnected.\\n\\n! Content and Attributes\\n\\nAny content of the `action-reconnectwebsocket` widget is ignored.\\n\\n|!Attribute |!Description |\\n|!sync |If this is set to `true` than the wiki sends the server a list of its unsent changes and asks for any changes on the server since the wiki was disconnected (Default: `false`) |\\n\\n! Examples\\n\\n```\\n<$action-reconnectwebsocet sync='false'/>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/ActionSaveSettings\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/ActionSaveSettings\",\n            \"tags\": \"ActionWidgets Widgets [[Bob Documentation]]\",\n            \"caption\": \"ActionConvertWiki\",\n            \"description\": \"An action widget that saves Bob settings to the server\",\n            \"text\": \"! Introduction\\n\\nThis widget saves the current contents of the manual settings to the server.\\n\\n! Content and Attributes\\n\\nAny content of the `action-convertwiki` widget is ignored.\\n\\nThis widget hsa no attributes.\\n\\n! Example\\n\\n```\\n<$button>\\nSave settings\\n<$action-savesettings'/>\\n</$button>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/ActionWebSocketMessage\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/ActionWebSocketMessage\",\n            \"tags\": \"ActionWidgets Widgets [[Bob Documentation]]\",\n            \"caption\": \"ActionWebSocketMessage\",\n            \"description\": \"The widget for sending websocket messages.\",\n            \"text\": \"! Introduction\\n\\nThe ''action-websocketmessage''  widget is an [[action widget|ActionWidgets]]\\nthat sends a websocket message to the websocket server on the node server\\nprocess.\\n\\nSee [[WebSocketMessages|$:/plugins/OokTech/Bob/WebSocketMessages]] for a\\nlist of available messages and their descriptions.\\n\\nThis is how any non-automated interaction with he websocket server is done.\\n\\n! Content and Attributes\\n\\nThe ''action-websocketmessage'' widget is invisible. Any content within it is ignored.\\n\\n|!Attribute |!Description |\\n|$type |The name of the websocket message you are sending, from the list in [[WebSocketMessages|$:/plugins/OokTech/Bob/WebSocketMessages]] |\\n|$param |This was supposed to be the default parameter for messages but it isn't used. This will probably be removed in the future. |\\n|$tiddler |This is the title of a tiddler that can be sent along with the message. |\\n|//{any other attributes}// |Each other attributed is added to the message sent. Attributes are added using `attribute=value` syntax. |\\n\\n! Examples\\n\\nThis will send a ping message to the server. All that it does is print out the\\nreceived message in the terminal running the node process.\\n\\nThis message will print out:\\n\\n`{ type: 'test', attribute: 'value', source_connection: 0 }`\\n\\nNote: the source connection may not be 0. The source connection is the\\nzero-based index of the browser connection to the server.\\n\\n```\\n<$button>\\n  PING!\\n  <$action-websocketmessage $type='test' attribute=value/>\\n</$button>\\n```\\n\\n<$button>\\n  PING!\\n  <$action-websocketmessage $type='test' attribute=value/>\\n</$button>\\n\\nThis will reset the tiddlywiki server. Note that if you press this button than\\nit will break your connection to the server and you will have to refresh the\\npage after the server has restarted.\\n\\n```\\n<$button>\\n  Restart Server!\\n  <$action-websocketmessage $type='restartServer'/>\\n</$button>\\n```\\n\\n<$button>\\n  Restart Server!\\n  <$action-websocketmessage $type='restartServer'/>\\n</$button>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/ApacheServer\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/ApacheServer\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"caption\": \"Using an Apache Server\",\n            \"description\": \"Setting up Bob on an apache server with SSL\",\n            \"text\": \"!! Bob behind an Apache SSL-terminating proxy\\n\\nApache does need to distinguish which traffic to proxy as WebSocket.\\nMany examples on the web assume that the URI path can be used to recognize\\nWebSocket traffic.\\ne.g. All WS traffic begins with \\\"/ws\\\".\\nBut Bob uses the same URI for the WS connection as the Tiddlywiki page itself.\\ne.g. https://my.domain.com/.\\n\\nYou can use the WS header to recognize the traffic.\\nThe 'WebSockets' section in the httpd.conf below says,\\n\\\"If you get a request with the HTTP headers \\\"Upgrade: websocket\\\" and\\n\\\"Connection: Upgrade\\\" rewrite it to a WebSocket request for the IP/port where\\nBob is running.\\n\\n```\\n<VirtualHost *:443>\\n  ServerName my.domain.com\\n  ProxyRequests Off\\n  ProxyPreserveHost on\\n  ###### Adding WebSockets ######\\n  RewriteEngine On\\n  RewriteCond %{HTTP:Connection} Upgrade [NC]\\n  RewriteCond %{HTTP:Upgrade} websocket [NC]\\n  RewriteRule /(.*) ws://127.0.0.1:8088/$1 [P,L]\\n  ###### Finished WebSockets #######\\n  ProxyPass \\\"/\\\"  \\\"http://127.0.0.1:8088/\\\"\\n  ProxyPassReverse \\\"/\\\"  \\\"http://127.0.0.1:8088/\\\"\\n  Include cert-stuff.conf\\n  AllowEncodedSlashes On\\n  SSLEngine On\\n  SSLProxyEngine On\\n  <Location \\\"/\\\">\\n    AuthType Basic\\n    AuthName \\\"Restricted test Content\\\"\\n    AuthUserFile /path/to/passwords\\n    Require valid-user\\n  </Location>\\n</VirtualHost>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/AutomaticBackup\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/AutomaticBackup\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"caption\": \"Automatic Backups\",\n            \"description\": \"Setting up automatic wiki backups\",\n            \"text\": \"You can enable automatic backups for wikis in the settings.\\n\\nBackups can be triggered by two events:\\n\\n* Loading a wiki\\n* Modifying a wiki\\n\\nHere loading a wiki is not loading it in the browser, it is loading it on the\\nserver. This happens the first time the wiki is loaded in a browser after the\\nserver starts, or the first time a wiki is loaded after being manually unloaded.\\n\\nBackups based on modifying a wiki do not happen right away, an interval is set\\nand when an edit is made to a wiki if a timer isn't already running a timer\\nstarts. When the timer runs out a backup is made.\\n\\nI need to put more here and make a reasonable UI for it.\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/BackendWebSocketMessages\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/BackendWebSocketMessages\",\n            \"caption\": \"BackendWebSocketMessages\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Back-end messages for developers.\",\n            \"text\": \"These are the messages available for websockets that are only used by the\\nback-end.\\n\\nIf you use these in normal wikitext than you will probably break things and I\\nwill not offer any sort of support. These are only used by the plugin itself\\nso they are only useful if you are modifying the plugin.\\n\\n<$list\\n  filter='[all[tiddlers+shadows]tag[Websocket Message]!tag[Human Usable]]'\\n>\\n  <$link\\n    to=<<currentTiddler>>\\n  >\\n    <$view\\n      field='caption'\\n    />\\n  </$link>\\n  -\\n  <$view\\n    field='description'\\n  />\\n  <br>\\n</$list>\\n\\nFor human usable messages see [[WebSocketMessages|$:/plugins/OokTech/Bob/WebSocketMessages]].\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/BigNoteOfDoom\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/BigNoteOfDoom\",\n            \"caption\": \"Big Note of DOOM\",\n            \"text\": \"This warning applies both to the normal Bob wiki server and the saver component\\nthat allows the BobSaver plugin to save single file wikis.\\n\\n!! BIG NOTE OF DOOM or what is the local network?\\n\\nThe local network is anyone using the same router as you. This means anyone on\\nthe same wifi network or using a wired connection on the same router. So when\\nyou are at starbucks or a library on the wifi anyone else who is on that wifi\\nis on the local network.\\n\\nBy default the wikis are only available on `localhost` on the computer you are\\nrunning BobEXE or the node process on.\\n\\nIf you want to make it available to other computers on the local network you\\nhave to change the settings in the $:/ControlPanel under the `Bob Settings`\\ntab.\\n\\n!!! What this means for wikis\\n\\nIf you have your wikis available to other computers than anyone on the local\\nnetwork can access them.\\nMost of the time they will be able to edit your wikis also.\\n\\nIf you have the file server turned on to access local media on your computer\\nand you have the wikis available on the local network anyone on the network\\nwill be able to access whatever folders you have set up to serve media.\\n\\nThat isn't to say that you should never allow editing on the local network, if\\nyou are on your home network or somewhere you trust than allowing editing on\\nthe local network isn't a problem.\\nThat is, it isn't a problem as long as you don't trust public WiFi networks,\\nthat include coffee shops and libraries and airports and hotels or anything\\nelse that isn't at your home or a friends home. While you may trust the\\nestablishment you should not trust everyone that has access to the network.\\n\\nTrusting private corporate networks where you work is up to you. I would\\ncaution against it.\\n\\n!!! What this means for the BobSaver component\\n\\nThe BobSaver has a separate configuration from the wiki server.\\nYou can set up the wiki server to make wikis available on the local network\\nwithout making the BobSaver available on the local network.\\n\\nIt is never a good idea to make the BobSaver available on the local network.\\nIt is never a good idea to make the BobSaver available on anything other than\\n`localhost` or `127.0.0.1` (the two mean the same thing).\\nThat is why there isn't a way to set it up like there is for the wiki server.\\n\\nIf you do decide to dig into the code and make the BobSaver available on the\\nlocal network anyone who has the key you set can save any files they want\\nanywhere on your computer.\\nThe files must have the extension `.html`, `.htm` or `.hta`, but that just\\nmakes it harder to use them to damage your computer or steal from you/spy on\\nyou, it doesn't prevent it.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Bob Documentation\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Bob Documentation\",\n            \"caption\": \"Bob Documentation\",\n            \"text\": \"<$list filter='[all[tiddlers+shadows]tag[Bob Documentation]]'>\\n<li>\\n  <$link\\n    to=<<currentTiddler>>\\n  >\\n    <$view\\n      field='caption'\\n    >\\n      <$view\\n        field='title'\\n      />\\n    </$view>\\n  </$link>\\n</li>\\n</$list>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/ChatDocumentation\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/ChatDocumentation\",\n            \"caption\": \"Chat\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Built-in chat using Bob\",\n            \"text\": \"!! Local Chat\\n\\nYou can set the conversation, then something or other and can talk.\\n\\n!! Federated Chat\\n\\nSomething else\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Configuration\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Configuration\",\n            \"caption\": \"Configuration\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Configuration options for Bob\",\n            \"text\": \"! Configuration\\n\\nConfiguration for the plugin is set in the `settings.json` file in the\\n`settings` sub-folder of the folder where the `tiddlywiki.info` file is\\nlocated.\\n\\nEverything is optional, if there are any missing pieces default values will be\\nused. If the json isn't formatted correctly than default values will be used.\\n\\n!! Example settings.json file\\n\\n```\\n{\\n  \\\"editionsPath\\\": \\\"./Editions\\\",\\n  \\\"filePathRoot\\\": \\\"./Wikis\\\",\\n  \\\"pluginsPath\\\": \\\"./Plugins\\\",\\n  \\\"themesPath\\\": \\\"./Themes\\\"\\n  \\\"wikisPath\\\": \\\"./Wikis\\\",\\n  \\\"wikiPathBase\\\": \\\"cwd\\\",\\n  \\\"includePluginList\\\": [],\\n  \\\"excludePluginList\\\": [],\\n  \\\"autoUnloadWikis\\\": \\\"false\\\",\\n  \\\"disableBrowserAlerts\\\": \\\"false\\\",\\n  \\\"fileURLPrefix\\\": \\\"files\\\",\\n  \\\"namespacedWikis\\\": \\\"false\\\",\\n  \\\"suppressBrowser\\\": \\\"false\\\",\\n  \\\"scripts\\\": {\\n    \\\"NewWiki\\\": \\\"tiddlywiki #wikiName --init #editionName\\\"\\n  },\\n  \\\"wikis\\\": {\\n    \\\"OneWiki\\\": \\\"/home/inmysocks/TiddlyWiki/Wikis/OneWiki\\\",\\n    \\\"TwoWiki\\\": \\\"/home/inmysocks/TiddlyWiki/Wikis/TwoWiki\\\",\\n    \\\"OokTech\\\": {\\n      \\\"TestWiki\\\": \\\"/home/inmysocks/TiddlyWiki/Wikis/TestWiki\\\"\\n    }\\n  },\\n  \\\"ws-server\\\": {\\n    \\\"port\\\": 8080,\\n    \\\"host\\\": \\\"127.0.0.1\\\",\\n    \\\"autoIncrementPort\\\": \\\"false\\\",\\n    \\\"servePlugin\\\": \\\"true\\\"\\n  },\\n  \\\"heartbeat\\\": {\\n    \\\"interval\\\": 1000,\\n    \\\"timeout\\\": 5000\\n  },\\n  \\\"mimeMap\\\": {\\n    \\\".ico\\\": \\\"image/x-icon\\\",\\n    \\\".html\\\": \\\"text/html\\\",\\n    \\\".js\\\": \\\"text/javascript\\\",\\n    \\\".json\\\": \\\"application/json\\\",\\n    \\\".css\\\": \\\"text/css\\\",\\n    \\\".png\\\": \\\"image/png\\\",\\n    \\\".jpg\\\": \\\"image/jpeg\\\",\\n    \\\".jpeg\\\": \\\"image/jpeg\\\",\\n    \\\".wav\\\": \\\"audio/wav\\\",\\n    \\\".mp3\\\": \\\"audio/mpeg\\\",\\n    \\\".svg\\\": \\\"image/svg+xml\\\",\\n    \\\".pdf\\\": \\\"application/pdf\\\",\\n    \\\".doc\\\": \\\"application/msword\\\",\\n    \\\".gif\\\": \\\"image/gif\\\"\\n  },\\n  \\\"API\\\": {\\n    \\\"enableFetch\\\": \\\"no\\\",\\n    \\\"enablePush\\\": \\\"no\\\",\\n    \\\"pluginLibrary\\\": \\\"no\\\"\\n  },\\n  \\\"logger\\\": {\\n    \\\"useFileLogging\\\":\\\"no\\\",\\n    \\\"outputFolder\\\": \\\"./logs\\\",\\n    \\\"outputBaseFileName\\\": \\\"Log\\\",\\n    \\\"useSeparateErrorFile\\\": \\\"no\\\",\\n    \\\"outputErrorFileName\\\": \\\"Error\\\",\\n    \\\"ignoreErrors\\\": \\\"yes\\\",\\n    \\\"useBrowserLogging\\\": \\\"no\\\",\\n    \\\"browserLogLevel\\\": \\\"2\\\",\\n    \\\"useConsoleLogging\\\": \\\"yes\\\",\\n    \\\"consoleLogLevel\\\": \\\"2\\\",\\n    \\\"useFileLogging\\\": \\\"no\\\",\\n    \\\"fileLogLevel\\\": \\\"2\\\"\\n  },\\n  \\\"federation\\\": {\\n    \\\"serverName\\\": \\\"Noh Neigh-m\\\",\\n    \\\"mobile\\\": \\\"no\\\",\\n    \\\"enableChat\\\": \\\"no\\\"\\n  }\\n}\\n```\\n\\n''Note:'' All paths can be either absolute or relative. Relative paths are\\nrelative to the path listed in `wikiPathBase`, if none is listed they are\\nrelative to the folder with tiddlywiki.js in it if you are using the plugin\\nversion or the folder with the executable file if you are using the BobEXE version.\\n\\n''Note for windows:'' All the example paths here are how they would appear on\\nlinux or osx. On windows the paths would look like\\n`C:\\\\Users\\\\inmysocks\\\\TiddlyWiki\\\\Wikis`. To make the examples what you would use\\nin windows replace `/home` with `C:\\\\Users` and change the `/` into `\\\\`.\\n\\n!! What each part is\\n\\n* `editionsPath` is the folder that holds any custom editions you want to be able to use when making wikis using the control panel.  If relative it is relative to `wikiPathBase`.\\n* `filePathRoot` is the root folder where external files are served. If you want to use an external image from your computer in your wiki than you need to set this to a parent folder of where the pictures are. If none is given than local files aren't served.\\n* `pluginsPath` is the path to the plugins folder if you are using the as a plugin library.  If relative it is relative to `wikiPathBase`.\\n* `themesPath` is the path to the folder where you have your themes.  If relative it is relative to `wikiPathBase`.\\n* `wikisPath` the name of the default wikis folder to use. If relative it is relative to `wikiPathBase`.\\n* `wikiPathBase` relative paths for everything other than serving files are relative to this path. It defaults to the current working directory.\\n* `includePluginList` is an array of plugin names that will be included in every wiki served. You do not have to include Bob in this list.\\n* `excludePluginList` is an array of plugin names that will not be included in any wiki served, even if it is listed in the tiddlywiki.info file. This does not prevent someone from installing the plugin via drag-and-drop or from a plugin library, it just affects plugins listed in `tiddlywiki.info` files.\\n* `autoUnloadWikis` if this is set to `true` than wikis with no active connections will be automatically unloaded from memory. (experimental, may cause problems)\\n* `disableBrowserAlerts` if this is set to `true` than no alerts are sent to the browser wikis. This can also be set on a per-wiki basis in the control panel.\\n* `fileURLPrefix` is the prefix used to distinguish file links from wikis. This has the normal restrictions on names as any URL, so avoid special characters. This defaults to `files` and only have an affect if you have also set `filePathRoot`. Note: If you set this to an empty string it will use the default value of `files` unless you set the `acceptance` value described below. This will break things and no tech support will be provided.\\n* `namespacedWikis` this only has an effect if you are using an external server with a login. If so this prefixes the wiki path with the currently logged in persons name when creating a wiki.\\n* `suppressBrowser` is only used if you are using the single executable version. If it is set to `true` than the browser isn't opened automatically when the server is started.\\n* `scripts` a list of scripts that you can call from inside the wiki using the `runScript` websocket message.\\n* `wikis` a list of child wikis to serve. The path to the wikis is determined by the name given. In the example above the wiki located at `/home/inmysocks/TiddlyWiki/Wikis/OneWiki` would be served on `localhost:8080/OneWiki` and the wiki located at `/home/inmysocks/TiddlyWiki/Wikis/TestWiki` would be served on `localhost:8080/OokTech/TestWiki`. You may have as many levels and wikis as you want.\\n* `ws-server` settings for the `wsserver` command.\\n** `port`\\n** `host`\\n** `rootTiddler` changing this will probably break everything\\n** `renderType` changing this will probably break everything\\n** `serveType` changing this will probably break everything\\n** `pathPrefix` a prefix for the path that wikis are served on.\\n** `autoIncrementPort` if not set to `false` than the server will try using the given port (`8080` by default) and if it is in use it will try the next port up and continue until it finds an open port to use. If this is set to false than if the given port is in use an error is thrown and the process fails.\\n** `servePlugin` is not `false` than any child wiki served will include the Bob plugin. So you can serve wikis that don't normally have the plugin and edit them as though they did.\\n* `heartbeat` settings for the heartbeat that makes sure the browser and server are still connected. You can almost certainly ignore these settings.\\n** `interval` the heartbeat message is sent every `interval` milliseconds (1000 milliseconds = 1 second).\\n** `timeout` is the length of time to wait for a heartbeat signal before assuming that the connection is no longer working.\\n* `mimeMap` lists the file extensions and their associated mime-types that the server is allowed to serve. This only has an effect if `filePathRoot` is set.\\n* `API` things in this group are used for the api used for inter-server communication using the TWederBob plugin. This is only active if you use the `--wsserver` command, if you use an external server than these don't do anything.\\n** `enablePush` if this is set to `yes` than the server will accept tiddlers pushed using the TWederBob plugin.\\n** `enableFetch` if this is set to `yes` than the server will let people fetch tiddlers from the server using the TWederBob plugin.\\n** `pluginLibrary` if this is set to `yes` than the server will act as a plugin library. (you also have to set the `pluginsPath`, see above)\\n* `logger` settings for the logger Bob uses\\n** `useFileLogging` set to `yes` to enable writing logs to files\\n** `fileLogLevel` set this to an integer from `0` to `4` to indicate how much logging you want in the log files. `0` is none, `4` is everything.\\n** `outputFolder` set to the folder name to use for the log files\\n** `outputBaseFileName` logs will use this as the base name\\n** `useSeparateErrorFile` set to `yes` if you want to have separte files for logs and error messages (stdout vs stderr)\\n** `outputErrorFileName` set this to the base file name to use for error log files\\n** `ignoreErrors` set this to `yes` to ignore logger errors (recommended!)\\n** `useBrowserLogging` set this to `yes` to have log messages sent to the browser\\n** `browserLogLevel` set this to an integer from `0` to `4` to indicate how much logging you want in the browser. `0` is none, `4` is everything.\\n** `useConsoleLogging` set this to `yes` to log output to the console\\n** `consoleLogLevel` set this to an integer from `0` to `4` to indicate how much logging you want in the console. `0` is none, `4` is everything.\\n* `federation` settings for inter-server federation and connections\\n** `serverName` is the human readable name that the server uses to identify itself. It does not need to be unique, but having it be unique is less confusing.\\n** `mobile` set this to `yes` if the server isn't going to have the same url or ip address all the time.\\n** `enableChat` set this to `yes` to enable the federated chat server.\\n* `acceptance` this is a setting for accepting that you will get no help if you do something that requires it to be set. These are things that are either insecure or have a very good chance of breaking your wiki. You will get no tech support if you do any of them. If you want to do it anyway than you need to give this the value `I Will Not Get Tech Support For This`.\\n* `allowUnsafeMimeTypes` setting this to `true` lets you serve anything ignoring the mimeMap. This is a bad idea but it was consistently requested so you have to fill out the `acceptance` key and you will receive no support for any problems that arise.\\n\\n''Note:'' Only changes to the `scripts` and `wikis` will be available without\\nrestarting the server. You still need to save the settings using the\\n`Update Settings` button after making changes in the `Manual Settings` tab\\nunder the `Bob Settings` tab in the $:/ControlPanel. If you change a wiki name\\nor path you also need to click on the `Update Routes` button after you click on\\nthe `Update Settings` button for your changes to take effect.\\n\\nAny other changes require a full server restart.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Creating New Wikis\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Creating New Wikis\",\n            \"caption\": \"Creating New Wikis\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Create and serve new wikis from inside a wiki.\",\n            \"text\": \"Reading about [[wiki paths|$:/plugins/OokTech/Bob/Wiki Paths]] may be useful In addition to the information\\npresented here.\\n\\nThere are multiple ways to make new wikis with Bob.\\n\\nTo create a new wiki go to the `Bob Settings` tab of the $:/ControlPanel and\\nopen the `Available Wikis` tab and select which method you want to use from the\\nradio buttons.\\n\\nFor the most part if you are unsure you will want to make a new wiki from an\\nedition and use the `empty` edition. This will give you the Bob equavilent of\\ndownloading an empty wiki from tiddlywiki.com.\\n\\nMore instruction about how to use each option is below.\\n\\nAfter creating a new wiki it will be available on `localhost:8080/WikiName`\\n(assuming you called the wiki WikiName and your wiki is served on port 8080\\nusing the default settings). If you are not on the computer running the server\\nor have changed the settings than the url is the url of your root wiki with\\n`/WikiName` added to the end.\\n\\n''Note:'' Wiki names are limited to what can be used in a URL. So they can be\\nunaccented letters in the latin alphabet (a-z, A-Z) or digits (0-9). They can\\nnot contain any spaces or other whitespace. As a special restriction wikis can\\nalso not be named `files` or `__path`.\\n\\n!!an edition\\n\\nSelect the edition you want to use as the base from the drop down menu labelled\\n`Select Wiki Edition` and then give the wiki a name in the text field, then\\nclick the `Make Wiki` button.\\n\\nYou can limit which editions are listed in the drop-down menu by listing the\\neditions you want to have available by creating a wiki called\\n`$:/ListedEditions` and listing the editions in the text field as a space\\nseparated list.\\n\\nExample:\\n\\n```\\nempty codemirrordemo\\n```\\n\\n!!an html file\\n\\nThis is for when you hvae a normal single html tiddlywiki and you want to make\\nit into a wiki you can use with Bob.\\n\\nSelect the `an html file` option from the radio buttons. Then click the\\n`Browse` button where it says `Select file` and find the wiki file you want to\\nuse on your computer.\\n\\nAfter selecting the file give the wiki a name using the text input box and then\\nclick the `Make Wiki` button. All of the tiddlers in the html file will be\\ncopied into a new wiki listed in the available wikis list.\\n\\nThis will not update the single file wiki when you make changes in Bob, you\\nwill have to export the wiki manually. See [[exporting wikis|]] for how to\\neasily do that.\\n\\n!!existing tiddlers\\n\\nIf you already have multiple wikis served by Bob and you want to create a new\\nwiki using tiddlers from one of more of them than you select this option.\\n\\nGive the wiki a name using the text box labelled `Give the wiki a name`. Then\\nbelow put a wiki name in the FromWiki box (using the same names as in the wiki\\nlisting) and in the filter give a filter to be applied to that wiki. The\\ntiddlers returned by this filter will be added to the newly created wiki.\\nClick the `Add Filter` button to include the filter. You can then add a filter\\nfor tiddlers from another wiki if you wish. You can add filters for as many\\nwikis as you want.\\n\\nWhen you have the filters you want to use listed click `Make Wiki` to create\\nthe wiki. The new wiki will be listed in the list of available wikis.\\n\\n!!a node wiki\\n\\nIf you have a node-based wiki that isn't currently listed in Bob you use this\\noption.\\n\\nThis is the same as manually adding the wiki in the manual setting tab.\\n\\nGive the wiki a name in the text box, remember that wiki names have to be\\nunique. This is the only method listed here that doesn't protect you from using\\nan existing name. The other methods will append a number to the end of the name\\nif it is not unique.\\n\\nEnter the path to the node wiki folder. This in the folder that has the\\ntiddlywiki.info file for the wiki. The path can be absolute or relative.\\nRelative paths are relative to the location where you started the wiki. In the\\ncase of the BobEXE they are relative to the location of the executable.\\n\\nThen click on the `Add Wiki` button and it will be listed under the available\\nwikis.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Exporting Wikis\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Exporting Wikis\",\n            \"caption\": \"Exporting Wikis\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Save or export wikis as single html files\",\n            \"text\": \"There are multiple ways to save a wiki made with Bob as a single file wiki.\\n\\nYou can also export wikis that are a combination of tiddlers from multiple\\nwikis or a subset of tiddlers from a single wiki.\\n\\n! Download a single html version of the current wiki\\n\\nThis is the most direct method of saving a wiki. It downloads the wiki as a\\nsingle file in (almost) the same way as when you click the save button on a\\nsingle file wiki.\\n\\nThere are a few changes:\\n\\n* The downloaded file has the Bob plugin removed, as well as some other\\n  server-specific plugins that have no purpose in a singe file wiki. This makes\\n  the resulting wiki file smaller.\\n* You can use an exclude filter to exclude certain tiddlers from the downloaded\\n  file\\n* You can use an include fliter to only include certain tiddlers in the\\n  downloaded file\\n\\nSee [[$:/plugins/OokTech/Bob/ActionDownloadWiki]] for more documentation.\\n\\n! Export a single html version of tiddlers from multiple wikis to the server\\n\\nThis method lets you pick and choose which tiddlers you want included in your\\ndownloaded file, not just from the current wiki but from any wiki served by\\nBob.\\n\\nThis saves the wiki on the server, it doesn't offer it as a download. If you\\nare using the computer that is running Bob than this is like it downloading the\\nwiki without you needing to tell the computer where to put the file.\\n\\nBy default the output file is called `index.html` and it is saved in the\\n`output` folder of the current wiki. These are the same defaults as the normal\\nbuild command used by the node version of tiddlywiki.\\n\\nSee [[$:/plugins/OokTech/Bob/WebSocketMessage-buildHTMLWiki]] for more.\\n\\n<!--\\n! Download an already exported singe file wiki from the server\\n\\nAfter you have used the second method above you can request the file from the\\nserver as a download.\\n\\nIt is undocumented for now\\n-->\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/External Libraries Used\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/External Libraries Used\",\n            \"caption\": \"External Libraries Used\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"text\": \"Bob uses three npm modules in addition to what is used by the base tiddlywiki.\\n\\n* [[ws|https://github.com/websockets/ws]] - This adds the websocket interface to the node server. ([[License|$:/plugins/OokTech/Bob/External/WS/LICENSE]], [[Readme|$:/plugins/OokTech/Bob/External/WS/README]])\\n* [[ip|https://github.com/indutny/node-ip]] - This gives the server information about its own ip address so the ip address can be displayed in the $:/ControlPanel making it easier to connect other computers to the server. ([[Readme|$:/plugins/OokTech/Bob/External/IP/README]])\\n* [[async-limiter|https://github.com/strml/async-limiter]] - This is a module required by `ws` ([[License|$:/plugins/OokTech/Bob/External/async-limiter/LICENSE]], [[Readme|$:/plugins/OokTech/Bob/External/async-limiter/README]])\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Federation\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Federation\",\n            \"caption\": \"Federation\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Federation between servers\",\n            \"text\": \"''HUGE WARNING:'' Do not enable this anywhere but on your home network where\\nyou know everything connected to the network. This is very very experimental\\nand currently has no security features enabled while the communication parts\\nare being worked out.\\n\\nNote: All of this is still experimental, it has worked well for me but one\\nperson testing is nowhere near enough for something to be considered stable.\\n\\nNote 2: This is unfinished, it doesn't have any security or privacy controls\\nimplemented yet. They are coming in future updates but for now if you enable\\nthis on a public network you are announcing to the world what you have and\\nallowing anyone to get copies of your wikis and potentially edit your wikis.\\n\\n!! Federation\\n\\nFederation allows communication between different servers.\\n\\nThis allows many things.\\n\\n!!!currently implemented features:\\n\\n* syncing wikis\\n* real-time chat between different servers\\n\\n!!!Planned features:\\n\\n* security and privacy controls\\n* Separate chat conversations\\n* Proper chat syncing (new members in conversations can get the conversation history)\\n* fetching tiddlers from wikis on remote servers (this is implemented as part of the syncing, but conceptually it should have a separate interface despite using the same back-end mechanisms)\\n* request other servers pull tiddlers from the local server (same note as above)\\n\\n!! Real-time chat\\n\\nTo use the chat you need to enable federation (TODO put instructions here) and\\nenable chat (TODO put instructions here).\\n\\nOnce everything is enabled Bob should automatically connect to any other Bob\\nservers on the same network.\\nOpen the chat interface, enter the name you want to use and start chatting.\\nWhen you type in the text input you can either click the `Send` button or press\\nenter to send the message.\\n\\n!! Backend things\\n\\nThe local server saves information about remote servers. This includes:\\n\\n```\\nuniqueName: {\\n  serverName: human readable name,\\n  url: the most recent url used to connect to the remote server,\\n  staticUrl: if the url changes or not (yes or no),\\n  publicKey: a public key,\\n  notes: optional notes you can make about the server,\\n  allows_login: if the server allows you to login,\\n  available_wikis: {\\n    wikiName1: {\\n      sync: yes/no,\\n      sync_filter: <<someFilter>>,\\n      sync_type: pull/push/bidirectional,\\n      auto_sync: yes/no,\\n      public: yes/no,\\n      conflict_type: newestWins/oldestWins/localWins/remoteWins/manual,\\n      allows_login: yes/no\\n    },\\n    wikiName2: {\\n      <<same stuff>>\\n    }\\n  },\\n  chats: {\\n    chatName1: {\\n      public: yes/no,\\n      relay: yes/no\\n    }\\n  }\\n}\\n```\\n\\nServer info tiddler:\\n\\n$:/Bob/KnownServers/<uniqueName>\\n\\nServer info tiddler format:\\n\\n```\\n{\\n  serverName: some name,\\n  url: server url,\\n  staticUrl: yes/no,\\n  publicKey: a key,\\n  allows_login: yes/no,\\n  notes: some notes,\\n  available_wikis: space separated list of wiki names,\\n  available_chats: space separated list of chat names\\n}\\n```\\n\\nEach wiki on the server gets:\\n\\n$:/Bob/KnownServers/<uniqueName>/wikis/<wikiName>\\n\\n```\\n{\\n  sync: yes/no,\\n  sync_filter: <<someFilter>>,\\n  sync_type: pull/push/bidirectional,\\n  auto_sync: yes/no,\\n  public: yes/no,\\n  conflict_type: newestWins/oldestWins/localWins/remoteWins/manual,\\n  allows_login: yes/no\\n}\\n```\\n\\nEach chat on the server gets:\\n\\n$:/Bob/KnownServers/<uniqueName>/chats/<chatName>\\n\\n```\\n{\\n  public: yes/no,\\n  relay: yes/no\\n}\\n```\\n\\n* `uniqueName` will be `serverName (publicKey)` for now, it may end up just being 0, 1, 2, ... as more servers get added, it may never need to be shared with anyone else.\\n\\nto connect to another server select the serverName from a select widget,\\nthen there is an interface that has the available_wikis and the current sync\\nstatus and setup for the wiki.\\n\\nServers have to have a login interface as well so you can log in to see private\\nwikis and edit wikis.\\n\\nFor this the login is done using either username/password pairs or by a signed\\ntoken that the remote server can check against the public key it has listed.\\nThis should probably use this process:\\n\\n# Local server requests a login to the remote wiki\\n# Remote server replies with a random number\\n# Local server puts the random number into a signed token and sends it back to the remote server, if everything matches than this is the access token for further interactions.\\n# Because the token handshake is taken care of by the servers without needing human interaction the tokens can be changed as often as desired. Use a unique random number for each token sent.\\n\\nTo connect to a new server there is an interface where you enter the URL and it\\nrequests information from the remote server.\\nThe requested information is:\\n\\n* human readable server name\\n* public key\\n* available wikis\\n* if the server hosts chats\\n** if so which chats are currently available\\n** if new chats can be created using this server\\n\\nthis information is saved locally and can be used in the above interface.\\n\\n!!! Chat\\n\\neach server can host a chat server as well.\\nEach chat on a server has a unique name and can be public or private.\\n\\nWhen you connect to a server you get a list of chats available on that server.\\n\\nthen in the connection interface above you select the server and then a list of\\nchats that are available on that server appear, you can select a chat and the\\nchat interface for that chat appears and you get an update of the chat history\\nfor that server.\\n\\nYou probably have to click a button to load the conversation.\\n\\nThe chat message is the same for both local and federated chats, the setup of\\nthe chat itself lets the server know who to send what messages to.\\n\\nSo chats can be:\\n\\n* Public - Anyone can see it if they have joined, the chat will be listed in the public chats when a new server connection is made.\\n* Private - only explicitly listed logins can see them, regardless of location.\\n* Local - Anyone on the same Bob server can see the chat but it isn't federated out to other servers.\\n* Invite-Only - the same as private, except the chat is listed in the available chats and people can request access.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/FileSystemMonitor\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/FileSystemMonitor\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"caption\": \"File System Monitor\",\n            \"description\": \"Watching the file system for modifications to tiddler files\",\n            \"text\": \"By default Bob watches the tiddler files for each wiki and if any change\\nhappens it will immediately reflect those changes in the browser.\\nThis includes adding or removing tiddler files or editing their contents.\\n\\n!!! Note about file names\\n\\nOne effect of the file system monitor is that any file that is modified gets\\nchecked to make sure that the file name matches what it would be if the tiddler\\ngot created in the browser.\\nThis means if you make a tiddler file and call it `foo.tid` and put this\\ncontent inside it\\n\\n```\\ntitle: bar\\n\\nsome text\\n```\\n\\nthe file `foo.tid` would immediately be deleted and relpaced by a file called\\n`bar.tid` to match the tiddler title.\\n\\nThis is expected behaviour, but may take people off guard because it is not\\nimmediately obvious what happened.\\n\\nThese changes include placing tiddler files in subfolders of the tiddlers\\nfolder.\\nIf the rules for creating tiddler files used by tiddlywiki would not place the\\ntiddler file in that folder than the file is moved to where tiddlywiki expects\\nit to be.\\nYou can change the rules for where tiddler files are placed by creating or\\nediting the `$:/config/FileSystemPaths` tiddler.\\nSee [ext[the documentation on tiddlywiki.com|https://tiddlywiki.com/#Customising%20Tiddler%20File%20Naming]] for further details.\\n\\n!! Known problems\\n\\n!!! Networked Drives\\n\\nThe file system monitor does not work as expected on networked drives.\\nThe most common time this comes up is on windows shared drives, but it affects\\nmost remote storage options.\\nIf you store your wikis on a networked drive that isn't in the computer running\\nBob you should disable the file system monitor (see below for how).\\n\\n!!! File syncing (Dropbox, syncthing, etc.)\\n\\nThe file system monitor does not play well with most automated file syncing\\noptions.\\nBoth the file syncing system and Bob are trying to manage the files at the same\\ntime and both react to changes in files.\\nThis can lead to duplicate tiddler files or lost data.\\n\\nIt is very strongly recommended that you do not use file syncing on wikis\\nserved by Bob.\\n\\nIf you use syncing anyway you should at a minimum disable the file system\\nmonitor.\\n\\n!! Disabling the file system monitor\\n\\nIf you want to avoid the problems mentioned above or for some other reason\\nwould like to not use the file system monitor you can disable it.\\nTo disable it open the $:/ControlPanel, then open the `Bob Settings` tab, then\\nthe `Server` tab.\\nOn the `Server` tab there is a checkbox labelled `Disable File System Monitor`,\\ncheck that box then restart Bob.\\n\\nDisabling or reenabling the file system monitor requires a restart in order to\\ntake effect.\\n\"\n        },\n        \"title: $:/plugins/OokTech/Bob/Documentation/InterServerFederation\": {\n            \"title\": \"title: $:/plugins/OokTech/Bob/Documentation/InterServerFederation\",\n            \"caption\": \"Inter-server Federation\",\n            \"text\": \"!! Connecting to servers\\n\\nYou connect to a server by giving its url.\\n\\nAs part of the connection process you send the name of your server to the\\nremote server (along with your public key and a signed token, if that is set up)\\n\\nIf the remote server wishes to respond than it replies with its name and a\\nlisting of its public wikis and any wikis that you have permission to see or\\nedit.\\n\\nServer information is saved so that the next time you can try to connect to the\\nsame server using the same url. This works when the server doesn't move, or\\nwhen you are on the same local network as the server and you are using a unix\\nbased system like Linux or OSX and are using .local urls.\\n\\nAfter you have connected to a server than you can send messages between the\\nservers in the same way as between the browser and server.\\n\\nYou can:\\n\\n* Sync wikis\\n* Fetch wikis\\n* Set up a real time chat messenger\\n* Fetch/push tiddlers between different servers\\n* Arbitrary messages between servers\\n* Set up repeated/continuous syncing between servers\\n* Other things?\\n\\n!! Server Info\\n\\nFor each known server the wiki saves info.\\n\\n* Server Name\\n* Most recent server URL\\n* A flag to set if the server is mobile or not (if it always uses the same url)\\n* What wikis are accessible on the server\\n* What wikis to sync with the remote server, and the type of syncing\\n** This would be wiki name, sync filter, direction, conflict resolution type\\n* If the server supports chat\\n\\n!! Interface\\n\\n* A listing of all of the known servers in the control panel federation tab\\n* Somewhere a chat interface for remote servers\\n* A one-time wiki syncing thing\\n* A fetch/duplicate remote wiki thing\\n* Set up repeated syncing and the interval or conditions for checking\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/LazyLoading\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/LazyLoading\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"caption\": \"Lazy Loading\",\n            \"description\": \"Only loading tiddler metadata until a tiddler is used to improve loading times\",\n            \"text\": \"You can turn on lazy loading by going to the $:/ControlPanel, then the\\n`Bob Settings` tab then the `Server` tab.\\n\\nAlternatively you can enable or disable lazy loading by directly editing the\\nmanual settings.\\nTo enable lazy loading set the `rootTiddler` key under `ws-server` to\\n`$:/core/save/lazy-all` or `$:/core/save/lazy-images`.\\nTo disable lazy loading either remove the key or set it to `$:/core/save/all`.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Logging\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Logging\",\n            \"caption\": \"Bob Logging\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"logging output from Bob\",\n            \"text\": \"Output from Bob can be logged in three places, a file, in the browser or to the\\nterminal console.\\n\\nThe logging output can be to any mix of the outputs, or none.\\nThe logging can also have multiple levels, and the logging level for each\\noutput can be set independently.\\n\\n!! Configuring logging\\n\\nConfiguration options are set using in the `logging` section of the settings.\\n\\nBy default, if nothing is set, than the logging level is `2` and only logging\\nto the console is enabled.\\nTo enable each logging output the keys `useFileLogging`, `useConsoleLogging`\\nand `useBrowserLogging` can be set to `yes` or `no`.\\n\\nSetting the logging level for each logging endpoint is set using `fileLogLevel`\\n`browserLogLevel` and `consoleLogLevel`\\n\\n!! Logging levels\\n\\nHigher numbers have more logging output, each level adds to the levels below\\nit.\\n\\n* `-1` (almost) no logging. There is still some output from loading the settings initially because the settings are what tell the system the logging level.\\n* `0` Only necessary outputs, like what port the wikis are served on and errors that crash the server.\\n* `1` 'Normal' messages, listing wikis that are created or deleted, wiki paths, etc.\\n* `2` verbose logging. Every tiddler that is saved or deleted is listed, every error is also listed.\\n* `3` debugging level of output. Lots of information that isn't useful for anything other than debugging.\\n* `4` a truly ridiculous amount of logging\\n\\n''Note:'' Output for levels 3 and 4 is still being added, so it may not be as\\nverbose as expected.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/getSetting Macro\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/getSetting Macro\",\n            \"caption\": \"getSetting Macro\",\n            \"tags\": \"Macros\",\n            \"text\": \"A convenience macro to return the value of a setting in the settings\\npseudo-json structure.\\n\\nThis is needed because tiddlywiki doesn't support nested json objects and\\nthe settings structure is faking it.\\n\\nThis is done relative to the tiddler given by the root parameter.\\n\\nTo fit with tiddlywiki as much as possible each level is separated by ##\\n\\n{\\n  First: {\\n    Second: {\\n      Item: Value\\n    }\\n  }\\n}\\n\\nGiven the above JSON you could use this:\\n\\n`<<getSetting key:\\\"First##Second##Item\\\">>`\\n\\nnote that you can leave out the `key:` part and use this:\\n\\n`<<getSetting \\\"First##Second##Item\\\">>`\\n\\nboth would return `Value`\\n\\nNote that this returns the first leaf reached. If you add extra levels that\\ndon't exit to the end of the key they are ignored. So in the example if you\\nused First##Second##Item##this##changes##nothing than it would work the same\\nway.\\n\\n!! Parameters\\n\\n''key''\\n\\n  The key to look up. If you are looking up a value that isn't on the root\\n  level than you separate each level's key by `##`, like\\n  FirstLevel##SecondLevel##key.\\n\\n''root''\\n\\n  (optional) the root tiddler for the settings. Defaults to\\n  `$:/WikiSettings/split`\\n\\n!! Example\\n\\nThe code\\n\\n`<<getSetting ws-server##host>>`\\n\\ngives\\n\\n<<getSetting ws-server##host>>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Bob Plugin Library\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Bob Plugin Library\",\n            \"caption\": \"Bob Plugin Library\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"setting up Bob as a plugin library\",\n            \"text\": \"A Bob server can be configured as a plugin library.\\nTo do this you need to set the `pluginLibrary` key under `API` to `yes` in the\\nsettings and then set the `pluginsPath` key to wherever you have your plugins.\\n\\nPlugins are assumed to be in the same format as used by the core wiki.\\nSo under the plugins folder there should be folders that have the author names\\nand under those folders that have the plugin names which hold the `plugin.info`\\nfiles.\\n\\nLook at the plugins folder of the tiddlywiki5 repo for an example.\\n\\nWhen listing plugins Bob looks for a tiddler whose title ends with `/readme`\\n(capitilisation is not important, so `/ReadMe`, `/README` or `/ReAdMe` would\\nalso work) and sends the text field of that tiddler with the plugin info.\\n\\n!!! Adding Plugins to the Library\\n\\nThere is a tab `Manage Plugins` under `Bob Settings` that has tools for adding\\nplugins that you have dragged and dropped into the wiki to the plugin library.\\nOnly plugins that are not already in the library are listed in this.\\n\\nAlternately you can add plugins to the library in three ways:\\n\\n- Git - You can use git to clone plugins into your plugin folder and they can\\n  be accessible in the library.\\n- API - You can use the api to POST plugins and have them saved in the library\\n- Websocket Message - If you have the plugin in your wiki via drag and drop\\n  than you can add it to the library using the `savePluginFolder` message.\\n\\n!!! Changing Plugins Used by a Wiki\\n\\nIn the `Manage Plugins` tab under `Bob Settings` in the $:/ControlPanel you can\\nchange which plugins are in a wiki. You should click `Update Plugin List` to\\nmake sure that you have a complete list of plugins.\\n\\nThen you can select whichever plugins from the list that you want to have in\\nyour wiki. After selecting the plugins you want click `Save Plugin Selection`\\nto update the `tiddlywiki.info` file then reload the page. Clicking\\n`Refresh Page` will do this, or use the normal browser reload.\\n\\nAfter reloading the wiki will have the new list of plugins.\\n\\n''Note:'' This will not remove plugins that you have added by drag and drop.\\nYou have to delete them like normal. If you have added a plugin using this\\nmethod after you added the plugin via drag and drop you can delete the plugin\\ntiddler before reloading the page.\\n\\n!! Developer Information\\n\\n''Note:'' This is information for developers. If you are setting up or using\\nBob as a plugin library you can ignore this. This section is only relevant if\\nyou are going to create your own interface to the plugin library.\\n\\nThere are two RESTful api endpoints that are part of the plugin library. They both accept POSTs and return the requested information as stringified JSON.\\n\\n* `/api/plugins/list` returns a list of all plugins available in the library\\n  (see list format below)\\n* `/api/plugins/fetch/Author/Plugin` returns the plugin as a json object.\\n\\nThe plugin list endpoint returns a list as an array in this format:\\n\\n```\\n[\\n  {\\n    name: Author/Plugin,\\n    description: plugin description field,\\n    tiddlerName: the plugin tiddler name,\\n    version: the plugin version,\\n    author: the plugin author,\\n    readme: the text of the plugins readme tiddler\\n  },\\n  {\\n    name: Author/Plugin2,\\n    description: plugin description field,\\n    tiddlerName: the plugin2 tiddler name,\\n    version: the plugin version,\\n    author: the plugin author,\\n    readme: the text of the plugins readme tiddler\\n  }\\n]\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Running Scripts Using Websocket Messages\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Running Scripts Using Websocket Messages\",\n            \"caption\": \"Running Scripts Using Websocket Messages\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Run shell scripts from the wiki.\",\n            \"text\": \"For safety it is set up so that you can only run messages that are defined in\\nthe settings.\\n\\nTo define a script to run make a new entry in the `scripts` section of the\\nsettings. The name is what you send in the websocket message, the value is the\\ncommand you want to run.\\n\\nTo run the `ls` command you put this in it:\\n\\n`'test': 'ls'`\\n\\nthen you would make a button like this:\\n\\n```\\n<$button>\\n  Test Script\\n  <$action-websocketmessage $type='runScript' name='test'/>\\n</$button>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/SaverServer\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/SaverServer\",\n            \"caption\": \"Saver Server\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Using Bob to save single file wikis\",\n            \"text\": \"!! First a bit of a warning to not change the configuration\\n\\nThe saver server is a separate server than the one for the wikis.\\nIt allows different actions and saving files anywhere on your computer.\\nUsing the default settings there are no security concerns, only html files can\\nbe saved and they can only be saved by someone using the computer running Bob\\nor BobEXE and no one else even if Bob is configured to allow people to access\\nwikis on the local network.\\n\\nChanging this configuration is not something that you can do by accident.\\n\\nIt is possible to configure the saver server to accept save requests from\\nsomething other than the computer running Bob. This is very strongly\\ndiscouraged. See [[the big note of doom|$:/plugins/OokTech/Bob/BigNoteOfDoom]].\\n\\nIf you want an extra layer of security you can use a saver key.\\nThis is a similar idea to a wifi password, you set it in the $:/ControlPanel\\nin Bob and then you have to enter the same key in the single file wikis you\\nwish to save or they will not be able to save.\\n''This is not sufficient to make changing the configuration a good idea.''\\n\\n!! And now on to what it actually is\\n\\nFor this Bob and BobEXE are considered the same thing. All of this applies\\nregardless of if you are using BobEXE or you are using Bob as a plugin.\\n\\nBob has an integrated server that allows you to use the BobSaver to save single\\nfile wikis without any further configuration.\\n\\nThe server is enabled by default.\\nAll you need to do is start Bob and then you can open up any single file wiki\\non your computer and edit it and save it normally.\\nThere are not restrictions on where in your file system you can save as long as\\nyou could save files there normally.\\n\\nIt works with both autosaving and manual saving.\\n\\n!!! Setting the saver key\\n\\nTo set the saver key open the $:/ControlPanel, then the `Bob Settings` tab,\\nthen the `Saver Server` tab.\\n\\nEnter the key you wish to use in the `Saver Key:` text box and then click on\\nthe `Save Settings` button.\\n\\nRemember that if you set this key every html wiki you wish to save will need to\\nhave the same key entered.\\n\\nTo enter the key in a single file wiki open the $:/ControlPanel then the\\n`Saving` tab then the `BobSaver` tab.\\n\\nEnter the key is the text entry box labeled `Key:`\\n\\n!!! Disabling the saver server\\n\\nTo disable the saver server go to the $:/ControlPanel, open the\\n`Bob Settings` tab, under that open the `Saver Server` tab and check the box to\\ndisable the saver server. There are more detailed instructions on the\\n`Saver Server` tab.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Selective Syncing\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Selective Syncing\",\n            \"caption\": \"Selective Syncing\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Select which tiddlers are synced with the server\",\n            \"text\": \"''Note:'' Changing the filter changes what can be saved and may have unintended\\nconcequences. Unless you know exactly what you are doing don't remove anything\\nfrom the default filter, only add more patterns to exclude other tiddlers.\\n\\nYou can change the filter listed in [[$:/plugins/OokTech/Bob/ExcludeSync]]\\nto change what is saved by the wiki. The filter returns tiddlers that won't be\\nsaved by the wiki.\\n\\nSo anything you change in a tiddler returned by that filter is not saved\\nbetween wiki refreshes and isn't sent to the server.\\n\\nThis is the same filter used by the server to determine if a tiddler should be\\nsent to the browser.\\n\\nThe default filter is:\\n\\n```\\n[has[draft.of]][prefix[$:/state/]][prefix[$:/temp/]][[$:/StoryList]][[$:/HistoryList]][[$:/status/UserName]][[$:/Import]][[$:/plugins/OokTech/Bob/Server Warning]]\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/ServerMedia\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/ServerMedia\",\n            \"caption\": \"Server Media\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Save imported media on the server instead of adding the media to a tiddler\",\n            \"text\": \"When this is enabled media files that are imported into the wiki will be saved\\nto the file system and a tiddler with the appropriate type and a\\n`_canonical_uri` field that points to the media file is created instead of\\ncreating a tiddler that contains a base64 encoded version of the media.\\n\\nThis can be very helpful because otherwise all of the media imported into a\\nwiki would have to be loaded before the wiki could fully load, having them\\nsetup as external files means that they are loaded when they are viewed.\\n\\nThis is enabled by default, to disable this feature open the $:/ControlPanel,\\nthen the `Bob Settings` tab, then the `File Server` tab and uncheck the\\n`Save media on server` checkbox.\\n\\nAfter disabling the server, or re-enabling it, you have to click on the\\n`Update Settings` button for it to take effect.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Serving Files\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Serving Files\",\n            \"caption\": \"Serving Files or Images\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Set up the server to serve static files from the local file system.\",\n            \"text\": \"''Big note of doom:'' If you are serving files and you have the host set to\\n`0.0.0.0` than anyone on the local network can access the files that you are\\nserving. So if you are sitting in Starbucks and you have the host set to\\n`0.0.0.0` and you have pdf copies of your tax documents in a sub-folder of\\nyour `filePathRoot` than everyone on the wifi at starbucks has access to those\\ndocuments. The simple solution is to not serve on `0.0.0.0` unless you are on\\nyour home network.\\n\\n---\\n\\nBob, like any other node.js version of tiddlywiki, does not handle external\\nfiles the same way that single file wikis do.\\nThis means that you can't just reference files by their location on your\\nharddrive the way you can with the single file wikis.\\nTo access files on your harddrive while using Bob you have to enable the file\\nserver component of Bob.\\n\\n!! Using the interface\\n\\nEverything can be done using the graphical interface in the control panel.\\n\\nTo get to the interface go to the $:/ControlPanel -> `Bob Settings` tab ->\\n`Server` tab -> `File Server` tab\\n\\n!!! Enabling the server\\n\\nTo enable the file server check the `Enable File Server` box.\\n\\nThis should enable the server, but due to browser caching you may still have to\\nreload the wiki page before images will appear.\\n\\n!!! Default Setup\\n\\nOnce the file server is enabled than every wiki can have a folder called\\n`files` next to the `tiddlers` folder that contains files that are accessible\\nto that wiki. This requires no setup past enabling the file server.\\n\\nFiles for each wiki have different uri prefixes. For the root wiki getting a\\nfile called `FileName.jpg` it is:\\n\\n`/files/FileName.jpg`\\n\\nFor a wiki called `This/Wiki` the uri would be:\\n\\n`/This/Wiki/files/FileName.jpg`\\n\\n!!! Saving media files on the server\\n\\nIf the file server in enabled than by default any media files that are imported\\ninto the wiki will be saved on the server and a `_canonical_uri` tiddler gets\\ncreated in the wiki instead of saving the media it the wiki itself.\\n\\nThis can help a lot with file size and loading times if you have a lot of media\\nin your wikis.\\nIt also greatly reduces the memory used by the server.\\n\\n!!! Advanced Setup\\n\\nBelow the check box there is a table that lists all of the other folders that\\nhave files that are accessible from within the wiki along with the prefix for\\nthose folders.\\n\\nTo add a new folder enter a prefix and path in the interface and click\\n`Add Folder`.\\n\\nIf you give the prefix `media` and what to access the file `FileName.jpg` in\\nthe folder listed the files in the folder are available in a similar way to\\nabove, the url prefix is `/files/media`\\n\\nSo the file would be available using at the url `/files/media/FileName.jpg`\\n\\n! Advanced configuration\\n\\nAfter enabling the file server it is easiest to just use the default settings.\\nUnless you have some compelling reason to change than it is recommended that\\nyou stick with the defaults.\\n\\nIf you have a reason to change the settings there are two relevant settings:\\n\\n* `fileURLPrefix` - this is the uri prefix to use for accessing files. This is used for files specific to individual wikis and files listed in the `servingFiles` section of the settings.\\n* `servingFiles` - this is an object that holds the prefix and path for different places where files are served from\\n** The content is in the form `prefix:path` as shown below\\n\\nExample:\\n\\n```\\nservingFiles: {\\n  docs: '/path/to/docs/folder',\\n  otherprefix: '/path/to/other/folder'\\n}\\n```\\n\\nthen the uri for files in the folder listed as `docs` would be in the form:\\n\\n`/wikiName/files/docs/fileName.ext`\\n\\nFiles that are only available to one wiki are served by default from the folder\\ncalled `files` inside the wiki folder, next to the `tiddlers` folder.\\n\\nThese defaults give the same paths to files as a single file wiki in the same\\nplace.\\n\\n!! Globally vs locally available files\\n\\nThis distinction is only relevant if you check the `per wiki files` box in the\\nfile server setup.\\nIf that isn't checked files in wiki-specific folders will be available to all\\nwikis and to anything outside tiddlywiki that can access the server, see the\\nbig note of doom at the top.\\n\\n!!! Globally available\\n\\nThese files are available to any wiki being served.\\n\\nYou can serve files from the local filesystem to make them available in the\\nwiki. This is particularly useful for things like images and pdf files that\\nwould make the wiki large if they were embedded as tiddlers.\\n\\nBy default the urls for files in that folder are prefixed with `files`, so if\\nyou have a file `foo.jpg` in the folder you are using than you can access it in\\nthe wiki like this:\\n\\n`[img[/files/foo.jpg]]`\\n\\nsub-folders of the folder listed are also available, so if you have\\n`filePathRoot` set to `/home/inmysocks/Pictures` and you have a folder called\\n`Plants` in that folder with `aloe.jpg` in it than you could get that image\\nlike this:\\n\\n`[img[/files/Plants/aloe.jpg]]`\\n\\nFolders served using the `Serve files from a new folder` section of the file\\nserver setup are all globally available.\\n\\n''Note about paths:'' For security you can't use any paths that would go above\\nthe base file path. So, using the example above, if you tried to access an\\nimage in `/home/inmysocks` by using the uri `./files/../foo.jpg` it would not\\nwork.\\n\\n!!! Files for specific wikis\\n\\nThese files are for specific wikis and, if you have set up access controls, are\\nonly available to that wiki.\\n\\nThese are similar to the globally available files with the following\\ndifferences:\\n\\n* The path root is the `files` folder located in the wiki folder, next to the tiddlers folder.\\n* To access these files you use the prefix `/wikiName/files/`, so if you have a wiki called `foo` and a picture called `bar.jpg` you would use `/foo/files/bar.jpg` to access it.\\n\\n!! File paths\\n\\nYou should not put a `.` at the start of the url to make it relative. It will\\nwork in some situations but it will not work in others. In general leaving out\\nthe `.` is a better idea in this situation.\\n\\n!!File Types\\n\\nEach file type that you want to serve has to be explicitly listed is the\\nsettings under the `mimeMap` property. If the mimeMap property is missing this\\nis used as the default:\\n\\n```\\nmimeMap: {\\n  '.aac': 'audio/aac',\\n  '.avi': 'video/x-msvideo',\\n  '.csv': 'text/csv',\\n  '.doc': 'application/msword',\\n  '.epub': 'application/epub+zip',\\n  '.gif': 'image/gif',\\n  '.html': 'text/html',\\n  '.htm': 'text/html',\\n  '.ico': 'image/x-icon',\\n  '.jpg': 'image/jpeg',\\n  '.jpeg': 'image/jpeg',\\n  '.mp3': 'audio/mpeg',\\n  '.mpeg': 'video/mpeg',\\n  '.oga': 'audio/ogg',\\n  '.ogv': 'video/ogg',\\n  '.ogx': 'application/ogg',\\n  '.png': 'image/png',\\n  '.svg': 'image/svg+xml',\\n  '.weba': 'audio/weba',\\n  '.webm': 'video/webm',\\n  '.wav': 'audio/wav'\\n}\\n```\\n\\nOnly files with the extensions listed will be served. You can add or remove\\nfile extensions as you wish, just make sure to give them the appropriate mime\\ntype or the browser may not know how to handle the file.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/SettingFavicons\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/SettingFavicons\",\n            \"caption\": \"Setting Favicons\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Notes about favicons with Bob\",\n            \"text\": \"To set the favicon for a wiki (a favicon is the little image shown on the\\nbrowser tab for most browsers) you can take an image tiddler and set its title\\nto `$:/favicon.ico`. This does not work with tiddlers that use `_canonical_uri`\\nfield.\\n\\n''Note:'' Due to details of how the file server component works if you set a\\nfavicon for the root wiki it is used as the default favicon for all of the\\nchild wikis. You can set the favicon for the child wikis normally and it works,\\nbut if there is none set it uses the same one as the root wiki.\\n\\nThis was not intended behaviour so it may change later, but I don't think it is\\na problem and it may be convenient.\\n\\nIf you want to set the favicon for your root wiki and have a child wiki with no\\nfavicon create an empty tiddler with the title `$:/favicon.ico` in the\\nchild wiki.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Starting Other Wikis\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Starting Other Wikis\",\n            \"caption\": \"Starting Other Wikis\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Serve multiple wikis at the same time.\",\n            \"text\": \"This works using the `wsserver` command included in this plugin.\\n\\n''Note:'' This describes how to make the Bob plugin serve existing wikis.\\nIf you want to create the wiki and start serving it you should look at\\n[[creating new wikis|$:/plugins/OokTech/Bob/Creating New Wikis]] instead.\\n\\nYou can start serving other wikis from within the wiki. First you need to give\\nthe wiki a name and list its path in the settings. Go to the `Bob Settings`\\ntab in the [[$:/ControlPanel]] and give the wiki a name and list its path in\\nthe `wikis` section like this:\\n\\n`'otherwiki': ~/Documents/TiddlyWiki/Wikis/Bob`\\n\\nthen click the `Update Settings` button under the list. Wait a moment for the\\nsave button to turn back to grey and then click on the `Update Routes` button\\nand your changes should take effect. It may take a few seconds for the server\\nto finish processing the requests.\\n\\nAfterward you will be able to go to `localhost:8080/otherwiki` to open the wiki\\n(assuming that you are using default settings)\\n\\n''Note:'' This does not create the wiki. If the wiki doesn't exist this won't\\ndo anything. To create a new wiki from within the wiki use the interface in the\\n$:/ControlPanel under the Bob tab. If for some reason you would rather do it\\nsome other way see the example for the\\n[[runScript message|$:/plugins/OokTech/Bob/WebSocketMessage-runScript]].\\n\\n<!--\\n!! Serving wikis using a script (Advanced)\\n\\nUsing the [[runScript|$:/plugins/OokTech/Bob/WebSocketMessage-runScript]]\\nwebsocket message you can run shell commands, so you can do this to start\\nserving other wikis normally from within a wiki.\\n-->\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Transform Filters\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Transform Filters\",\n            \"caption\": \"Transform Filters\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Filters that can be used to modify tiddler names when they are imported\",\n            \"text\": \"Transfom filters are filters that can be used to modify the names of tiddlers\\nwhen they are imported into a wiki.\\n\\nThe input to the filter is the original tiddler title and the output is used as\\nthe new title.\\n\\nExample:\\n\\nTransform Filter: `[addprefix[$:/prefix/]]`\\n\\nInput Title: `A Tiddler`\\n\\nOutput Title: `$:/prefix/A Tiddler`\\n\\n!! Some notes about context\\n\\nThese filters are evaluated in the context of the originating wiki, so you can use\\ntransclusions from that wiki to create the name.\\n\\nThis means that if you use this filter:\\n\\n`[addprefix{$:/WikiName}]`\\n\\nand pull a tiddler called `This Tiddler` from a wiki called `MyWiki` the title\\nwhen it gets pulled would be called:\\n\\n`MyWikiThis Tiddler`\\n\\nA perhaps more useful filter would be:\\n\\n`[addprefix[/]addprefix{$:/WikiName}addprefix[$:/imported/]]`\\n\\nwhich would result in the tiddler name\\n\\n`$:/imported/MyWiki/This Tiddler`\\n\\nnote that the prefixes are added left to right, so reading them in the filter\\ngives the opposite order than they appear in on the output.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/UsingProxies\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/UsingProxies\",\n            \"caption\": \"Using Proxies\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"text\": \"''Note:'' The developers do not have a setup to test these.\\nThey are community supplied so support for proxies needs to mainly come from\\nthe community.\\n\\n!! Setting up a proxy\\n\\nIf you use a proxy that rewrites the path component of the wiki URL than you\\nneed to set the removed prefix in the settings so that the browser can connect\\nto the websockets component of the server on the correct port.\\n\\n''Note:'' This is outdated, you should be able to ignore this setting now.\\n\\nThe setting is in the `ws-server` section of the manual settings. An example\\n`ws-server` is:\\n\\n```\\n'ws-server': {\\n  \\\"host\\\":  \\\"127.0.0.1\\\",\\n  \\\"port\\\":  \\\"8090\\\",\\n  \\\"proxyprefix\\\": \\\"wiki\\\"\\n}\\n```\\n\\nyou can add the leading `/` or not, so you could use `/wiki` or `wiki`.\\n\\n!! Setting up Caddy\\n\\nAn example caddy file that removes the `wiki` part of the url, which means that\\nthe `proxyprefix` needs to be set.\\n\\n```\\nphone.local:8080 {\\n  tls /data/data/com.termux/files/home/etc/phone.crt /data/data/com.termux/files/home/etc/phone.key\\n    proxy /wiki 127.0.0.1:8090 {\\n    without /wiki\\n  }\\n}\\n```\\n\\nAnother example of a caddy file that explicitly forwards websockets and does not use TLS is:\\n\\n```\\nexample.com:8081 {\\n  tls off\\n  proxy /wiki example.com:8080 {\\n  websocket\\n  without /wiki\\n}\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-ack\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-ack\",\n            \"tags\": \"[[Websocket Message]]\",\n            \"caption\": \"ack\",\n            \"description\": \"A message for the backend, not human usable.\",\n            \"text\": \"A message for the backend, not human usable.\\n\\nIt is used to acknowledge a websocket message from the server or browser.\\n\\nIf you use this in normal wikitext than it will probably break things and I will not offer any help fixing it.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-browserTiddlerList\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-browserTiddlerList\",\n            \"tags\": \"[[Websocket Message]]\",\n            \"caption\": \"browserTiddlerList\",\n            \"description\": \"A message for the backend, not human usable.\",\n            \"text\": \"This message isn't used by the backend to help keep the browser and server in\\nsync.\\n\\nThis message is sent with a list of all tiddlers currently in the wiki open in\\nthe browser.\\n\\n!!Usage\\n\\nThis message is used by the back-end, sending this message manually will break\\nthe synchronisation between your browser and the server so don't do it.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-buildHTMLWiki\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-buildHTMLWiki\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"buildHTMLWiki\",\n            \"description\": \"A message used to build the single file version of a wiki\",\n            \"text\": \"This message is used to create a single html file version of the wiki.\\n\\n!!Usage\\n\\nNote: all parameters for this are optional.\\n\\n|!Name |!Description |\\n|!buildWiki |The name of the wiki to build. Defaults to the current wiki if no value is given. |\\n|!outputFolder |The folder to store the output html file in. Can be absolute or relative to the wiki folder. (Default: `output`) |\\n|!outputName |The to give the output html file. (Default: `index.html`) |\\n|!excludeList |A filter that returns a list of tiddlers that should not be included in the output html file. (No Default) |\\n|!ignoreDefaultExclude |If this is set to `true` than the default exclude list is ignored (Default: 'false') |\\n|!externalTiddlers |A JSON object where each key is a wiki name and the value is a filter used to select tiddlers from that wiki to include is the output. (No Default) |\\n|!transfromFilters |A JSON object where each key is a wiki name and the value is a filter used to transform the names of tiddlers imported from that wiki. (No Default) |\\n|!transformFilter |A filter that is used to transform all tiddler titles pulled in from external wikis using the externalTiddlers parameter. (No Default) |\\n\\nExample: Build the current wiki in the default location\\n\\n```\\n<$action-websocketmessage $type='buildHTMLWiki'/>\\n```\\n\\nExample: Build the current wiki with extra tiddlers from two other wikis\\n\\n```\\n<$action-websocketmessage $type='buildHTMLWiki' externalTiddlers=\\\"\\\"\\\"{\\\"WikiOne\\\":\\\"[!is[system]]\\\", \\\"WikiTwo\\\":\\\"[tag[import]]\\\"}\\\"\\\"\\\"/>\\n```\\n\\nNote: The exclude list has two parts, there is the default exclude list that\\nremoves the parts that are not useful for single file wikis like the Bob plugin\\nand the filter given by the `excludeList` parameter, if any.\\nThese two lists are combined and nothing on the combined list is included in\\nthe output html file.\\nIf you want more control you can ignore the default exclude list by setting\\n`ignoreDefaultExclude=true` in the widget.\\nIf you do decide to ignore the defaults be careful, the included tiddlers have\\nno purpose in a single file wiki and may cause errors.\\n\\nThe defualt exclude filter is\\n\\n```\\n[prefix[$:/plugins/OokTech/Bob/]][[$:/plugins/OokTech/Bob]][prefix[$:/WikiSettings]][prefix[$:/Bob/]][[$:/ServerIP]][[$:/plugins/tiddlywiki/filesystem]][[$:/plugins/tiddlywiki/tiddlyweb]]\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-cancelEditingTiddler\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-cancelEditingTiddler\",\n            \"tags\": \"[[Websocket Message]]\",\n            \"caption\": \"cancelEditingTiddler\",\n            \"description\": \"A message for the backend, not human usable.\",\n            \"text\": \"This message is used to keep all connected browsers in sync and is only used by\\nthe back end to keep track of if a tiddler is being edited or not.\\n\\n!!Usage\\n\\nThis message isn't meant to be manually used. Sending this message manually will break things.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-clearStatus\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-clearStatus\",\n            \"tags\": \"[[Websocket Message]]\",\n            \"caption\": \"clearStatus\",\n            \"description\": \"A message for the backend, not human usable.\",\n            \"text\": \"A message for the backend, not human usable.\\n\\nIf you use this in normal wikitext than it will probably break things and I will not offer any help fixing it.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-createNewWiki\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-createNewWiki\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"createNewWiki\",\n            \"description\": \"A message used to make new wikis\",\n            \"text\": \"This message is used to create a new wiki using an edition.\\n\\n''BobEXE note:'' `BobEXE` uses a slightly different structure than the plugin\\nversion does by default. For `BobEXE` the IndexWiki folder is made in the same\\nfolder as the executable, and by default all other wikis are placed in a `Wikis`\\nsubfolder.\\n\\n''Location note:'' By default new wikis are created in the same folder as the\\nroot wiki. So if you have a folder `Wikis` and your root wiki in a subfolder\\n`RootWiki` than new wikis created using this will also be in the `Wikis`\\nfolder.\\n\\nExample folder structure:\\n\\n```\\nWikis\\n |\\n |-RootWiki\\n |\\n |-NewWiki\\n```\\n\\n!!Usage\\n\\n|!Name |!Description |\\n|!edition |The edition to use to make the new wiki. If it is left out 'empty' is used. |\\n|!wikiName |The name to give the new wiki. This is used to make the URL path to the new wiki and to set its location in the wikis folder. |\\n|!basePath |OPTIONAL Use this if you want the wiki created somewhere other than the default location (see location note above) |\\n|!wikisFolder |OPTIONAL Use this if you want the wikis folder to have a different name for this wiki. This is relative to `basePath` above.|\\n\\n```\\n<$action-websocketmessage $type='createNewWiki' path='wikiFolderPath' edition='editionName' wikiName='newWikiName' basePath='basePath'/>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-deleteTiddler\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-deleteTiddler\",\n            \"tags\": \"[[Websocket Message]]\",\n            \"caption\": \"deleteTiddler\",\n            \"description\": \"A message for the backend, not human usable.\",\n            \"text\": \"A message for the backend, not human usable.\\n\\nIf you use this in normal wikitext than it will probably break things and I will not offer any help fixing it.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-renameWiki\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-renameWiki\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"renameWiki\",\n            \"description\": \"Renames a wiki\",\n            \"text\": \"This renames an existing wiki. This is equivalent to moving a wiki.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-downloadHTMLFile\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-downloadHTMLFile\",\n            \"tags\": \"[[Websocket Message]][[Human Usable]]\",\n            \"caption\": \"downloadHTMLFile\",\n            \"description\": \"Download an html version of a wiki. (Depreciated)\",\n            \"text\": \"''Note:'' This isn't very useful anymore, the `$action-downloadwiki` widget\\ndoes a similar thing and works better.\\n\\nThis wiki creates and prompts you to download a single file html version of a\\nwiki to your device. It has all of the node-specific plugins (Bob, for example)\\nstripped out of it because they don't have any function in a single file wiki.\\n\\n!!Usage\\n\\n|!Parameter |!Description |\\n|!forWiki | The name of the wiki you want to download the html file for. (Default: the current wiki) |\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-duplicateWiki\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-duplicateWiki\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"duplicateWiki\",\n            \"description\": \"A message that creates a duplicate of an existing wiki.\",\n            \"text\": \"This message is used to create a duplicate of an existing wiki.\\n\\n|!Parameter |!Description |\\n|!fromWiki |The wiki to duplicate. |\\n|!newWiki |The name of the new wiki. |\\n|!copyChildren |If this is set to `true` child wikis will be copied as well. (Default: false) |\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-editingTiddler\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-editingTiddler\",\n            \"tags\": \"[[Websocket Message]]\",\n            \"caption\": \"editingTiddler\",\n            \"description\": \"A message for the backend, not human usable.\",\n            \"text\": \"A message for the backend, not human usable.\\n\\nIf you use this in normal wikitext than it will probably break things and I\\nwill not offer any help fixing it.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-getViewableWikiList\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-getViewableWikiList\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"getViewableWikiList\",\n            \"description\": \"Get a list of all viewable wikis\",\n            \"text\": \"This sends back a list of all wikis that are viewable using the current access\\ntoken.\\n\\nIf no access controls are present this returns a list of all available wikis.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-getThemeList\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-getThemeList\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"getThemeList\",\n            \"description\": \"Get a list of all available themes from the server\",\n            \"text\": \"This updates the list of all themes that are available on the server. It is\\nhere to be used with the tools for changing which plugins from the local\\nlibrary.\\n\\nThe list of plugins is saved in the list field of the tiddler\\n`$:/Bob/AvailableThemeList` and they are in the form `Author/ThemeName`, like\\n`tiddlywiki/snowwhite`.\\n\\n!!Inputs\\n\\nNone\\n\\n!!Usage\\n\\n`<$action-websocketmessage $type='getThemeList'/>`\\n\\n\\nA button that will update the list of available themes\\n\\n```\\n<$button>\\n  Update Plugin List\\n  <$action-websocketmessage\\n    $type='getThemeList'\\n  />\\n</$button>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-getPluginList\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-getPluginList\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"getPluginList\",\n            \"description\": \"Get a list of all available plugins from the server\",\n            \"text\": \"This updates the list of all plugins that are available on the server. It is\\nhere to be used with the tools for changing which plugins from the local\\nlibrary.\\n\\nThe list of plugins is saved in the list field of the tiddler\\n`$:/Bob/AvailablePluginList` and they are in the form `Author/PluginName`, like\\n`tiddlywiki/katex`.\\n\\n!!Inputs\\n\\nNone\\n\\n!!Usage\\n\\n`<$action-websocketmessage $type='getPluginList'/>`\\n\\n\\nA button that will update the list of available plugins\\n\\n```\\n<$button>\\n  Update Plugin List\\n  <$action-websocketmessage\\n    $type='getPluginList'\\n  />\\n</$button>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-internalFetch\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-internalFetch\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"internalFetch\",\n            \"description\": \"Fetch tiddlers from another wiki on the same Bob server\",\n            \"text\": \"This message imports tiddlers from another wiki being served by the same Bob\\nserver into the current wiki. It can optionally apply a filter to modify the\\ntitles of imported tiddlers.\\n\\n''Note:'' This makes new copies of the tiddler. Changes to the imported\\ntiddlers don't affect the original wiki and changes in the original wiki don't\\naffect the imported tiddlers.\\n\\n!!Inputs\\n\\n|!Parameter |!Description |\\n|!fromWiki |The name of the wiki to shut down. (No default) |\\n|!filter |The tiddlers returned by this filter are imported. (No default) |\\n|!transformFilter |Imported tiddlers have their titles transformed by this filter (No defalut) |\\n|!resolution |The method used to handle conflicts (default: `manual`) |\\n\\nIf nothing is given for the `fromWiki` or `filter` attributes than this message\\ndoes nothing. To determine the wikiName for a wiki look in the $:/WikiName\\ntiddler.\\n\\nThere are there options for `resolution`\\n\\n* `manual` each tiddler is saved to a temporary tiddler for review and must be\\n  manually accepted or rejected.\\n* `conflict` tiddlers with local copies that have been modified more recently\\n  than the incoming version are saved in temporary tiddlers to be accepted or\\n  rejected.\\n* `force` all incoming tiddlers are saved regardless of any conflicts\\n\\n!!Usage\\n\\n`<$action-websocketmessage $type='internalFetch' fromWiki=wikiName filter='[prefix[$:/importMe/]]' transformFilter='[removeprefix[$:/importMe]]'/>`\\n\\n\\nA button that will import any tiddlers in the wiki called `AnotherWiki` that\\nhave the tag `IMPORT ME` and adds `From Another Wiki ` added to the imported\\ntiddler titles as a prefix.\\n\\n```\\n<$button>\\n  Import Some Tiddlers\\n  <$action-websocketmessage\\n    $type='internalFetch'\\n    fromWiki='AnotherWiki'\\n    filter='[tag[IMPORT ME]]'\\n    transformFilter='[addprefix[From Another Wiki: ]]'\\n  />\\n</$button>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-listFiles\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-listFiles\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"listFiles\",\n            \"description\": \"A message that gives a list of files in a folder\",\n            \"text\": \"This message is used to get a list of files available in a folder.\\nOnly files that that are available using the file server are listed.\\n\\nFolders that can have their files listed are:\\n\\n- The file set as the `filePathRoot`\\n- Child folders of the `filePathRoot`\\n- Any folder listed in the file server tab.\\n\\nOnly file types in the `mimeMap` are listed, you can filter the filetypes\\nfurther by giving a space separated list of file extensions as the `mediaTypes`\\nattribute.\\n\\nThe filelist will be put in a tiddler, by default it is called `$:/state/fileList/files/`\\n\\n!!Usage\\n\\nNote: if you set the tiddler property to an existing tiddler the existing\\ntiddler will be overwritten.\\n\\n|!Name |!Description |!Default |\\n|!folder |The url path to the folder you want listed. The `filePathRoot` is `files`, other locations are what is shown in the list in the file server tab. |`files` |\\n|!tiddler |The tiddler to store the list of files in. |`$:/state/fileList/<<folderName>>` |\\n|!field |The field to store the file list in. |`list` |\\n|!mediaTypes |(optional) a space separated list of file extensions to use to filter the returned files. |None |\\n\\nExample: Get the filelist for the folder listed as the `filePathRoot` and store the list in the `list` field of the tiddler `$:/state/fileList/./`.\\n\\n```\\n<$action-websocketmessage $type='listFiles' folder='files'/>\\n```\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-makeImagesExternal\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-makeImagesExternal\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"makeImagesExternal\",\n            \"description\": \"Make all images in the wiki external tiddlers using _canonical_uri\",\n            \"text\": \"This moves all images and other media from a wiki into an external folder and\\ncreates _canonical_uri tiddlers for each one.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-mediaScan\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-mediaScan\",\n            \"tags\": \"[[Websocket Message]]\",\n            \"caption\": \"mediaScan\",\n            \"description\": \"Scan a folder for media and create _canonical_uri tiddlers for each file found\",\n            \"text\": \"This message is used to scan a folder for media files and create a\\n_canonical_uri tiddler for each file found.\\n\\n''NOTE:'' Only folders that are children of the folder set as the\\n`filePathRoot` in the settings can be scanned.\\n\\n!!Usage\\n\\n|!Name |!Description |\\n|!folder |The folder to scan, either absolute or relative to the file path root. (No Default) |\\n|!ignoreExisting |If this is set to `yes` any tiddler with _canonical_uri that matches a file exists nothing further is done with that file (this takes precidence over overwrite) (Default `no`) |\\n|!overwrite |If this is set to `yes` than new tiddlers are made even if they overwrite existing tiddlers. (Default `no`) |\\n|!prune |If this is set to `yes` than any tiddlers that have _canonical_uri fields that point to a file that would be in the folder being scanned that doesn't exist the tiddler is removed. (Default `no`) |\\n|!mediaTypes |(Optional) A space separated list of file extensions to scan for. If no list is given all types listed in the mimeMap will be used. |\\n\\n```\\n<$action-websocketmessage $type='mediaScan' folder='/path/to/folder' ignoreExisting='true' overwrite='false' prune='true' mediaTypes='.jpg .png .jpeg'/>\\n```\\n\\nThe default mimeMap is:\\n\\n```\\n{\\n  '.aac': 'audio/aac',\\n  '.avi': 'video/x-msvideo',\\n  '.csv': 'text/csv',\\n  '.doc': 'application/msword',\\n  '.epub': 'application/epub+zip',\\n  '.gif': 'image/gif',\\n  '.html': 'text/html',\\n  '.htm': 'text/html',\\n  '.ico': 'image/x-icon',\\n  '.jpg': 'image/jpeg',\\n  '.jpeg': 'image/jpeg',\\n  '.mp3': 'audio/mpeg',\\n  '.mpeg': 'video/mpeg',\\n  '.oga': 'audio/ogg',\\n  '.ogv': 'video/ogg',\\n  '.ogx': 'application/ogg',\\n  '.pdf': 'application/pdf',\\n  '.png': 'image/png',\\n  '.svg': 'image/svg+xml',\\n  '.weba': 'audio/weba',\\n  '.webm': 'video/webm',\\n  '.wav': 'audio/wav'\\n}\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-newWikiFromTiddlers\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-newWikiFromTiddlers\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"newWikiFromTiddlers\",\n            \"description\": \"Create a new wiki using tiddlers from other wikis\",\n            \"text\": \"This message is used to create a wiki from existing tiddlers.\\n\\nThis message is human usable, but it is generally used as part of something\\nelse that generates the input.\\n\\n!!Inputs\\n\\n|!Parameter |!Description |\\n|!tiddlers |An array of tiddlers in json format to make into a wiki. |\\n|!wikiName |The name of the saved wiki. Default: `NewWiki`|\\n|!wikiFolder |The folder to store the created wiki in. Default: `Wikis` |\\n|!wikisPath |The folder where `wikiFolder` parameter above is located. Defaults to the current working directory. |\\n|!overwrite |If this is set to `true` and a `wikiName` is given and a wiki with that name already exists than the unpacked tiddlers will be added to that wiki instead of being used to make a new wiki. Default: `false` |\\n|!transfromFilters |A JSON object where each key is a wiki name and the value is a filter used to transform the names of tiddlers imported from that wiki. (No Default) |\\n|!transformFilter |A filter that is used to transform all tiddler titles pulled in from external wikis using the externalTiddlers parameter. (No Default) |\\n\\n* `tiddlers` is an array of json objects. Each element in the array lists the fields of one tiddler.\\n* You only need to set `wikiFolder` or `wikisPath` if you want your newly created wiki to be located somewhere other than where your existing wikis are.\\n\\n!!Usage\\n\\nThis is almost always used as part of something else, like the [[ActionConvertWiki widget|]].\\n\\n`<$action-websocketmessage $type='newWikiFromTiddlers' tiddlers=\\\"[{title: Hi, text: potato}, {title: bye, text: tomato}]\\\"/>`\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-openRemoteConnection\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-openRemoteConnection\",\n            \"tags\": \"[[Websocket Message]]\",\n            \"caption\": \"openRemoteConnection\",\n            \"description\": \"A message that tells the server to open a connection to a remote server.\",\n            \"text\": \"This message tells the server to try and open a connection to a remote server.\\n\\nThis is the first step to having federated communication between wikis.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-ping\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-ping\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"ping\",\n            \"description\": \"Send a ping to the server. Human usable but not very useful in most cases.\",\n            \"text\": \"This sends a ping to the server. It doesn't do anything else and unless you modify the node message handler part there isn't any visible effect.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-runScript\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-runScript\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"runScript\",\n            \"description\": \"Run a shell command defined in the settings.\",\n            \"text\": \"You can define a shell command in the `Bob Settings` tab of $:/ControlPanel.\\nThen you can use this message to run that command.\\n\\nIt is possible to make messages that have placeholder values that you can set\\nwhen you send the message. To do this you put an attribute that has the same\\nname as the placeholder in the script (or the actual argument in the script)\\nand the argument in the script will be replaced with the value given. See the\\nexample below for clarification. The placeholders here start with # to make\\nthem obvious but they can be anything you want to use.\\n\\nSee [[Running Scripts Using Websocket Messages|$:/plugins/OokTech/Bob/Running Scripts Using Websocket Messages]]\\n\\n|!Parameter |!Description |\\n|name |The name given to a script listed in the `Bob Settings` |\\n|sequential |Scripts with this set to true will run in order and only start after the previous script with sequential set finishes. See note below. (Default: `false`) |\\n|queue | ''OPTIONAL'' This only affects scripts that have sequential set to `true`, see note below. Default: `0`. |\\n|//{any parameter not starting with $}// |Any other parameters passed are assumed to be the names for placeholders. |\\n\\n''About the `sequential` and `queue` parameters:''\\nthese option only matter to scripts that have sequential set to true. Scripts\\nwith sequential set to true will not wait for scripts without it set to finish\\nbefore starting.\\n\\nYou can have multiple independent queues for scripts as well. Scripts a queue\\nwill only wait for the previous script in the same queue to finish before\\nstarting. If no queue is listed everything goes into the default queue called\\n`0`.\\n\\n! Usage\\n\\n''Note:'' This is just an example shell script. You can create new wikis much\\nmore easily using the built-in tool. See\\n[[creating new wikis|$:/plugins/OokTech/Bob/Creating New Wikis]] for\\nmore.\\n\\nAssuming that you have a script defined in the settings as:\\n\\n`\\\"NewWiki\\\": \\\"tiddlywiki #wikiName --init #editionName\\\"`\\n\\nand assuming that you have an edition called `Bob`.\\n\\n```\\n<$button>\\n  Make Wiki!\\n  <$action-websocketmessage $type='runScript' name='NewWiki' #wikiName='Wikis/SomeName' #editionName='Bob'/>\\n</$button>\\n```\\n\\nThis would then run the shell command `tiddlywiki Wikis/SomeName --init Bob`,\\nwhich creates a new wiki using the Bob edition in the folder Wikis/SomeName.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-savePluginFolder\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-savePluginFolder\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"savePluginFolder\",\n            \"description\": \"Split a plugin into individual .tid files and save it on the server\",\n            \"text\": \"This message imports tiddlers from another wiki being served by the same Bob\\nserver into the current wiki. It can optionally apply a filter to modify the\\ntitles of imported tiddlers.\\n\\nThe purpose of this is to add plugins to the list of plugins served by a Bob\\nserver.\\n\\n!!Inputs\\n\\n|!Parameter |!Description |\\n|!pluginName |The name of the plugin tiddler to save on the server |\\n\\n\\n!!Notes\\n\\nThe plugin tiddler must be named in the form `$:/plugins/Author/PluginName`.\\nThey will be stored in the folder listed in the settings under `pluginsPath`.\\nThe folder holding the .tid files will be `<<pluginsPath>>/Author/PluginName`.\\n\\nThis message checks to make sure that the plugin being saved isn't an older\\nversion of one that is already saved. If the version number matches than the\\nplugin is saved.\\n\\n!!Usage\\n\\n`<$action-websocketmessage $type='savePluginFolder' pluginName='$:/plugins/OokTech/Bob'/>`\\n\\n\\nA button that will import any tiddlers in the wiki called `AnotherWiki` that\\nhave the tag `IMPORT ME` and adds `From Another Wiki ` added to the imported\\ntiddler titles as a prefix.\\n\\n```\\n<$button>\\n  Import Some Tiddlers\\n  <$action-websocketmessage\\n    $type='savePluginFolder'\\n    pluginName='$:/plugins/OokTech/Bob'\\n  />\\n</$button>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-saveSettings\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-saveSettings\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"saveSettings\",\n            \"description\": \"Save changed made to the settings from within the wiki.\",\n            \"text\": \"''Note:'' you should very rarely have a reason to use this. The\\n`$action-savesettings` widget is a better choice unless you have a manually\\ncreated string you want to send as your full configuration file.\\n\\n''Note:'' this currently only works for the root wiki!! (that is the wiki at\\nthe root level served on `localhost:8080` if you are using the defaults).\\n\\nThis saves any changes to the Bob settings made in the wiki to the file system.\\n\\nYou shouldn't use this, use the button under the manual settings interface or\\nthe `$action-savesettings` widget instead.\\n\\n|!Parameter |!Description |\\n|!settingsString |A stringified JSON object that contains the full settings object. |\\n\\n!!Usage\\n\\n`<$action-websocketmessage $type='saveSettings' settingsString=<<SettingsString>>/>`\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-saveTiddler\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-saveTiddler\",\n            \"tags\": \"[[Websocket Message]]\",\n            \"caption\": \"saveTiddler\",\n            \"description\": \"A message for the backend, not human usable.\",\n            \"text\": \"A message for the backend, not human usable.\\n\\nIf you use this in normal wikitext than it will probably break things and I will not offer any help fixing it.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-shutdownServer\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-shutdownServer\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"shutdownServer\",\n            \"description\": \"Shutdown the wiki server.\",\n            \"text\": \"This message shuts down the node process and stops serving any wikis. This\\naffects all wikis, none will be available until you start the server again.\\n\\nNote that for some reason the http server may take a few minutes to finally\\nstop and until it stops the socket it was using will remain in use.\\n\\nUsage:\\n\\n`<$action-websocketmessage $type='shutdownServer'/>`\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-stopScripts\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-stopScripts\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"stopScripts\",\n            \"description\": \"Stop currently running shell scipt queue.\",\n            \"text\": \"This is to stop scripts started using the\\n[[runScript message|$:/plugins/OokTech/Bob/WebSocketMessage-runScript]] message\\nthat have the `sequential` attribute set to true.\\n\\nThe `queue` attribute is only useful if you started any scripts with the queue\\nset. If you set the queue attribute here it wil stop any scripts started that\\nare in the same queue.\\n\\n|!Parameter |!Description |\\n|queue | ''OPTIONAL'' This only affects scripts that have sequential set to `true`, see note below. Default: `0`. |\\n\\n```\\n<$button>\\n  Halt Scripts\\n  <$action-websocketmessage $type='stopScripts'/>\\n</$button>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-syncChanges\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-syncChanges\",\n            \"tags\": \"[[Websocket Message]]\",\n            \"caption\": \"syncChanges\",\n            \"description\": \"Resync with a server after reconnecting\",\n            \"text\": \"If your browser is disconnected from a wiki server this is the message used to\\nsync any updates made either in the browser or on the server.\\n\\nWhile this is usable it should only be used indirectly through the `Reconnect`\\nbutton that appears when the browser has been disconnected from the server.\\n\\n!!Inputs\\n\\n|!Parameter |!Description |\\n|!since |The time that the browser detected that it was disconnected. Changes after this time will be synced. (No default) |\\n|!changes |A messageQueue object that contains the changes in the browser. (No default) |\\n|!wiki |The wiki that is trying to reconnect (No defalut) |\\n\\n!!Usage\\n\\nThis is all handled automatically.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-test\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-test\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"test\",\n            \"description\": \"A message for debugging. Human usable but not particularly useful outside of development.\",\n            \"text\": \"This message is for testing and doesn't have much practical use outside of\\ndebugging.\\n\\nThis message takes any input parameters and puts them into a json object and sends that as the message.\\n\\nOn the node side the received data is printed to the terminal.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-unloadWiki\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-unloadWiki\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"unloadWiki\",\n            \"description\": \"Unload a wiki from memory.\",\n            \"text\": \"This message removes the given wiki from the node process. It effecively shuts\\ndown the wiki. If you go to the wiki url again it will reload the wiki like\\nnormal.\\n\\nThis allows you to edit the tiddlywiki.info file for a wiki (to change the\\navailable plugins or themes, etc.) and have the changes take effect without\\nrestarting the full server.\\n\\n!!Inputs\\n\\n|!Parameter |!Description |\\n|!wikiName |The name of the wiki to shut down. (No default) |\\n\\nIf no wikiName is given than this message does nothing. To determine the\\nwikiName for a wiki look in the $:/WikiName tiddler.\\n\\n!!Usage\\n\\n`<$action-websocketmessage $type='unloadWiki' wikiName=wikiName/>`\\n\\n\\nA button that will unload the current wiki from memory:\\n\\n```\\n<$button>\\n  Unload Wiki\\n  <$action-websocketmessage\\n    $type='unloadWiki'\\n    wikiName={{$:/WikiName}}\\n  />\\n</$button>\\n```\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-updateFederatedConnectionInfo\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-updateFederatedConnectionInfo\",\n            \"tags\": \"[[Websocket Message]][[Human Usable]]\",\n            \"caption\": \"updateFederatedConnectionInfo\",\n            \"description\": \"Update the saved information for a federated server\",\n            \"text\": \"While this is human usable, it is probably always better to use the wiki ui to\\ndo everything instead of manually using this.\\n\\nThis message takes the information tiddler for a federated connection and sends\\nit to the server where it is used to update the saved information on the server.\\n\\n!!Usage\\n\\n|!Parameter |!Description |\\n|!$tiddler |The title of the tiddler that holds the connection information. |\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-updateRoutes\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-updateRoutes\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"updateRoutes\",\n            \"description\": \"Add new wikis to server or update the URL of wikis currently being served.\",\n            \"text\": \"This message lets you start serving a new wiki from within tiddlywiki. The\\nlocation of the named wiki must be listed in the `wikis` section of the\\n`Bob Settings` tab in the $:/ControlPanel.\\n\\nNote this is for wikis that already exist. If you wish to create a new wiki\\nsee the example for the\\n[[runScript message|$:/plugins/OokTech/Bob/WebSocketMessage-runScript]]\\n\\n!!! Example wikis settings\\n\\nYou can have the wikis grouped in the wikis listing like this:\\n\\n```\\n{\\n  wikis: {\\n    wikiHere: /path/to/wikiHere,\\n    group1: {\\n      someWiki: /path/to/someWiki\\n    },\\n    group2: {\\n      otherWiki: /path/to/otherOne,\\n      wiki2: /path/to/wiki2\\n    }\\n  }\\n}\\n```\\n\\nAssuming default settings, this means that 5 wikis will be served, the root\\nwiki and the 4 child wikis listed. The urls would be:\\n\\n* For wikiHere the url is `localhost:8080/wikiHere`\\n* For someWiki the url is `localhost:8080/group1/someWiki`\\n* For otherWiki the url is `localhost:8080/group2/otherWiki`\\n* For wiki2 the url is `localhost:8080/group2/wiki2`\\n\\n\\n!!Usage\\n\\n`<$action-websocketmessage $type='updateRoutes'/>`\\n\\n''NOTE:'' This message only works from the root wiki. That is the wiki served\\non `localhost:8080` by default (the wiki that opens up when you start the\\napplication if you are using the single executable version). It is ignored if\\nit comes from any child wiki.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-updateTiddlyWikiInfo\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessage-updateTiddlyWikiInfo\",\n            \"tags\": \"[[Websocket Message]] [[Human Usable]]\",\n            \"caption\": \"updateTiddlyWikiInfo\",\n            \"description\": \"Update the description, plugins, languages and themes in tiddlywiki.info\",\n            \"text\": \"This message can be used to modify the `tiddlywiki.info` file for the current\\nwiki.\\nYou can change the list of plugins, themes or languages as well as the\\ndescription.\\n\\nYou can change one or more of the parts at the same time.\\n\\nIf you give a parameter with an empty string (like this `\\\"\\\"`) than it will\\nclear the list of plugins/themes/languages.\\n\\n!!Usage\\n\\nNote: all parameters for this are optional.\\n\\n|!Name |!Description |\\n|!description |A text description to replace the current one. (optional) |\\n|!pluginList |A list of plugin names to replace the current list of plugins in the form \\\"OokTech/Bob tiddlywiki/katext\\\" (optional) |\\n|!themeList |A list of themes to include in the wiki in the same form as the plugins. (optional) |\\n|!languageList |A list of languages to include in the wiki in the same form as the plugins (optional) |\\n\\n\\nExample: Build the current wiki in the default location\\n\\n```\\n<$action-websocketmessage $type='buildHTMLWiki'/>\\n```\\n\\nNote: If you make your own exclude list it is a good idea to include the\\ntiddlers in the default. They have no purpose in a single file wiki and may\\ncause errors.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessages\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WebSocketMessages\",\n            \"caption\": \"WebSocketMessages\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"the different human usable websocket messages avaliable.\",\n            \"text\": \"You use websocket messages with the [[ActionWebSocketMessage|$:/plugins/OokTech/Bob/ActionWebSocketMessage]] widget.\\n\\nThese are the human usable messages currently available for websockets:\\n\\n<$list\\n  filter='[all[tiddlers+shadows]tag[Websocket Message]tag[Human Usable]]'\\n>\\n  <$link\\n    to=<<currentTiddler>>\\n  >\\n    <$view\\n      field='caption'\\n    />\\n  </$link>\\n  -\\n  <$view\\n    field='description'\\n  />\\n  <br>\\n</$list>\\n\\nFor developers there are also [[messaged used by the back-end|$:/plugins/OokTech/Bob/BackendWebSocketMessages]].\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/Wiki Paths\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/Wiki Paths\",\n            \"caption\": \"Wiki paths\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Information about the relationship between file system paths, urls, and wiki names.\",\n            \"text\": \"First some definitions:\\n\\n- `file system paths` can be thought of as addresses for where files live on your computer. File system paths generally look something like: `C:\\\\Users\\\\me\\\\documents` (on windows) or `/home/me/documents` on OSX or linux.\\n- `urls` refer to locations or files that are made available by a web server. The internet uses urls because everything that you access on the internet is sent to you by a server somewhere.\\n- `wiki names` refer to the names used to distinguish between wikis in Bob. The url of wikis served by Bob generally ends with the wiki name.\\n\\nOne very important thing to understand that the url you type in to access a\\nwiki while using Bob is not the same as a file system path. By default Bob uses\\na structure that mostly mirrors the way that wikis are laid out on the file\\nsystem, but that doesn't mean that the urls and the file system structure are\\nthe same thing. This is a very important distinction when it comes to serving\\nfiles that can be used in Bob wikis.\\n\\nAs of Bob version 1.2.2 wiki urls can be part of the path to another wiki. That\\nis you an have a wiki available on `localhost:8080/MyWiki` and another wiki on\\n`localhost:8080/MyWiki/MyOtherWiki`. This is new in version 1.2.2 and will not\\nwork in any older versions.\\n\\n!! Setting wiki paths\\n\\nThe easiest way to add wikis is using the tools in the $:/ControlPanel, so\\nunless you want to do something that you can't do using them this next part\\nisn't necessary.\\n\\nYou can set the wiki url by where you place it in the wikis property of the settings, wiki names need to be unique only within the same group, so you can have `localhost:8080/foo/baz` and `localhost:8080/bar/baz` without trouble.\\n\\nThe way that the file system paths of wikis are listed in the settings changed in version 1.2.2. Previously it was `wikiName: wikiPath`, you can still list them that way but they will automatically get updated to the form `wikiName: {'__path': wikiPath}`, this is necessary in order to allow wikis on nested urls.\\n\\n**I need to write this part at some point**\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/WikiSyncing\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/WikiSyncing\",\n            \"caption\": \"Wiki Syncing\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"description\": \"Sync wikis between different Bob servers\",\n            \"text\": \"TODO write this\"\n        },\n        \"$:/plugins/OokTech/Bob/Documentation/A note about ports\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Documentation/A note about ports\",\n            \"caption\": \"A note about ports\",\n            \"tags\": \"[[Bob Documentation]]\",\n            \"text\": \"As long as the key `ws-server.autoIncrementPort` is not set to false, the\\n`wsserver` command ensures that there aren't port conflicts when starting up.\\nA result of this is that if you say to use a port that is taken than it will\\nincrement the port number until an available port is found. Because of this the\\nwiki may not be on the same port that you expect, so look at the commandline\\noutput to see which port it is being served on.\\n\\nIf `ws-server.autoIncrementPort` is set to false than the server will try using\\nthe port given (`8080` by default) and the process will fail and exit if the\\nport is in use.\\n\\nBoth the websocket interface and the http(s) interface use the same port.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/ExcludeSync\": {\n            \"title\": \"$:/plugins/OokTech/Bob/ExcludeSync\",\n            \"text\": \"[has[draft.of]]\\n[prefix[$:/state/]]\\n[prefix[$:/temp/]]\\n[[$:/StoryList]]\\n[[$:/HistoryList]]\\n[[$:/status/UserName]]\\n[[$:/Import]]\\n[[$:/plugins/OokTech/Bob/Server Warning]]\\n[[$:/plugins/OokTech/Bob/Unsent]]\\n[[$:/Bob/VisibleConfigurationTabs]]\\n[[$:/Bob/ActiveLanguagesList]]\\n[[$:/Bob/ActiveThemesList]]\\n[[$:/Bob/ActivePluginList]]\\n[[$:/Bob/AlertHistory]]\\n[[$:/ServerIP]]\\n[[$:/Bob/AvailableEditionList]]\\n[[$:/Bob/AvailableThemeList]]\\n[[$:/Bob/AvailablePluginList]]\\n[[$:/Bob/AvailableLanguageList]]\\n[[$:/state/ViewableWikis]]\\n[[$:/status/UserName]]\\n[[$:/boot/boot.css]]\\n[[$:/boot/boot.js]]\\n[[$:/boot/bootprefix.js]]\\n[[$:/core]]\\n[[$:/library/sjcl.js]]\\n[prefix[$:/WikiSettings]]\\n[[$:/ProxyPrefix]]\\n[[$:/WikiName]]\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/External/IP/ip.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\nvar ip = exports;\\nvar Buffer = require('buffer').Buffer;\\nvar os = require('os');\\n\\nip.toBuffer = function(ip, buff, offset) {\\n  offset = ~~offset;\\n\\n  var result;\\n\\n  if (this.isV4Format(ip)) {\\n    result = buff || new Buffer(offset + 4);\\n    ip.split(/\\\\./g).map(function(byte) {\\n      result[offset++] = parseInt(byte, 10) & 0xff;\\n    });\\n  } else if (this.isV6Format(ip)) {\\n    var sections = ip.split(':', 8);\\n\\n    var i;\\n    for (i = 0; i < sections.length; i++) {\\n      var isv4 = this.isV4Format(sections[i]);\\n      var v4Buffer;\\n\\n      if (isv4) {\\n        v4Buffer = this.toBuffer(sections[i]);\\n        sections[i] = v4Buffer.slice(0, 2).toString('hex');\\n      }\\n\\n      if (v4Buffer && ++i < 8) {\\n        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));\\n      }\\n    }\\n\\n    if (sections[0] === '') {\\n      while (sections.length < 8) sections.unshift('0');\\n    } else if (sections[sections.length - 1] === '') {\\n      while (sections.length < 8) sections.push('0');\\n    } else if (sections.length < 8) {\\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\\n      var argv = [ i, 1 ];\\n      for (i = 9 - sections.length; i > 0; i--) {\\n        argv.push('0');\\n      }\\n      sections.splice.apply(sections, argv);\\n    }\\n\\n    result = buff || new Buffer(offset + 16);\\n    for (i = 0; i < sections.length; i++) {\\n      var word = parseInt(sections[i], 16);\\n      result[offset++] = (word >> 8) & 0xff;\\n      result[offset++] = word & 0xff;\\n    }\\n  }\\n\\n  if (!result) {\\n    throw Error('Invalid ip address: ' + ip);\\n  }\\n\\n  return result;\\n};\\n\\nip.toString = function(buff, offset, length) {\\n  offset = ~~offset;\\n  length = length || (buff.length - offset);\\n\\n  var result = [];\\n  if (length === 4) {\\n    // IPv4\\n    for (var i = 0; i < length; i++) {\\n      result.push(buff[offset + i]);\\n    }\\n    result = result.join('.');\\n  } else if (length === 16) {\\n    // IPv6\\n    for (var i = 0; i < length; i += 2) {\\n      result.push(buff.readUInt16BE(offset + i).toString(16));\\n    }\\n    result = result.join(':');\\n    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');\\n    result = result.replace(/:{3,4}/, '::');\\n  }\\n\\n  return result;\\n};\\n\\nvar ipv4Regex = /^(\\\\d{1,3}\\\\.){3,3}\\\\d{1,3}$/;\\nvar ipv6Regex =\\n    /^(::)?(((\\\\d{1,3}\\\\.){3}(\\\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\\n\\nip.isV4Format = function(ip) {\\n  return ipv4Regex.test(ip);\\n};\\n\\nip.isV6Format = function(ip) {\\n  return ipv6Regex.test(ip);\\n};\\nfunction _normalizeFamily(family) {\\n  return family ? family.toLowerCase() : 'ipv4';\\n}\\n\\nip.fromPrefixLen = function(prefixlen, family) {\\n  if (prefixlen > 32) {\\n    family = 'ipv6';\\n  } else {\\n    family = _normalizeFamily(family);\\n  }\\n\\n  var len = 4;\\n  if (family === 'ipv6') {\\n    len = 16;\\n  }\\n  var buff = new Buffer(len);\\n\\n  for (var i = 0, n = buff.length; i < n; ++i) {\\n    var bits = 8;\\n    if (prefixlen < 8) {\\n      bits = prefixlen;\\n    }\\n    prefixlen -= bits;\\n\\n    buff[i] = ~(0xff >> bits) & 0xff;\\n  }\\n\\n  return ip.toString(buff);\\n};\\n\\nip.mask = function(addr, mask) {\\n  addr = ip.toBuffer(addr);\\n  mask = ip.toBuffer(mask);\\n\\n  var result = new Buffer(Math.max(addr.length, mask.length));\\n\\n  var i = 0;\\n  // Same protocol - do bitwise and\\n  if (addr.length === mask.length) {\\n    for (i = 0; i < addr.length; i++) {\\n      result[i] = addr[i] & mask[i];\\n    }\\n  } else if (mask.length === 4) {\\n    // IPv6 address and IPv4 mask\\n    // (Mask low bits)\\n    for (i = 0; i < mask.length; i++) {\\n      result[i] = addr[addr.length - 4  + i] & mask[i];\\n    }\\n  } else {\\n    // IPv6 mask and IPv4 addr\\n    for (var i = 0; i < result.length - 6; i++) {\\n      result[i] = 0;\\n    }\\n\\n    // ::ffff:ipv4\\n    result[10] = 0xff;\\n    result[11] = 0xff;\\n    for (i = 0; i < addr.length; i++) {\\n      result[i + 12] = addr[i] & mask[i + 12];\\n    }\\n    i = i + 12;\\n  }\\n  for (; i < result.length; i++)\\n    result[i] = 0;\\n\\n  return ip.toString(result);\\n};\\n\\nip.cidr = function(cidrString) {\\n  var cidrParts = cidrString.split('/');\\n\\n  var addr = cidrParts[0];\\n  if (cidrParts.length !== 2)\\n    throw new Error('invalid CIDR subnet: ' + addr);\\n\\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\\n\\n  return ip.mask(addr, mask);\\n};\\n\\nip.subnet = function(addr, mask) {\\n  var networkAddress = ip.toLong(ip.mask(addr, mask));\\n\\n  // Calculate the mask's length.\\n  var maskBuffer = ip.toBuffer(mask);\\n  var maskLength = 0;\\n\\n  for (var i = 0; i < maskBuffer.length; i++) {\\n    if (maskBuffer[i] === 0xff) {\\n      maskLength += 8;\\n    } else {\\n      var octet = maskBuffer[i] & 0xff;\\n      while (octet) {\\n        octet = (octet << 1) & 0xff;\\n        maskLength++;\\n      }\\n    }\\n  }\\n\\n  var numberOfAddresses = Math.pow(2, 32 - maskLength);\\n\\n  return {\\n    networkAddress: ip.fromLong(networkAddress),\\n    firstAddress: numberOfAddresses <= 2 ?\\n                    ip.fromLong(networkAddress) :\\n                    ip.fromLong(networkAddress + 1),\\n    lastAddress: numberOfAddresses <= 2 ?\\n                    ip.fromLong(networkAddress + numberOfAddresses - 1) :\\n                    ip.fromLong(networkAddress + numberOfAddresses - 2),\\n    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),\\n    subnetMask: mask,\\n    subnetMaskLength: maskLength,\\n    numHosts: numberOfAddresses <= 2 ?\\n                numberOfAddresses : numberOfAddresses - 2,\\n    length: numberOfAddresses,\\n    contains: function(other) {\\n      return networkAddress === ip.toLong(ip.mask(other, mask));\\n    }\\n  };\\n};\\n\\nip.cidrSubnet = function(cidrString) {\\n  var cidrParts = cidrString.split('/');\\n\\n  var addr = cidrParts[0];\\n  if (cidrParts.length !== 2)\\n    throw new Error('invalid CIDR subnet: ' + addr);\\n\\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\\n\\n  return ip.subnet(addr, mask);\\n};\\n\\nip.not = function(addr) {\\n  var buff = ip.toBuffer(addr);\\n  for (var i = 0; i < buff.length; i++) {\\n    buff[i] = 0xff ^ buff[i];\\n  }\\n  return ip.toString(buff);\\n};\\n\\nip.or = function(a, b) {\\n  a = ip.toBuffer(a);\\n  b = ip.toBuffer(b);\\n\\n  // same protocol\\n  if (a.length === b.length) {\\n    for (var i = 0; i < a.length; ++i) {\\n      a[i] |= b[i];\\n    }\\n    return ip.toString(a);\\n\\n  // mixed protocols\\n  } else {\\n    var buff = a;\\n    var other = b;\\n    if (b.length > a.length) {\\n      buff = b;\\n      other = a;\\n    }\\n\\n    var offset = buff.length - other.length;\\n    for (var i = offset; i < buff.length; ++i) {\\n      buff[i] |= other[i - offset];\\n    }\\n\\n    return ip.toString(buff);\\n  }\\n};\\n\\nip.isEqual = function(a, b) {\\n  a = ip.toBuffer(a);\\n  b = ip.toBuffer(b);\\n\\n  // Same protocol\\n  if (a.length === b.length) {\\n    for (var i = 0; i < a.length; i++) {\\n      if (a[i] !== b[i]) return false;\\n    }\\n    return true;\\n  }\\n\\n  // Swap\\n  if (b.length === 4) {\\n    var t = b;\\n    b = a;\\n    a = t;\\n  }\\n\\n  // a - IPv4, b - IPv6\\n  for (var i = 0; i < 10; i++) {\\n    if (b[i] !== 0) return false;\\n  }\\n\\n  var word = b.readUInt16BE(10);\\n  if (word !== 0 && word !== 0xffff) return false;\\n\\n  for (var i = 0; i < 4; i++) {\\n    if (a[i] !== b[i + 12]) return false;\\n  }\\n\\n  return true;\\n};\\n\\nip.isPrivate = function(addr) {\\n  return /^(::f{4}:)?10\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})$/i\\n      .test(addr) ||\\n    /^(::f{4}:)?192\\\\.168\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})$/i.test(addr) ||\\n    /^(::f{4}:)?172\\\\.(1[6-9]|2\\\\d|30|31)\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})$/i\\n      .test(addr) ||\\n    /^(::f{4}:)?127\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})$/i.test(addr) ||\\n    /^(::f{4}:)?169\\\\.254\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})$/i.test(addr) ||\\n    /^f[cd][0-9a-f]{2}:/i.test(addr) ||\\n    /^fe80:/i.test(addr) ||\\n    /^::1$/.test(addr) ||\\n    /^::$/.test(addr);\\n};\\n\\nip.isPublic = function(addr) {\\n  return !ip.isPrivate(addr);\\n};\\n\\nip.isLoopback = function(addr) {\\n  return /^(::f{4}:)?127\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})/\\n      .test(addr) ||\\n    /^fe80::1$/.test(addr) ||\\n    /^::1$/.test(addr) ||\\n    /^::$/.test(addr);\\n};\\n\\nip.loopback = function(family) {\\n  //\\n  // Default to `ipv4`\\n  //\\n  family = _normalizeFamily(family);\\n\\n  if (family !== 'ipv4' && family !== 'ipv6') {\\n    throw new Error('family must be ipv4 or ipv6');\\n  }\\n\\n  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';\\n};\\n\\n//\\n// ### function address (name, family)\\n// #### @name {string|'public'|'private'} **Optional** Name or security\\n//      of the network interface.\\n// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults\\n//      to ipv4).\\n//\\n// Returns the address for the network interface on the current system with\\n// the specified `name`:\\n//   * String: First `family` address of the interface.\\n//             If not found see `undefined`.\\n//   * 'public': the first public ip address of family.\\n//   * 'private': the first private ip address of family.\\n//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.\\n//\\nip.address = function(name, family) {\\n  var interfaces = os.networkInterfaces();\\n  var all;\\n\\n  //\\n  // Default to `ipv4`\\n  //\\n  family = _normalizeFamily(family);\\n\\n  //\\n  // If a specific network interface has been named,\\n  // return the address.\\n  //\\n  if (name && name !== 'private' && name !== 'public') {\\n    var res = interfaces[name].filter(function(details) {\\n      var itemFamily = details.family.toLowerCase();\\n      return itemFamily === family;\\n    });\\n    if (res.length === 0)\\n      return undefined;\\n    return res[0].address;\\n  }\\n\\n  var all = Object.keys(interfaces).map(function (nic) {\\n    //\\n    // Note: name will only be `public` or `private`\\n    // when this is called.\\n    //\\n    var addresses = interfaces[nic].filter(function (details) {\\n      details.family = details.family.toLowerCase();\\n      if (details.family !== family || ip.isLoopback(details.address)) {\\n        return false;\\n      } else if (!name) {\\n        return true;\\n      }\\n\\n      return name === 'public' ? ip.isPrivate(details.address) :\\n          ip.isPublic(details.address);\\n    });\\n\\n    return addresses.length ? addresses[0].address : undefined;\\n  }).filter(Boolean);\\n\\n  return !all.length ? ip.loopback(family) : all[0];\\n};\\n\\nip.toLong = function(ip) {\\n  var ipl = 0;\\n  ip.split('.').forEach(function(octet) {\\n    ipl <<= 8;\\n    ipl += parseInt(octet);\\n  });\\n  return(ipl >>> 0);\\n};\\n\\nip.fromLong = function(ipl) {\\n  return ((ipl >>> 24) + '.' +\\n      (ipl >> 16 & 255) + '.' +\\n      (ipl >> 8 & 255) + '.' +\\n      (ipl & 255) );\\n};\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/IP/ip.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/IP/README\": {\n            \"text\": \"# IP  \\n[![](https://badge.fury.io/js/ip.svg)](https://www.npmjs.com/package/ip)  \\n\\nIP address utilities for node.js\\n\\n## Installation\\n\\n###  npm\\n```shell\\nnpm install ip\\n```\\n\\n### git\\n\\n```shell\\ngit clone https://github.com/indutny/node-ip.git\\n```\\n  \\n## Usage\\nGet your ip address, compare ip addresses, validate ip addresses, etc.\\n\\n```js\\nvar ip = require('ip');\\n\\nip.address() // my ip address\\nip.isEqual('::1', '::0:1'); // true\\nip.toBuffer('127.0.0.1') // Buffer([127, 0, 0, 1])\\nip.toString(new Buffer([127, 0, 0, 1])) // 127.0.0.1\\nip.fromPrefixLen(24) // 255.255.255.0\\nip.mask('192.168.1.134', '255.255.255.0') // 192.168.1.0\\nip.cidr('192.168.1.134/26') // 192.168.1.128\\nip.not('255.255.255.0') // 0.0.0.255\\nip.or('192.168.1.134', '0.0.0.255') // 192.168.1.255\\nip.isPrivate('127.0.0.1') // true\\nip.isV4Format('127.0.0.1'); // true\\nip.isV6Format('::ffff:127.0.0.1'); // true\\n\\n// operate on buffers in-place\\nvar buf = new Buffer(128);\\nvar offset = 64;\\nip.toBuffer('127.0.0.1', buf, offset);  // [127, 0, 0, 1] at offset 64\\nip.toString(buf, offset, 4);            // '127.0.0.1'\\n\\n// subnet information\\nip.subnet('192.168.1.134', '255.255.255.192')\\n// { networkAddress: '192.168.1.128',\\n//   firstAddress: '192.168.1.129',\\n//   lastAddress: '192.168.1.190',\\n//   broadcastAddress: '192.168.1.191',\\n//   subnetMask: '255.255.255.192',\\n//   subnetMaskLength: 26,\\n//   numHosts: 62,\\n//   length: 64,\\n//   contains: function(addr){...} }\\nip.cidrSubnet('192.168.1.134/26')\\n// Same as previous.\\n\\n// range checking\\nip.cidrSubnet('192.168.1.134/26').contains('192.168.1.190') // true\\n\\n\\n// ipv4 long conversion\\nip.toLong('127.0.0.1'); // 2130706433\\nip.fromLong(2130706433); // '127.0.0.1'\\n```\\n\\n### License\\n\\nThis software is licensed under the MIT License.\\n\\nCopyright Fedor Indutny, 2012.\\n\\nPermission is hereby granted, free of charge, to any person obtaining a\\ncopy of this software and associated documentation files (the\\n\\\"Software\\\"), to deal in the Software without restriction, including\\nwithout limitation the rights to use, copy, modify, merge, publish,\\ndistribute, sublicense, and/or sell copies of the Software, and to permit\\npersons to whom the Software is furnished to do so, subject to the\\nfollowing conditions:\\n\\nThe above copyright notice and this permission notice shall be included\\nin all copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\\n\",\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/IP/README\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/ws.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\nconst WebSocket = require('./lib/websocket');\\n\\nWebSocket.Server = require('./lib/websocket-server');\\nWebSocket.Receiver = require('./lib/receiver');\\nWebSocket.Sender = require('./lib/sender');\\n\\nmodule.exports = WebSocket;\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/ws.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/README\": {\n            \"text\": \"# ws: a Node.js WebSocket library\\n\\n[![Version npm](https://img.shields.io/npm/v/ws.svg)](https://www.npmjs.com/package/ws)\\n[![Linux Build](https://img.shields.io/travis/websockets/ws/master.svg)](https://travis-ci.org/websockets/ws)\\n[![Windows Build](https://ci.appveyor.com/api/projects/status/github/websockets/ws?branch=master&svg=true)](https://ci.appveyor.com/project/lpinca/ws)\\n[![Coverage Status](https://img.shields.io/coveralls/websockets/ws/master.svg)](https://coveralls.io/r/websockets/ws?branch=master)\\n\\nws is a simple to use, blazing fast, and thoroughly tested WebSocket client\\nand server implementation.\\n\\nPasses the quite extensive Autobahn test suite: [server][server-report],\\n[client][client-report].\\n\\n**Note**: This module does not work in the browser. The client in the docs is a\\nreference to a back end with the role of a client in the WebSocket\\ncommunication. Browser clients must use the native\\n[`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) object.\\nTo make the same code work seamlessly on Node.js and the browser, you can use\\none of the many wrappers available on npm, like\\n[isomorphic-ws](https://github.com/heineiuo/isomorphic-ws).\\n\\n## Table of Contents\\n\\n* [Protocol support](#protocol-support)\\n* [Installing](#installing)\\n  + [Opt-in for performance and spec compliance](#opt-in-for-performance-and-spec-compliance)\\n* [API docs](#api-docs)\\n* [WebSocket compression](#websocket-compression)\\n* [Usage examples](#usage-examples)\\n  + [Sending and receiving text data](#sending-and-receiving-text-data)\\n  + [Sending binary data](#sending-binary-data)\\n  + [Simple server](#simple-server)\\n  + [External HTTP/S server](#external-https-server)\\n  + [Multiple servers sharing a single HTTP/S server](#multiple-servers-sharing-a-single-https-server)\\n  + [Server broadcast](#server-broadcast)\\n  + [echo.websocket.org demo](#echowebsocketorg-demo)\\n  + [Other examples](#other-examples)\\n* [Error handling best practices](#error-handling-best-practices)\\n* [FAQ](#faq)\\n  + [How to get the IP address of the client?](#how-to-get-the-ip-address-of-the-client)\\n  + [How to detect and close broken connections?](#how-to-detect-and-close-broken-connections)\\n  + [How to connect via a proxy?](#how-to-connect-via-a-proxy)\\n* [Changelog](#changelog)\\n* [License](#license)\\n\\n## Protocol support\\n\\n* **HyBi drafts 07-12** (Use the option `protocolVersion: 8`)\\n* **HyBi drafts 13-17** (Current default, alternatively option `protocolVersion: 13`)\\n\\n## Installing\\n\\n```\\nnpm install --save ws\\n```\\n\\n### Opt-in for performance and spec compliance\\n\\nThere are 2 optional modules that can be installed along side with the ws\\nmodule. These modules are binary addons which improve certain operations.\\nPrebuilt binaries are available for the most popular platforms so you don't\\nnecessarily need to have a C++ compiler installed on your machine.\\n\\n- `npm install --save-optional bufferutil`: Allows to efficiently perform\\n  operations such as masking and unmasking the data payload of the WebSocket\\n  frames.\\n- `npm install --save-optional utf-8-validate`: Allows to efficiently check\\n  if a message contains valid UTF-8 as required by the spec.\\n\\n## API docs\\n\\nSee [`/doc/ws.md`](./doc/ws.md) for Node.js-like docs for the ws classes.\\n\\n## WebSocket compression\\n\\nws supports the [permessage-deflate extension][permessage-deflate] which\\nenables the client and server to negotiate a compression algorithm and its\\nparameters, and then selectively apply it to the data payloads of each\\nWebSocket message.\\n\\nThe extension is disabled by default on the server and enabled by default on\\nthe client. It adds a significant overhead in terms of performance and memory\\nconsumption so we suggest to enable it only if it is really needed.\\n\\nNote that Node.js has a variety of issues with high-performance compression,\\nwhere increased concurrency, especially on Linux, can lead to\\n[catastrophic memory fragmentation][node-zlib-bug] and slow performance.\\nIf you intend to use permessage-deflate in production, it is worthwhile to set\\nup a test representative of your workload and ensure Node.js/zlib will handle\\nit with acceptable performance and memory usage.\\n\\nTuning of permessage-deflate can be done via the options defined below. You can\\nalso use `zlibDeflateOptions` and `zlibInflateOptions`, which is passed directly\\ninto the creation of [raw deflate/inflate streams][node-zlib-deflaterawdocs].\\n\\nSee [the docs][ws-server-options] for more options.\\n\\n```js\\nconst WebSocket = require('ws');\\n\\nconst wss = new WebSocket.Server({\\n  port: 8080,\\n  perMessageDeflate: {\\n    zlibDeflateOptions: { // See zlib defaults.\\n      chunkSize: 1024,\\n      memLevel: 7,\\n      level: 3,\\n    },\\n    zlibInflateOptions: {\\n      chunkSize: 10 * 1024\\n    },\\n    // Other options settable:\\n    clientNoContextTakeover: true, // Defaults to negotiated value.\\n    serverNoContextTakeover: true, // Defaults to negotiated value.\\n    clientMaxWindowBits: 10,       // Defaults to negotiated value.\\n    serverMaxWindowBits: 10,       // Defaults to negotiated value.\\n    // Below options specified as default values.\\n    concurrencyLimit: 10,          // Limits zlib concurrency for perf.\\n    threshold: 1024,               // Size (in bytes) below which messages\\n                                   // should not be compressed.\\n  }\\n});\\n```\\n\\nThe client will only use the extension if it is supported and enabled on the\\nserver. To always disable the extension on the client set the\\n`perMessageDeflate` option to `false`.\\n\\n```js\\nconst WebSocket = require('ws');\\n\\nconst ws = new WebSocket('ws://www.host.com/path', {\\n  perMessageDeflate: false\\n});\\n```\\n\\n## Usage examples\\n\\n### Sending and receiving text data\\n\\n```js\\nconst WebSocket = require('ws');\\n\\nconst ws = new WebSocket('ws://www.host.com/path');\\n\\nws.on('open', function open() {\\n  ws.send('something');\\n});\\n\\nws.on('message', function incoming(data) {\\n  console.log(data);\\n});\\n```\\n\\n### Sending binary data\\n\\n```js\\nconst WebSocket = require('ws');\\n\\nconst ws = new WebSocket('ws://www.host.com/path');\\n\\nws.on('open', function open() {\\n  const array = new Float32Array(5);\\n\\n  for (var i = 0; i < array.length; ++i) {\\n    array[i] = i / 2;\\n  }\\n\\n  ws.send(array);\\n});\\n```\\n\\n### Simple server\\n\\n```js\\nconst WebSocket = require('ws');\\n\\nconst wss = new WebSocket.Server({ port: 8080 });\\n\\nwss.on('connection', function connection(ws) {\\n  ws.on('message', function incoming(message) {\\n    console.log('received: %s', message);\\n  });\\n\\n  ws.send('something');\\n});\\n```\\n\\n### External HTTP/S server\\n\\n```js\\nconst fs = require('fs');\\nconst https = require('https');\\nconst WebSocket = require('ws');\\n\\nconst server = new https.createServer({\\n  cert: fs.readFileSync('/path/to/cert.pem'),\\n  key: fs.readFileSync('/path/to/key.pem')\\n});\\nconst wss = new WebSocket.Server({ server });\\n\\nwss.on('connection', function connection(ws) {\\n  ws.on('message', function incoming(message) {\\n    console.log('received: %s', message);\\n  });\\n\\n  ws.send('something');\\n});\\n\\nserver.listen(8080);\\n```\\n\\n### Multiple servers sharing a single HTTP/S server\\n\\n```js\\nconst http = require('http');\\nconst WebSocket = require('ws');\\n\\nconst server = http.createServer();\\nconst wss1 = new WebSocket.Server({ noServer: true });\\nconst wss2 = new WebSocket.Server({ noServer: true });\\n\\nwss1.on('connection', function connection(ws) {\\n  // ...\\n});\\n\\nwss2.on('connection', function connection(ws) {\\n  // ...\\n});\\n\\nserver.on('upgrade', function upgrade(request, socket, head) {\\n  const pathname = url.parse(request.url).pathname;\\n\\n  if (pathname === '/foo') {\\n    wss1.handleUpgrade(request, socket, head, function done(ws) {\\n      wss1.emit('connection', ws, request);\\n    });\\n  } else if (pathname === '/bar') {\\n    wss2.handleUpgrade(request, socket, head, function done(ws) {\\n      wss2.emit('connection', ws, request);\\n    });\\n  } else {\\n    socket.destroy();\\n  }\\n});\\n\\nserver.listen(8080);\\n```\\n\\n### Server broadcast\\n\\n```js\\nconst WebSocket = require('ws');\\n\\nconst wss = new WebSocket.Server({ port: 8080 });\\n\\n// Broadcast to all.\\nwss.broadcast = function broadcast(data) {\\n  wss.clients.forEach(function each(client) {\\n    if (client.readyState === WebSocket.OPEN) {\\n      client.send(data);\\n    }\\n  });\\n};\\n\\nwss.on('connection', function connection(ws) {\\n  ws.on('message', function incoming(data) {\\n    // Broadcast to everyone else.\\n    wss.clients.forEach(function each(client) {\\n      if (client !== ws && client.readyState === WebSocket.OPEN) {\\n        client.send(data);\\n      }\\n    });\\n  });\\n});\\n```\\n\\n### echo.websocket.org demo\\n\\n```js\\nconst WebSocket = require('ws');\\n\\nconst ws = new WebSocket('wss://echo.websocket.org/', {\\n  origin: 'https://websocket.org'\\n});\\n\\nws.on('open', function open() {\\n  console.log('connected');\\n  ws.send(Date.now());\\n});\\n\\nws.on('close', function close() {\\n  console.log('disconnected');\\n});\\n\\nws.on('message', function incoming(data) {\\n  console.log(`Roundtrip time: ${Date.now() - data} ms`);\\n\\n  setTimeout(function timeout() {\\n    ws.send(Date.now());\\n  }, 500);\\n});\\n```\\n\\n### Other examples\\n\\nFor a full example with a browser client communicating with a ws server, see the\\nexamples folder.\\n\\nOtherwise, see the test cases.\\n\\n## Error handling best practices\\n\\n```js\\n// If the WebSocket is closed before the following send is attempted\\nws.send('something');\\n\\n// Errors (both immediate and async write errors) can be detected in an optional\\n// callback. The callback is also the only way of being notified that data has\\n// actually been sent.\\nws.send('something', function ack(error) {\\n  // If error is not defined, the send has been completed, otherwise the error\\n  // object will indicate what failed.\\n});\\n\\n// Immediate errors can also be handled with `try...catch`, but **note** that\\n// since sends are inherently asynchronous, socket write failures will *not* be\\n// captured when this technique is used.\\ntry { ws.send('something'); }\\ncatch (e) { /* handle error */ }\\n```\\n\\n## FAQ\\n\\n### How to get the IP address of the client?\\n\\nThe remote IP address can be obtained from the raw socket.\\n\\n```js\\nconst WebSocket = require('ws');\\n\\nconst wss = new WebSocket.Server({ port: 8080 });\\n\\nwss.on('connection', function connection(ws, req) {\\n  const ip = req.connection.remoteAddress;\\n});\\n```\\n\\nWhen the server runs behind a proxy like NGINX, the de-facto standard is to use\\nthe `X-Forwarded-For` header.\\n\\n```js\\nwss.on('connection', function connection(ws, req) {\\n  const ip = req.headers['x-forwarded-for'].split(/\\\\s*,\\\\s*/)[0];\\n});\\n```\\n\\n### How to detect and close broken connections?\\n\\nSometimes the link between the server and the client can be interrupted in a\\nway that keeps both the server and the client unaware of the broken state of the\\nconnection (e.g. when pulling the cord).\\n\\nIn these cases ping messages can be used as a means to verify that the remote\\nendpoint is still responsive.\\n\\n```js\\nconst WebSocket = require('ws');\\n\\nconst wss = new WebSocket.Server({ port: 8080 });\\n\\nfunction noop() {}\\n\\nfunction heartbeat() {\\n  this.isAlive = true;\\n}\\n\\nwss.on('connection', function connection(ws) {\\n  ws.isAlive = true;\\n  ws.on('pong', heartbeat);\\n});\\n\\nconst interval = setInterval(function ping() {\\n  wss.clients.forEach(function each(ws) {\\n    if (ws.isAlive === false) return ws.terminate();\\n\\n    ws.isAlive = false;\\n    ws.ping(noop);\\n  });\\n}, 30000);\\n```\\n\\nPong messages are automatically sent in response to ping messages as required\\nby the spec.\\n\\n### How to connect via a proxy?\\n\\nUse a custom `http.Agent` implementation like [https-proxy-agent][] or\\n[socks-proxy-agent][].\\n\\n## Changelog\\n\\nWe're using the GitHub [releases][changelog] for changelog entries.\\n\\n## License\\n\\n[MIT](LICENSE)\\n\\n[https-proxy-agent]: https://github.com/TooTallNate/node-https-proxy-agent\\n[socks-proxy-agent]: https://github.com/TooTallNate/node-socks-proxy-agent\\n[client-report]: http://websockets.github.io/ws/autobahn/clients/\\n[server-report]: http://websockets.github.io/ws/autobahn/servers/\\n[permessage-deflate]: https://tools.ietf.org/html/rfc7692\\n[changelog]: https://github.com/websockets/ws/releases\\n[node-zlib-bug]: https://github.com/nodejs/node/issues/8871\\n[node-zlib-deflaterawdocs]: https://nodejs.org/api/zlib.html#zlib_zlib_createdeflateraw_options\\n[ws-server-options]: https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback\\n\",\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/README\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/LICENSE\": {\n            \"text\": \"The MIT License (MIT)\\n\\nCopyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n\",\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/LICENSE\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/lib/buffer-util.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\n/**\\n * Merges an array of buffers into a new buffer.\\n *\\n * @param {Buffer[]} list The array of buffers to concat\\n * @param {Number} totalLength The total length of buffers in the list\\n * @return {Buffer} The resulting buffer\\n * @public\\n */\\nfunction concat (list, totalLength) {\\n  const target = Buffer.allocUnsafe(totalLength);\\n  var offset = 0;\\n\\n  for (var i = 0; i < list.length; i++) {\\n    const buf = list[i];\\n    buf.copy(target, offset);\\n    offset += buf.length;\\n  }\\n\\n  return target;\\n}\\n\\n/**\\n * Masks a buffer using the given mask.\\n *\\n * @param {Buffer} source The buffer to mask\\n * @param {Buffer} mask The mask to use\\n * @param {Buffer} output The buffer where to store the result\\n * @param {Number} offset The offset at which to start writing\\n * @param {Number} length The number of bytes to mask.\\n * @public\\n */\\nfunction _mask (source, mask, output, offset, length) {\\n  for (var i = 0; i < length; i++) {\\n    output[offset + i] = source[i] ^ mask[i & 3];\\n  }\\n}\\n\\n/**\\n * Unmasks a buffer using the given mask.\\n *\\n * @param {Buffer} buffer The buffer to unmask\\n * @param {Buffer} mask The mask to use\\n * @public\\n */\\nfunction _unmask (buffer, mask) {\\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\\n  const length = buffer.length;\\n  for (var i = 0; i < length; i++) {\\n    buffer[i] ^= mask[i & 3];\\n  }\\n}\\n\\ntry {\\n  const bufferUtil = require('bufferutil');\\n  const bu = bufferUtil.BufferUtil || bufferUtil;\\n\\n  module.exports = {\\n    mask (source, mask, output, offset, length) {\\n      if (length < 48) _mask(source, mask, output, offset, length);\\n      else bu.mask(source, mask, output, offset, length);\\n    },\\n    unmask (buffer, mask) {\\n      if (buffer.length < 32) _unmask(buffer, mask);\\n      else bu.unmask(buffer, mask);\\n    },\\n    concat\\n  };\\n} catch (e) /* istanbul ignore next */ {\\n  module.exports = { concat, mask: _mask, unmask: _unmask };\\n}\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/lib/buffer-util.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/lib/constants.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\nmodule.exports = {\\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\\n  kStatusCode: Symbol('status-code'),\\n  kWebSocket: Symbol('websocket'),\\n  EMPTY_BUFFER: Buffer.alloc(0),\\n  NOOP: () => {}\\n};\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/lib/constants.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/lib/event-target.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\n/**\\n * Class representing an event.\\n *\\n * @private\\n */\\nclass Event {\\n  /**\\n   * Create a new `Event`.\\n   *\\n   * @param {String} type The name of the event\\n   * @param {Object} target A reference to the target to which the event was dispatched\\n   */\\n  constructor (type, target) {\\n    this.target = target;\\n    this.type = type;\\n  }\\n}\\n\\n/**\\n * Class representing a message event.\\n *\\n * @extends Event\\n * @private\\n */\\nclass MessageEvent extends Event {\\n  /**\\n   * Create a new `MessageEvent`.\\n   *\\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\\n   */\\n  constructor (data, target) {\\n    super('message', target);\\n\\n    this.data = data;\\n  }\\n}\\n\\n/**\\n * Class representing a close event.\\n *\\n * @extends Event\\n * @private\\n */\\nclass CloseEvent extends Event {\\n  /**\\n   * Create a new `CloseEvent`.\\n   *\\n   * @param {Number} code The status code explaining why the connection is being closed\\n   * @param {String} reason A human-readable string explaining why the connection is closing\\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\\n   */\\n  constructor (code, reason, target) {\\n    super('close', target);\\n\\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\\n    this.reason = reason;\\n    this.code = code;\\n  }\\n}\\n\\n/**\\n * Class representing an open event.\\n *\\n * @extends Event\\n * @private\\n */\\nclass OpenEvent extends Event {\\n  /**\\n   * Create a new `OpenEvent`.\\n   *\\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\\n   */\\n  constructor (target) {\\n    super('open', target);\\n  }\\n}\\n\\n/**\\n * Class representing an error event.\\n *\\n * @extends Event\\n * @private\\n */\\nclass ErrorEvent extends Event {\\n  /**\\n   * Create a new `ErrorEvent`.\\n   *\\n   * @param {Object} error The error that generated this event\\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\\n   */\\n  constructor (error, target) {\\n    super('error', target);\\n\\n    this.message = error.message;\\n    this.error = error;\\n  }\\n}\\n\\n/**\\n * This provides methods for emulating the `EventTarget` interface. It's not\\n * meant to be used directly.\\n *\\n * @mixin\\n */\\nconst EventTarget = {\\n  /**\\n   * Register an event listener.\\n   *\\n   * @param {String} method A string representing the event type to listen for\\n   * @param {Function} listener The listener to add\\n   * @public\\n   */\\n  addEventListener (method, listener) {\\n    if (typeof listener !== 'function') return;\\n\\n    function onMessage (data) {\\n      listener.call(this, new MessageEvent(data, this));\\n    }\\n\\n    function onClose (code, message) {\\n      listener.call(this, new CloseEvent(code, message, this));\\n    }\\n\\n    function onError (error) {\\n      listener.call(this, new ErrorEvent(error, this));\\n    }\\n\\n    function onOpen () {\\n      listener.call(this, new OpenEvent(this));\\n    }\\n\\n    if (method === 'message') {\\n      onMessage._listener = listener;\\n      this.on(method, onMessage);\\n    } else if (method === 'close') {\\n      onClose._listener = listener;\\n      this.on(method, onClose);\\n    } else if (method === 'error') {\\n      onError._listener = listener;\\n      this.on(method, onError);\\n    } else if (method === 'open') {\\n      onOpen._listener = listener;\\n      this.on(method, onOpen);\\n    } else {\\n      this.on(method, listener);\\n    }\\n  },\\n\\n  /**\\n   * Remove an event listener.\\n   *\\n   * @param {String} method A string representing the event type to remove\\n   * @param {Function} listener The listener to remove\\n   * @public\\n   */\\n  removeEventListener (method, listener) {\\n    const listeners = this.listeners(method);\\n\\n    for (var i = 0; i < listeners.length; i++) {\\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\\n        this.removeListener(method, listeners[i]);\\n      }\\n    }\\n  }\\n};\\n\\nmodule.exports = EventTarget;\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/lib/event-target.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/lib/extension.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\n//\\n// Allowed token characters:\\n//\\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\\n//\\n// tokenChars[32] === 0 // ' '\\n// tokenChars[33] === 1 // '!'\\n// tokenChars[34] === 0 // '\\\"'\\n// ...\\n//\\nconst tokenChars = [\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\\n];\\n\\n/**\\n * Adds an offer to the map of extension offers or a parameter to the map of\\n * parameters.\\n *\\n * @param {Object} dest The map of extension offers or parameters\\n * @param {String} name The extension or parameter name\\n * @param {(Object|Boolean|String)} elem The extension parameters or the\\n *     parameter value\\n * @private\\n */\\nfunction push (dest, name, elem) {\\n  if (Object.prototype.hasOwnProperty.call(dest, name)) dest[name].push(elem);\\n  else dest[name] = [elem];\\n}\\n\\n/**\\n * Parses the `Sec-WebSocket-Extensions` header into an object.\\n *\\n * @param {String} header The field value of the header\\n * @return {Object} The parsed object\\n * @public\\n */\\nfunction parse (header) {\\n  const offers = {};\\n\\n  if (header === undefined || header === '') return offers;\\n\\n  var params = {};\\n  var mustUnescape = false;\\n  var isEscaping = false;\\n  var inQuotes = false;\\n  var extensionName;\\n  var paramName;\\n  var start = -1;\\n  var end = -1;\\n\\n  for (var i = 0; i < header.length; i++) {\\n    const code = header.charCodeAt(i);\\n\\n    if (extensionName === undefined) {\\n      if (end === -1 && tokenChars[code] === 1) {\\n        if (start === -1) start = i;\\n      } else if (code === 0x20/* ' ' */|| code === 0x09/* '\\\\t' */) {\\n        if (end === -1 && start !== -1) end = i;\\n      } else if (code === 0x3b/* ';' */ || code === 0x2c/* ',' */) {\\n        if (start === -1) {\\n          throw new SyntaxError(`Unexpected character at index ${i}`);\\n        }\\n\\n        if (end === -1) end = i;\\n        const name = header.slice(start, end);\\n        if (code === 0x2c) {\\n          push(offers, name, params);\\n          params = {};\\n        } else {\\n          extensionName = name;\\n        }\\n\\n        start = end = -1;\\n      } else {\\n        throw new SyntaxError(`Unexpected character at index ${i}`);\\n      }\\n    } else if (paramName === undefined) {\\n      if (end === -1 && tokenChars[code] === 1) {\\n        if (start === -1) start = i;\\n      } else if (code === 0x20 || code === 0x09) {\\n        if (end === -1 && start !== -1) end = i;\\n      } else if (code === 0x3b || code === 0x2c) {\\n        if (start === -1) {\\n          throw new SyntaxError(`Unexpected character at index ${i}`);\\n        }\\n\\n        if (end === -1) end = i;\\n        push(params, header.slice(start, end), true);\\n        if (code === 0x2c) {\\n          push(offers, extensionName, params);\\n          params = {};\\n          extensionName = undefined;\\n        }\\n\\n        start = end = -1;\\n      } else if (code === 0x3d/* '=' */&& start !== -1 && end === -1) {\\n        paramName = header.slice(start, i);\\n        start = end = -1;\\n      } else {\\n        throw new SyntaxError(`Unexpected character at index ${i}`);\\n      }\\n    } else {\\n      //\\n      // The value of a quoted-string after unescaping must conform to the\\n      // token ABNF, so only token characters are valid.\\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\\n      //\\n      if (isEscaping) {\\n        if (tokenChars[code] !== 1) {\\n          throw new SyntaxError(`Unexpected character at index ${i}`);\\n        }\\n        if (start === -1) start = i;\\n        else if (!mustUnescape) mustUnescape = true;\\n        isEscaping = false;\\n      } else if (inQuotes) {\\n        if (tokenChars[code] === 1) {\\n          if (start === -1) start = i;\\n        } else if (code === 0x22/* '\\\"' */ && start !== -1) {\\n          inQuotes = false;\\n          end = i;\\n        } else if (code === 0x5c/* '\\\\' */) {\\n          isEscaping = true;\\n        } else {\\n          throw new SyntaxError(`Unexpected character at index ${i}`);\\n        }\\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\\n        inQuotes = true;\\n      } else if (end === -1 && tokenChars[code] === 1) {\\n        if (start === -1) start = i;\\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\\n        if (end === -1) end = i;\\n      } else if (code === 0x3b || code === 0x2c) {\\n        if (start === -1) {\\n          throw new SyntaxError(`Unexpected character at index ${i}`);\\n        }\\n\\n        if (end === -1) end = i;\\n        var value = header.slice(start, end);\\n        if (mustUnescape) {\\n          value = value.replace(/\\\\\\\\/g, '');\\n          mustUnescape = false;\\n        }\\n        push(params, paramName, value);\\n        if (code === 0x2c) {\\n          push(offers, extensionName, params);\\n          params = {};\\n          extensionName = undefined;\\n        }\\n\\n        paramName = undefined;\\n        start = end = -1;\\n      } else {\\n        throw new SyntaxError(`Unexpected character at index ${i}`);\\n      }\\n    }\\n  }\\n\\n  if (start === -1 || inQuotes) {\\n    throw new SyntaxError('Unexpected end of input');\\n  }\\n\\n  if (end === -1) end = i;\\n  const token = header.slice(start, end);\\n  if (extensionName === undefined) {\\n    push(offers, token, {});\\n  } else {\\n    if (paramName === undefined) {\\n      push(params, token, true);\\n    } else if (mustUnescape) {\\n      push(params, paramName, token.replace(/\\\\\\\\/g, ''));\\n    } else {\\n      push(params, paramName, token);\\n    }\\n    push(offers, extensionName, params);\\n  }\\n\\n  return offers;\\n}\\n\\n/**\\n * Builds the `Sec-WebSocket-Extensions` header field value.\\n *\\n * @param {Object} extensions The map of extensions and parameters to format\\n * @return {String} A string representing the given object\\n * @public\\n */\\nfunction format (extensions) {\\n  return Object.keys(extensions).map((extension) => {\\n    var configurations = extensions[extension];\\n    if (!Array.isArray(configurations)) configurations = [configurations];\\n    return configurations.map((params) => {\\n      return [extension].concat(Object.keys(params).map((k) => {\\n        var values = params[k];\\n        if (!Array.isArray(values)) values = [values];\\n        return values.map((v) => v === true ? k : `${k}=${v}`).join('; ');\\n      })).join('; ');\\n    }).join(', ');\\n  }).join(', ');\\n}\\n\\nmodule.exports = { format, parse };\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/lib/extension.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/lib/permessage-deflate.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\n//const Limiter = require('async-limiter');\\nconst Limiter = require('$:/plugins/OokTech/Bob/External/async-limiter/async-limiter.js');\\nconst zlib = require('zlib');\\n\\nconst bufferUtil = require('./buffer-util');\\nconst constants = require('./constants');\\n\\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\\nconst EMPTY_BLOCK = Buffer.from([0x00]);\\n\\nconst kPerMessageDeflate = Symbol('permessage-deflate');\\nconst kWriteInProgress = Symbol('write-in-progress');\\nconst kPendingClose = Symbol('pending-close');\\nconst kTotalLength = Symbol('total-length');\\nconst kCallback = Symbol('callback');\\nconst kBuffers = Symbol('buffers');\\nconst kError = Symbol('error');\\n\\n//\\n// We limit zlib concurrency, which prevents severe memory fragmentation\\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\\n// and https://github.com/websockets/ws/issues/1202\\n//\\n// Intentionally global; it's the global thread pool that's an issue.\\n//\\nlet zlibLimiter;\\n\\n/**\\n * permessage-deflate implementation.\\n */\\nclass PerMessageDeflate {\\n  /**\\n   * Creates a PerMessageDeflate instance.\\n   *\\n   * @param {Object} options Configuration options\\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\\n   *     of server context takeover\\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\\n   *     disabling of client context takeover\\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\\n   *     use of a custom server window size\\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\\n   *     for, or request, a custom client window size\\n   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate\\n   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate\\n   * @param {Number} options.threshold Size (in bytes) below which messages\\n   *     should not be compressed\\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\\n   *     zlib\\n   * @param {Boolean} isServer Create the instance in either server or client\\n   *     mode\\n   * @param {Number} maxPayload The maximum allowed message length\\n   */\\n  constructor (options, isServer, maxPayload) {\\n    this._maxPayload = maxPayload | 0;\\n    this._options = options || {};\\n    this._threshold = this._options.threshold !== undefined\\n      ? this._options.threshold\\n      : 1024;\\n    this._isServer = !!isServer;\\n    this._deflate = null;\\n    this._inflate = null;\\n\\n    this.params = null;\\n\\n    if (!zlibLimiter) {\\n      const concurrency = this._options.concurrencyLimit !== undefined\\n        ? this._options.concurrencyLimit\\n        : 10;\\n      zlibLimiter = new Limiter({ concurrency });\\n    }\\n  }\\n\\n  /**\\n   * @type {String}\\n   */\\n  static get extensionName () {\\n    return 'permessage-deflate';\\n  }\\n\\n  /**\\n   * Create an extension negotiation offer.\\n   *\\n   * @return {Object} Extension parameters\\n   * @public\\n   */\\n  offer () {\\n    const params = {};\\n\\n    if (this._options.serverNoContextTakeover) {\\n      params.server_no_context_takeover = true;\\n    }\\n    if (this._options.clientNoContextTakeover) {\\n      params.client_no_context_takeover = true;\\n    }\\n    if (this._options.serverMaxWindowBits) {\\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\\n    }\\n    if (this._options.clientMaxWindowBits) {\\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\\n    } else if (this._options.clientMaxWindowBits == null) {\\n      params.client_max_window_bits = true;\\n    }\\n\\n    return params;\\n  }\\n\\n  /**\\n   * Accept an extension negotiation offer/response.\\n   *\\n   * @param {Array} configurations The extension negotiation offers/reponse\\n   * @return {Object} Accepted configuration\\n   * @public\\n   */\\n  accept (configurations) {\\n    configurations = this.normalizeParams(configurations);\\n\\n    this.params = this._isServer\\n      ? this.acceptAsServer(configurations)\\n      : this.acceptAsClient(configurations);\\n\\n    return this.params;\\n  }\\n\\n  /**\\n   * Releases all resources used by the extension.\\n   *\\n   * @public\\n   */\\n  cleanup () {\\n    if (this._inflate) {\\n      if (this._inflate[kWriteInProgress]) {\\n        this._inflate[kPendingClose] = true;\\n      } else {\\n        this._inflate.close();\\n        this._inflate = null;\\n      }\\n    }\\n    if (this._deflate) {\\n      if (this._deflate[kWriteInProgress]) {\\n        this._deflate[kPendingClose] = true;\\n      } else {\\n        this._deflate.close();\\n        this._deflate = null;\\n      }\\n    }\\n  }\\n\\n  /**\\n   *  Accept an extension negotiation offer.\\n   *\\n   * @param {Array} offers The extension negotiation offers\\n   * @return {Object} Accepted configuration\\n   * @private\\n   */\\n  acceptAsServer (offers) {\\n    const opts = this._options;\\n    const accepted = offers.find((params) => {\\n      if (\\n        (opts.serverNoContextTakeover === false &&\\n          params.server_no_context_takeover) ||\\n        (params.server_max_window_bits &&\\n          (opts.serverMaxWindowBits === false ||\\n            (typeof opts.serverMaxWindowBits === 'number' &&\\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\\n        (typeof opts.clientMaxWindowBits === 'number' &&\\n          !params.client_max_window_bits)\\n      ) {\\n        return false;\\n      }\\n\\n      return true;\\n    });\\n\\n    if (!accepted) {\\n      throw new Error('None of the extension offers can be accepted');\\n    }\\n\\n    if (opts.serverNoContextTakeover) {\\n      accepted.server_no_context_takeover = true;\\n    }\\n    if (opts.clientNoContextTakeover) {\\n      accepted.client_no_context_takeover = true;\\n    }\\n    if (typeof opts.serverMaxWindowBits === 'number') {\\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\\n    }\\n    if (typeof opts.clientMaxWindowBits === 'number') {\\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\\n    } else if (\\n      accepted.client_max_window_bits === true ||\\n      opts.clientMaxWindowBits === false\\n    ) {\\n      delete accepted.client_max_window_bits;\\n    }\\n\\n    return accepted;\\n  }\\n\\n  /**\\n   * Accept the extension negotiation response.\\n   *\\n   * @param {Array} response The extension negotiation response\\n   * @return {Object} Accepted configuration\\n   * @private\\n   */\\n  acceptAsClient (response) {\\n    const params = response[0];\\n\\n    if (\\n      this._options.clientNoContextTakeover === false &&\\n      params.client_no_context_takeover\\n    ) {\\n      throw new Error('Unexpected parameter \\\"client_no_context_takeover\\\"');\\n    }\\n\\n    if (!params.client_max_window_bits) {\\n      if (typeof this._options.clientMaxWindowBits === 'number') {\\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\\n      }\\n    } else if (\\n      this._options.clientMaxWindowBits === false ||\\n      (typeof this._options.clientMaxWindowBits === 'number' &&\\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\\n    ) {\\n      throw new Error(\\n        'Unexpected or invalid parameter \\\"client_max_window_bits\\\"'\\n      );\\n    }\\n\\n    return params;\\n  }\\n\\n  /**\\n   * Normalize parameters.\\n   *\\n   * @param {Array} configurations The extension negotiation offers/reponse\\n   * @return {Array} The offers/response with normalized parameters\\n   * @private\\n   */\\n  normalizeParams (configurations) {\\n    configurations.forEach((params) => {\\n      Object.keys(params).forEach((key) => {\\n        var value = params[key];\\n\\n        if (value.length > 1) {\\n          throw new Error(`Parameter \\\"${key}\\\" must have only a single value`);\\n        }\\n\\n        value = value[0];\\n\\n        if (key === 'client_max_window_bits') {\\n          if (value !== true) {\\n            const num = +value;\\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\\n              throw new TypeError(\\n                `Invalid value for parameter \\\"${key}\\\": ${value}`\\n              );\\n            }\\n            value = num;\\n          } else if (!this._isServer) {\\n            throw new TypeError(\\n              `Invalid value for parameter \\\"${key}\\\": ${value}`\\n            );\\n          }\\n        } else if (key === 'server_max_window_bits') {\\n          const num = +value;\\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\\n            throw new TypeError(\\n              `Invalid value for parameter \\\"${key}\\\": ${value}`\\n            );\\n          }\\n          value = num;\\n        } else if (\\n          key === 'client_no_context_takeover' ||\\n          key === 'server_no_context_takeover'\\n        ) {\\n          if (value !== true) {\\n            throw new TypeError(\\n              `Invalid value for parameter \\\"${key}\\\": ${value}`\\n            );\\n          }\\n        } else {\\n          throw new Error(`Unknown parameter \\\"${key}\\\"`);\\n        }\\n\\n        params[key] = value;\\n      });\\n    });\\n\\n    return configurations;\\n  }\\n\\n  /**\\n   * Decompress data. Concurrency limited by async-limiter.\\n   *\\n   * @param {Buffer} data Compressed data\\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\\n   * @param {Function} callback Callback\\n   * @public\\n   */\\n  decompress (data, fin, callback) {\\n    zlibLimiter.push((done) => {\\n      this._decompress(data, fin, (err, result) => {\\n        done();\\n        callback(err, result);\\n      });\\n    });\\n  }\\n\\n  /**\\n   * Compress data. Concurrency limited by async-limiter.\\n   *\\n   * @param {Buffer} data Data to compress\\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\\n   * @param {Function} callback Callback\\n   * @public\\n   */\\n  compress (data, fin, callback) {\\n    zlibLimiter.push((done) => {\\n      this._compress(data, fin, (err, result) => {\\n        done();\\n        callback(err, result);\\n      });\\n    });\\n  }\\n\\n  /**\\n   * Decompress data.\\n   *\\n   * @param {Buffer} data Compressed data\\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\\n   * @param {Function} callback Callback\\n   * @private\\n   */\\n  _decompress (data, fin, callback) {\\n    const endpoint = this._isServer ? 'client' : 'server';\\n\\n    if (!this._inflate) {\\n      const key = `${endpoint}_max_window_bits`;\\n      const windowBits = typeof this.params[key] !== 'number'\\n        ? zlib.Z_DEFAULT_WINDOWBITS\\n        : this.params[key];\\n\\n      this._inflate = zlib.createInflateRaw(\\n        Object.assign({}, this._options.zlibInflateOptions, { windowBits })\\n      );\\n      this._inflate[kPerMessageDeflate] = this;\\n      this._inflate[kTotalLength] = 0;\\n      this._inflate[kBuffers] = [];\\n      this._inflate.on('error', inflateOnError);\\n      this._inflate.on('data', inflateOnData);\\n    }\\n\\n    this._inflate[kCallback] = callback;\\n    this._inflate[kWriteInProgress] = true;\\n\\n    this._inflate.write(data);\\n    if (fin) this._inflate.write(TRAILER);\\n\\n    this._inflate.flush(() => {\\n      const err = this._inflate[kError];\\n\\n      if (err) {\\n        this._inflate.close();\\n        this._inflate = null;\\n        callback(err);\\n        return;\\n      }\\n\\n      const data = bufferUtil.concat(\\n        this._inflate[kBuffers],\\n        this._inflate[kTotalLength]\\n      );\\n\\n      if (\\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\\n        this._inflate[kPendingClose]\\n      ) {\\n        this._inflate.close();\\n        this._inflate = null;\\n      } else {\\n        this._inflate[kWriteInProgress] = false;\\n        this._inflate[kTotalLength] = 0;\\n        this._inflate[kBuffers] = [];\\n      }\\n\\n      callback(null, data);\\n    });\\n  }\\n\\n  /**\\n   * Compress data.\\n   *\\n   * @param {Buffer} data Data to compress\\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\\n   * @param {Function} callback Callback\\n   * @private\\n   */\\n  _compress (data, fin, callback) {\\n    if (!data || data.length === 0) {\\n      process.nextTick(callback, null, EMPTY_BLOCK);\\n      return;\\n    }\\n\\n    const endpoint = this._isServer ? 'server' : 'client';\\n\\n    if (!this._deflate) {\\n      const key = `${endpoint}_max_window_bits`;\\n      const windowBits = typeof this.params[key] !== 'number'\\n        ? zlib.Z_DEFAULT_WINDOWBITS\\n        : this.params[key];\\n\\n      this._deflate = zlib.createDeflateRaw(\\n        Object.assign({}, this._options.zlibDeflateOptions, { windowBits })\\n      );\\n\\n      this._deflate[kTotalLength] = 0;\\n      this._deflate[kBuffers] = [];\\n\\n      //\\n      // `zlib.DeflateRaw` emits an `'error'` event only when an attempt to use\\n      // it is made after it has already been closed. This cannot happen here,\\n      // so we only add a listener for the `'data'` event.\\n      //\\n      this._deflate.on('data', deflateOnData);\\n    }\\n\\n    this._deflate[kWriteInProgress] = true;\\n\\n    this._deflate.write(data);\\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\\n      var data = bufferUtil.concat(\\n        this._deflate[kBuffers],\\n        this._deflate[kTotalLength]\\n      );\\n\\n      if (fin) data = data.slice(0, data.length - 4);\\n\\n      if (\\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\\n        this._deflate[kPendingClose]\\n      ) {\\n        this._deflate.close();\\n        this._deflate = null;\\n      } else {\\n        this._deflate[kWriteInProgress] = false;\\n        this._deflate[kTotalLength] = 0;\\n        this._deflate[kBuffers] = [];\\n      }\\n\\n      callback(null, data);\\n    });\\n  }\\n}\\n\\nmodule.exports = PerMessageDeflate;\\n\\n/**\\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\\n *\\n * @param {Buffer} chunk A chunk of data\\n * @private\\n */\\nfunction deflateOnData (chunk) {\\n  this[kBuffers].push(chunk);\\n  this[kTotalLength] += chunk.length;\\n}\\n\\n/**\\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\\n *\\n * @param {Buffer} chunk A chunk of data\\n * @private\\n */\\nfunction inflateOnData (chunk) {\\n  this[kTotalLength] += chunk.length;\\n\\n  if (\\n    this[kPerMessageDeflate]._maxPayload < 1 ||\\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\\n  ) {\\n    this[kBuffers].push(chunk);\\n    return;\\n  }\\n\\n  this[kError] = new RangeError('Max payload size exceeded');\\n  this[kError][constants.kStatusCode] = 1009;\\n  this.removeListener('data', inflateOnData);\\n  this.reset();\\n}\\n\\n/**\\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\\n *\\n * @param {Error} err The emitted error\\n * @private\\n */\\nfunction inflateOnError (err) {\\n  //\\n  // There is no need to call `Zlib#close()` as the handle is automatically\\n  // closed when an error is emitted.\\n  //\\n  this[kPerMessageDeflate]._inflate = null;\\n  err[constants.kStatusCode] = 1007;\\n  this[kCallback](err);\\n}\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/lib/permessage-deflate.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/lib/receiver.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\nconst stream = require('stream');\\n\\nconst PerMessageDeflate = require('./permessage-deflate');\\nconst bufferUtil = require('./buffer-util');\\nconst validation = require('./validation');\\nconst constants = require('./constants');\\n\\nconst GET_INFO = 0;\\nconst GET_PAYLOAD_LENGTH_16 = 1;\\nconst GET_PAYLOAD_LENGTH_64 = 2;\\nconst GET_MASK = 3;\\nconst GET_DATA = 4;\\nconst INFLATING = 5;\\n\\n/**\\n * HyBi Receiver implementation.\\n *\\n * @extends stream.Writable\\n */\\nclass Receiver extends stream.Writable {\\n  /**\\n   * Creates a Receiver instance.\\n   *\\n   * @param {String} binaryType The type for binary data\\n   * @param {Object} extensions An object containing the negotiated extensions\\n   * @param {Number} maxPayload The maximum allowed message length\\n   */\\n  constructor (binaryType, extensions, maxPayload) {\\n    super();\\n\\n    this._binaryType = binaryType || constants.BINARY_TYPES[0];\\n    this[constants.kWebSocket] = undefined;\\n    this._extensions = extensions || {};\\n    this._maxPayload = maxPayload | 0;\\n\\n    this._bufferedBytes = 0;\\n    this._buffers = [];\\n\\n    this._compressed = false;\\n    this._payloadLength = 0;\\n    this._mask = undefined;\\n    this._fragmented = 0;\\n    this._masked = false;\\n    this._fin = false;\\n    this._opcode = 0;\\n\\n    this._totalPayloadLength = 0;\\n    this._messageLength = 0;\\n    this._fragments = [];\\n\\n    this._state = GET_INFO;\\n    this._loop = false;\\n  }\\n\\n  /**\\n   * Implements `Writable.prototype._write()`.\\n   *\\n   * @param {Buffer} chunk The chunk of data to write\\n   * @param {String} encoding The character encoding of `chunk`\\n   * @param {Function} cb Callback\\n   */\\n  _write (chunk, encoding, cb) {\\n    if (this._opcode === 0x08) return cb();\\n\\n    this._bufferedBytes += chunk.length;\\n    this._buffers.push(chunk);\\n    this.startLoop(cb);\\n  }\\n\\n  /**\\n   * Consumes `n` bytes from the buffered data.\\n   *\\n   * @param {Number} n The number of bytes to consume\\n   * @return {Buffer} The consumed bytes\\n   * @private\\n   */\\n  consume (n) {\\n    this._bufferedBytes -= n;\\n\\n    if (n === this._buffers[0].length) return this._buffers.shift();\\n\\n    if (n < this._buffers[0].length) {\\n      const buf = this._buffers[0];\\n      this._buffers[0] = buf.slice(n);\\n      return buf.slice(0, n);\\n    }\\n\\n    const dst = Buffer.allocUnsafe(n);\\n\\n    do {\\n      const buf = this._buffers[0];\\n\\n      if (n >= buf.length) {\\n        this._buffers.shift().copy(dst, dst.length - n);\\n      } else {\\n        buf.copy(dst, dst.length - n, 0, n);\\n        this._buffers[0] = buf.slice(n);\\n      }\\n\\n      n -= buf.length;\\n    } while (n > 0);\\n\\n    return dst;\\n  }\\n\\n  /**\\n   * Starts the parsing loop.\\n   *\\n   * @param {Function} cb Callback\\n   * @private\\n   */\\n  startLoop (cb) {\\n    var err;\\n    this._loop = true;\\n\\n    do {\\n      switch (this._state) {\\n        case GET_INFO:\\n          err = this.getInfo();\\n          break;\\n        case GET_PAYLOAD_LENGTH_16:\\n          err = this.getPayloadLength16();\\n          break;\\n        case GET_PAYLOAD_LENGTH_64:\\n          err = this.getPayloadLength64();\\n          break;\\n        case GET_MASK:\\n          this.getMask();\\n          break;\\n        case GET_DATA:\\n          err = this.getData(cb);\\n          break;\\n        default: // `INFLATING`\\n          this._loop = false;\\n          return;\\n      }\\n    } while (this._loop);\\n\\n    cb(err);\\n  }\\n\\n  /**\\n   * Reads the first two bytes of a frame.\\n   *\\n   * @return {(RangeError|undefined)} A possible error\\n   * @private\\n   */\\n  getInfo () {\\n    if (this._bufferedBytes < 2) {\\n      this._loop = false;\\n      return;\\n    }\\n\\n    const buf = this.consume(2);\\n\\n    if ((buf[0] & 0x30) !== 0x00) {\\n      this._loop = false;\\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);\\n    }\\n\\n    const compressed = (buf[0] & 0x40) === 0x40;\\n\\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\\n      this._loop = false;\\n      return error(RangeError, 'RSV1 must be clear', true, 1002);\\n    }\\n\\n    this._fin = (buf[0] & 0x80) === 0x80;\\n    this._opcode = buf[0] & 0x0f;\\n    this._payloadLength = buf[1] & 0x7f;\\n\\n    if (this._opcode === 0x00) {\\n      if (compressed) {\\n        this._loop = false;\\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\\n      }\\n\\n      if (!this._fragmented) {\\n        this._loop = false;\\n        return error(RangeError, 'invalid opcode 0', true, 1002);\\n      }\\n\\n      this._opcode = this._fragmented;\\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\\n      if (this._fragmented) {\\n        this._loop = false;\\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\\n      }\\n\\n      this._compressed = compressed;\\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\\n      if (!this._fin) {\\n        this._loop = false;\\n        return error(RangeError, 'FIN must be set', true, 1002);\\n      }\\n\\n      if (compressed) {\\n        this._loop = false;\\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\\n      }\\n\\n      if (this._payloadLength > 0x7d) {\\n        this._loop = false;\\n        return error(\\n          RangeError,\\n          `invalid payload length ${this._payloadLength}`,\\n          true,\\n          1002\\n        );\\n      }\\n    } else {\\n      this._loop = false;\\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\\n    }\\n\\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\\n    this._masked = (buf[1] & 0x80) === 0x80;\\n\\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\\n    else return this.haveLength();\\n  }\\n\\n  /**\\n   * Gets extended payload length (7+16).\\n   *\\n   * @return {(RangeError|undefined)} A possible error\\n   * @private\\n   */\\n  getPayloadLength16 () {\\n    if (this._bufferedBytes < 2) {\\n      this._loop = false;\\n      return;\\n    }\\n\\n    this._payloadLength = this.consume(2).readUInt16BE(0);\\n    return this.haveLength();\\n  }\\n\\n  /**\\n   * Gets extended payload length (7+64).\\n   *\\n   * @return {(RangeError|undefined)} A possible error\\n   * @private\\n   */\\n  getPayloadLength64 () {\\n    if (this._bufferedBytes < 8) {\\n      this._loop = false;\\n      return;\\n    }\\n\\n    const buf = this.consume(8);\\n    const num = buf.readUInt32BE(0);\\n\\n    //\\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\\n    // if payload length is greater than this number.\\n    //\\n    if (num > Math.pow(2, 53 - 32) - 1) {\\n      this._loop = false;\\n      return error(\\n        RangeError,\\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\\n        false,\\n        1009\\n      );\\n    }\\n\\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\\n    return this.haveLength();\\n  }\\n\\n  /**\\n   * Payload length has been read.\\n   *\\n   * @return {(RangeError|undefined)} A possible error\\n   * @private\\n   */\\n  haveLength () {\\n    if (this._payloadLength && this._opcode < 0x08) {\\n      this._totalPayloadLength += this._payloadLength;\\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\\n        this._loop = false;\\n        return error(RangeError, 'Max payload size exceeded', false, 1009);\\n      }\\n    }\\n\\n    if (this._masked) this._state = GET_MASK;\\n    else this._state = GET_DATA;\\n  }\\n\\n  /**\\n   * Reads mask bytes.\\n   *\\n   * @private\\n   */\\n  getMask () {\\n    if (this._bufferedBytes < 4) {\\n      this._loop = false;\\n      return;\\n    }\\n\\n    this._mask = this.consume(4);\\n    this._state = GET_DATA;\\n  }\\n\\n  /**\\n   * Reads data bytes.\\n   *\\n   * @param {Function} cb Callback\\n   * @return {(Error|RangeError|undefined)} A possible error\\n   * @private\\n   */\\n  getData (cb) {\\n    var data = constants.EMPTY_BUFFER;\\n\\n    if (this._payloadLength) {\\n      if (this._bufferedBytes < this._payloadLength) {\\n        this._loop = false;\\n        return;\\n      }\\n\\n      data = this.consume(this._payloadLength);\\n      if (this._masked) bufferUtil.unmask(data, this._mask);\\n    }\\n\\n    if (this._opcode > 0x07) return this.controlMessage(data);\\n\\n    if (this._compressed) {\\n      this._state = INFLATING;\\n      this.decompress(data, cb);\\n      return;\\n    }\\n\\n    if (data.length) {\\n      //\\n      // This message is not compressed so its lenght is the sum of the payload\\n      // length of all fragments.\\n      //\\n      this._messageLength = this._totalPayloadLength;\\n      this._fragments.push(data);\\n    }\\n\\n    return this.dataMessage();\\n  }\\n\\n  /**\\n   * Decompresses data.\\n   *\\n   * @param {Buffer} data Compressed data\\n   * @param {Function} cb Callback\\n   * @private\\n   */\\n  decompress (data, cb) {\\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\\n\\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\\n      if (err) return cb(err);\\n\\n      if (buf.length) {\\n        this._messageLength += buf.length;\\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\\n          return cb(error(RangeError, 'Max payload size exceeded', false, 1009));\\n        }\\n\\n        this._fragments.push(buf);\\n      }\\n\\n      const er = this.dataMessage();\\n      if (er) return cb(er);\\n\\n      this.startLoop(cb);\\n    });\\n  }\\n\\n  /**\\n   * Handles a data message.\\n   *\\n   * @return {(Error|undefined)} A possible error\\n   * @private\\n   */\\n  dataMessage () {\\n    if (this._fin) {\\n      const messageLength = this._messageLength;\\n      const fragments = this._fragments;\\n\\n      this._totalPayloadLength = 0;\\n      this._messageLength = 0;\\n      this._fragmented = 0;\\n      this._fragments = [];\\n\\n      if (this._opcode === 2) {\\n        var data;\\n\\n        if (this._binaryType === 'nodebuffer') {\\n          data = toBuffer(fragments, messageLength);\\n        } else if (this._binaryType === 'arraybuffer') {\\n          data = toArrayBuffer(toBuffer(fragments, messageLength));\\n        } else {\\n          data = fragments;\\n        }\\n\\n        this.emit('message', data);\\n      } else {\\n        const buf = toBuffer(fragments, messageLength);\\n\\n        if (!validation.isValidUTF8(buf)) {\\n          this._loop = false;\\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\\n        }\\n\\n        this.emit('message', buf.toString());\\n      }\\n    }\\n\\n    this._state = GET_INFO;\\n  }\\n\\n  /**\\n   * Handles a control message.\\n   *\\n   * @param {Buffer} data Data to handle\\n   * @return {(Error|RangeError|undefined)} A possible error\\n   * @private\\n   */\\n  controlMessage (data) {\\n    if (this._opcode === 0x08) {\\n      this._loop = false;\\n\\n      if (data.length === 0) {\\n        this.emit('conclude', 1005, '');\\n        this.end();\\n      } else if (data.length === 1) {\\n        return error(RangeError, 'invalid payload length 1', true, 1002);\\n      } else {\\n        const code = data.readUInt16BE(0);\\n\\n        if (!validation.isValidStatusCode(code)) {\\n          return error(RangeError, `invalid status code ${code}`, true, 1002);\\n        }\\n\\n        const buf = data.slice(2);\\n\\n        if (!validation.isValidUTF8(buf)) {\\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\\n        }\\n\\n        this.emit('conclude', code, buf.toString());\\n        this.end();\\n      }\\n\\n      return;\\n    }\\n\\n    if (this._opcode === 0x09) this.emit('ping', data);\\n    else this.emit('pong', data);\\n\\n    this._state = GET_INFO;\\n  }\\n}\\n\\nmodule.exports = Receiver;\\n\\n/**\\n * Builds an error object.\\n *\\n * @param {(Error|RangeError)} ErrorCtor The error constructor\\n * @param {String} message The error message\\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\\n *     `message`\\n * @param {Number} statusCode The status code\\n * @return {(Error|RangeError)} The error\\n * @private\\n */\\nfunction error (ErrorCtor, message, prefix, statusCode) {\\n  const err = new ErrorCtor(\\n    prefix ? `Invalid WebSocket frame: ${message}` : message\\n  );\\n\\n  Error.captureStackTrace(err, error);\\n  err[constants.kStatusCode] = statusCode;\\n  return err;\\n}\\n\\n/**\\n * Makes a buffer from a list of fragments.\\n *\\n * @param {Buffer[]} fragments The list of fragments composing the message\\n * @param {Number} messageLength The length of the message\\n * @return {Buffer}\\n * @private\\n */\\nfunction toBuffer (fragments, messageLength) {\\n  if (fragments.length === 1) return fragments[0];\\n  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\\n  return constants.EMPTY_BUFFER;\\n}\\n\\n/**\\n * Converts a buffer to an `ArrayBuffer`.\\n *\\n * @param {Buffer} The buffer to convert\\n * @return {ArrayBuffer} Converted buffer\\n */\\nfunction toArrayBuffer (buf) {\\n  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\\n    return buf.buffer;\\n  }\\n\\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\\n}\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/lib/receiver.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/lib/sender.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\nconst crypto = require('crypto');\\n\\nconst PerMessageDeflate = require('./permessage-deflate');\\nconst bufferUtil = require('./buffer-util');\\nconst validation = require('./validation');\\nconst constants = require('./constants');\\n\\n/**\\n * HyBi Sender implementation.\\n */\\nclass Sender {\\n  /**\\n   * Creates a Sender instance.\\n   *\\n   * @param {net.Socket} socket The connection socket\\n   * @param {Object} extensions An object containing the negotiated extensions\\n   */\\n  constructor (socket, extensions) {\\n    this._extensions = extensions || {};\\n    this._socket = socket;\\n\\n    this._firstFragment = true;\\n    this._compress = false;\\n\\n    this._bufferedBytes = 0;\\n    this._deflating = false;\\n    this._queue = [];\\n  }\\n\\n  /**\\n   * Frames a piece of data according to the HyBi WebSocket protocol.\\n   *\\n   * @param {Buffer} data The data to frame\\n   * @param {Object} options Options object\\n   * @param {Number} options.opcode The opcode\\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\\n   * @public\\n   */\\n  static frame (data, options) {\\n    const merge = data.length < 1024 || (options.mask && options.readOnly);\\n    var offset = options.mask ? 6 : 2;\\n    var payloadLength = data.length;\\n\\n    if (data.length >= 65536) {\\n      offset += 8;\\n      payloadLength = 127;\\n    } else if (data.length > 125) {\\n      offset += 2;\\n      payloadLength = 126;\\n    }\\n\\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\\n\\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\\n    if (options.rsv1) target[0] |= 0x40;\\n\\n    if (payloadLength === 126) {\\n      target.writeUInt16BE(data.length, 2);\\n    } else if (payloadLength === 127) {\\n      target.writeUInt32BE(0, 2);\\n      target.writeUInt32BE(data.length, 6);\\n    }\\n\\n    if (!options.mask) {\\n      target[1] = payloadLength;\\n      if (merge) {\\n        data.copy(target, offset);\\n        return [target];\\n      }\\n\\n      return [target, data];\\n    }\\n\\n    const mask = crypto.randomBytes(4);\\n\\n    target[1] = payloadLength | 0x80;\\n    target[offset - 4] = mask[0];\\n    target[offset - 3] = mask[1];\\n    target[offset - 2] = mask[2];\\n    target[offset - 1] = mask[3];\\n\\n    if (merge) {\\n      bufferUtil.mask(data, mask, target, offset, data.length);\\n      return [target];\\n    }\\n\\n    bufferUtil.mask(data, mask, data, 0, data.length);\\n    return [target, data];\\n  }\\n\\n  /**\\n   * Sends a close message to the other peer.\\n   *\\n   * @param {(Number|undefined)} code The status code component of the body\\n   * @param {String} data The message component of the body\\n   * @param {Boolean} mask Specifies whether or not to mask the message\\n   * @param {Function} cb Callback\\n   * @public\\n   */\\n  close (code, data, mask, cb) {\\n    var buf;\\n\\n    if (code === undefined) {\\n      buf = constants.EMPTY_BUFFER;\\n    } else if (typeof code !== 'number' || !validation.isValidStatusCode(code)) {\\n      throw new TypeError('First argument must be a valid error code number');\\n    } else if (data === undefined || data === '') {\\n      buf = Buffer.allocUnsafe(2);\\n      buf.writeUInt16BE(code, 0);\\n    } else {\\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\\n      buf.writeUInt16BE(code, 0);\\n      buf.write(data, 2);\\n    }\\n\\n    if (this._deflating) {\\n      this.enqueue([this.doClose, buf, mask, cb]);\\n    } else {\\n      this.doClose(buf, mask, cb);\\n    }\\n  }\\n\\n  /**\\n   * Frames and sends a close message.\\n   *\\n   * @param {Buffer} data The message to send\\n   * @param {Boolean} mask Specifies whether or not to mask `data`\\n   * @param {Function} cb Callback\\n   * @private\\n   */\\n  doClose (data, mask, cb) {\\n    this.sendFrame(Sender.frame(data, {\\n      fin: true,\\n      rsv1: false,\\n      opcode: 0x08,\\n      mask,\\n      readOnly: false\\n    }), cb);\\n  }\\n\\n  /**\\n   * Sends a ping message to the other peer.\\n   *\\n   * @param {*} data The message to send\\n   * @param {Boolean} mask Specifies whether or not to mask `data`\\n   * @param {Function} cb Callback\\n   * @public\\n   */\\n  ping (data, mask, cb) {\\n    var readOnly = true;\\n\\n    if (!Buffer.isBuffer(data)) {\\n      if (data instanceof ArrayBuffer) {\\n        data = Buffer.from(data);\\n      } else if (ArrayBuffer.isView(data)) {\\n        data = viewToBuffer(data);\\n      } else {\\n        data = Buffer.from(data);\\n        readOnly = false;\\n      }\\n    }\\n\\n    if (this._deflating) {\\n      this.enqueue([this.doPing, data, mask, readOnly, cb]);\\n    } else {\\n      this.doPing(data, mask, readOnly, cb);\\n    }\\n  }\\n\\n  /**\\n   * Frames and sends a ping message.\\n   *\\n   * @param {*} data The message to send\\n   * @param {Boolean} mask Specifies whether or not to mask `data`\\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\\n   * @param {Function} cb Callback\\n   * @private\\n   */\\n  doPing (data, mask, readOnly, cb) {\\n    this.sendFrame(Sender.frame(data, {\\n      fin: true,\\n      rsv1: false,\\n      opcode: 0x09,\\n      mask,\\n      readOnly\\n    }), cb);\\n  }\\n\\n  /**\\n   * Sends a pong message to the other peer.\\n   *\\n   * @param {*} data The message to send\\n   * @param {Boolean} mask Specifies whether or not to mask `data`\\n   * @param {Function} cb Callback\\n   * @public\\n   */\\n  pong (data, mask, cb) {\\n    var readOnly = true;\\n\\n    if (!Buffer.isBuffer(data)) {\\n      if (data instanceof ArrayBuffer) {\\n        data = Buffer.from(data);\\n      } else if (ArrayBuffer.isView(data)) {\\n        data = viewToBuffer(data);\\n      } else {\\n        data = Buffer.from(data);\\n        readOnly = false;\\n      }\\n    }\\n\\n    if (this._deflating) {\\n      this.enqueue([this.doPong, data, mask, readOnly, cb]);\\n    } else {\\n      this.doPong(data, mask, readOnly, cb);\\n    }\\n  }\\n\\n  /**\\n   * Frames and sends a pong message.\\n   *\\n   * @param {*} data The message to send\\n   * @param {Boolean} mask Specifies whether or not to mask `data`\\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\\n   * @param {Function} cb Callback\\n   * @private\\n   */\\n  doPong (data, mask, readOnly, cb) {\\n    this.sendFrame(Sender.frame(data, {\\n      fin: true,\\n      rsv1: false,\\n      opcode: 0x0a,\\n      mask,\\n      readOnly\\n    }), cb);\\n  }\\n\\n  /**\\n   * Sends a data message to the other peer.\\n   *\\n   * @param {*} data The message to send\\n   * @param {Object} options Options object\\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\\n   * @param {Function} cb Callback\\n   * @public\\n   */\\n  send (data, options, cb) {\\n    var opcode = options.binary ? 2 : 1;\\n    var rsv1 = options.compress;\\n    var readOnly = true;\\n\\n    if (!Buffer.isBuffer(data)) {\\n      if (data instanceof ArrayBuffer) {\\n        data = Buffer.from(data);\\n      } else if (ArrayBuffer.isView(data)) {\\n        data = viewToBuffer(data);\\n      } else {\\n        data = Buffer.from(data);\\n        readOnly = false;\\n      }\\n    }\\n\\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\\n\\n    if (this._firstFragment) {\\n      this._firstFragment = false;\\n      if (rsv1 && perMessageDeflate) {\\n        rsv1 = data.length >= perMessageDeflate._threshold;\\n      }\\n      this._compress = rsv1;\\n    } else {\\n      rsv1 = false;\\n      opcode = 0;\\n    }\\n\\n    if (options.fin) this._firstFragment = true;\\n\\n    if (perMessageDeflate) {\\n      const opts = {\\n        fin: options.fin,\\n        rsv1,\\n        opcode,\\n        mask: options.mask,\\n        readOnly\\n      };\\n\\n      if (this._deflating) {\\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\\n      } else {\\n        this.dispatch(data, this._compress, opts, cb);\\n      }\\n    } else {\\n      this.sendFrame(Sender.frame(data, {\\n        fin: options.fin,\\n        rsv1: false,\\n        opcode,\\n        mask: options.mask,\\n        readOnly\\n      }), cb);\\n    }\\n  }\\n\\n  /**\\n   * Dispatches a data message.\\n   *\\n   * @param {Buffer} data The message to send\\n   * @param {Boolean} compress Specifies whether or not to compress `data`\\n   * @param {Object} options Options object\\n   * @param {Number} options.opcode The opcode\\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\\n   * @param {Function} cb Callback\\n   * @private\\n   */\\n  dispatch (data, compress, options, cb) {\\n    if (!compress) {\\n      this.sendFrame(Sender.frame(data, options), cb);\\n      return;\\n    }\\n\\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\\n\\n    this._deflating = true;\\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\\n      options.readOnly = false;\\n      this.sendFrame(Sender.frame(buf, options), cb);\\n      this._deflating = false;\\n      this.dequeue();\\n    });\\n  }\\n\\n  /**\\n   * Executes queued send operations.\\n   *\\n   * @private\\n   */\\n  dequeue () {\\n    while (!this._deflating && this._queue.length) {\\n      const params = this._queue.shift();\\n\\n      this._bufferedBytes -= params[1].length;\\n      params[0].apply(this, params.slice(1));\\n    }\\n  }\\n\\n  /**\\n   * Enqueues a send operation.\\n   *\\n   * @param {Array} params Send operation parameters.\\n   * @private\\n   */\\n  enqueue (params) {\\n    this._bufferedBytes += params[1].length;\\n    this._queue.push(params);\\n  }\\n\\n  /**\\n   * Sends a frame.\\n   *\\n   * @param {Buffer[]} list The frame to send\\n   * @param {Function} cb Callback\\n   * @private\\n   */\\n  sendFrame (list, cb) {\\n    if (list.length === 2) {\\n      this._socket.write(list[0]);\\n      this._socket.write(list[1], cb);\\n    } else {\\n      this._socket.write(list[0], cb);\\n    }\\n  }\\n}\\n\\nmodule.exports = Sender;\\n\\n/**\\n * Converts an `ArrayBuffer` view into a buffer.\\n *\\n * @param {(DataView|TypedArray)} view The view to convert\\n * @return {Buffer} Converted view\\n * @private\\n */\\nfunction viewToBuffer (view) {\\n  const buf = Buffer.from(view.buffer);\\n\\n  if (view.byteLength !== view.buffer.byteLength) {\\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\\n  }\\n\\n  return buf;\\n}\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/lib/sender.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/lib/validation.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\ntry {\\n  const isValidUTF8 = require('utf-8-validate');\\n\\n  exports.isValidUTF8 = typeof isValidUTF8 === 'object'\\n    ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\\n    : isValidUTF8;\\n} catch (e) /* istanbul ignore next */ {\\n  exports.isValidUTF8 = () => true;\\n}\\n\\n/**\\n * Checks if a status code is allowed in a close frame.\\n *\\n * @param {Number} code The status code\\n * @return {Boolean} `true` if the status code is valid, else `false`\\n * @public\\n */\\nexports.isValidStatusCode = (code) => {\\n  return (\\n    (code >= 1000 &&\\n      code <= 1013 &&\\n      code !== 1004 &&\\n      code !== 1005 &&\\n      code !== 1006) ||\\n    (code >= 3000 && code <= 4999)\\n  );\\n};\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/lib/validation.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/lib/websocket-server.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\nconst EventEmitter = require('events');\\nconst crypto = require('crypto');\\nconst http = require('http');\\nconst url = require('url');\\n\\nconst PerMessageDeflate = require('./permessage-deflate');\\nconst extension = require('./extension');\\nconst constants = require('./constants');\\nconst WebSocket = require('./websocket');\\n\\n/**\\n * Class representing a WebSocket server.\\n *\\n * @extends EventEmitter\\n */\\nclass WebSocketServer extends EventEmitter {\\n  /**\\n   * Create a `WebSocketServer` instance.\\n   *\\n   * @param {Object} options Configuration options\\n   * @param {String} options.host The hostname where to bind the server\\n   * @param {Number} options.port The port where to bind the server\\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\\n   * @param {Function} options.verifyClient An hook to reject connections\\n   * @param {Function} options.handleProtocols An hook to handle protocols\\n   * @param {String} options.path Accept only connections matching this path\\n   * @param {Boolean} options.noServer Enable no server mode\\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\\n   * @param {Number} options.maxPayload The maximum allowed message size\\n   * @param {Function} callback A listener for the `listening` event\\n   */\\n  constructor (options, callback) {\\n    super();\\n\\n    options = Object.assign({\\n      maxPayload: 100 * 1024 * 1024,\\n      perMessageDeflate: false,\\n      handleProtocols: null,\\n      clientTracking: true,\\n      verifyClient: null,\\n      noServer: false,\\n      backlog: null, // use default (511 as implemented in net.js)\\n      server: null,\\n      host: null,\\n      path: null,\\n      port: null\\n    }, options);\\n\\n    if (options.port == null && !options.server && !options.noServer) {\\n      throw new TypeError(\\n        'One of the \\\"port\\\", \\\"server\\\", or \\\"noServer\\\" options must be specified'\\n      );\\n    }\\n\\n    if (options.port != null) {\\n      this._server = http.createServer((req, res) => {\\n        const body = http.STATUS_CODES[426];\\n\\n        res.writeHead(426, {\\n          'Content-Length': body.length,\\n          'Content-Type': 'text/plain'\\n        });\\n        res.end(body);\\n      });\\n      this._server.listen(options.port, options.host, options.backlog, callback);\\n    } else if (options.server) {\\n      this._server = options.server;\\n    }\\n\\n    if (this._server) {\\n      this._removeListeners = addListeners(this._server, {\\n        listening: this.emit.bind(this, 'listening'),\\n        error: this.emit.bind(this, 'error'),\\n        upgrade: (req, socket, head) => {\\n          this.handleUpgrade(req, socket, head, (ws) => {\\n            this.emit('connection', ws, req);\\n          });\\n        }\\n      });\\n    }\\n\\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\\n    if (options.clientTracking) this.clients = new Set();\\n    this.options = options;\\n  }\\n\\n  /**\\n   * Returns the bound address, the address family name, and port of the server\\n   * as reported by the operating system if listening on an IP socket.\\n   * If the server is listening on a pipe or UNIX domain socket, the name is\\n   * returned as a string.\\n   *\\n   * @return {(Object|String|null)} The address of the server\\n   * @public\\n   */\\n  address () {\\n    if (this.options.noServer) {\\n      throw new Error('The server is operating in \\\"noServer\\\" mode');\\n    }\\n\\n    if (!this._server) return null;\\n    return this._server.address();\\n  }\\n\\n  /**\\n   * Close the server.\\n   *\\n   * @param {Function} cb Callback\\n   * @public\\n   */\\n  close (cb) {\\n    //\\n    // Terminate all associated clients.\\n    //\\n    if (this.clients) {\\n      for (const client of this.clients) client.terminate();\\n    }\\n\\n    const server = this._server;\\n\\n    if (server) {\\n      this._removeListeners();\\n      this._removeListeners = this._server = null;\\n\\n      //\\n      // Close the http server if it was internally created.\\n      //\\n      if (this.options.port != null) return server.close(cb);\\n    }\\n\\n    if (cb) cb();\\n  }\\n\\n  /**\\n   * See if a given request should be handled by this server instance.\\n   *\\n   * @param {http.IncomingMessage} req Request object to inspect\\n   * @return {Boolean} `true` if the request is valid, else `false`\\n   * @public\\n   */\\n  shouldHandle (req) {\\n    if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\\n      return false;\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * Handle a HTTP Upgrade request.\\n   *\\n   * @param {http.IncomingMessage} req The request object\\n   * @param {net.Socket} socket The network socket between the server and client\\n   * @param {Buffer} head The first packet of the upgraded stream\\n   * @param {Function} cb Callback\\n   * @public\\n   */\\n  handleUpgrade (req, socket, head, cb) {\\n    socket.on('error', socketOnError);\\n\\n    const version = +req.headers['sec-websocket-version'];\\n    const extensions = {};\\n\\n    if (\\n      req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' ||\\n      !req.headers['sec-websocket-key'] || (version !== 8 && version !== 13) ||\\n      !this.shouldHandle(req)\\n    ) {\\n      return abortHandshake(socket, 400);\\n    }\\n\\n    if (this.options.perMessageDeflate) {\\n      const perMessageDeflate = new PerMessageDeflate(\\n        this.options.perMessageDeflate,\\n        true,\\n        this.options.maxPayload\\n      );\\n\\n      try {\\n        const offers = extension.parse(\\n          req.headers['sec-websocket-extensions']\\n        );\\n\\n        if (offers[PerMessageDeflate.extensionName]) {\\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\\n        }\\n      } catch (err) {\\n        return abortHandshake(socket, 400);\\n      }\\n    }\\n\\n    //\\n    // Optionally call external client verification handler.\\n    //\\n    if (this.options.verifyClient) {\\n      const info = {\\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\\n        secure: !!(req.connection.authorized || req.connection.encrypted),\\n        req\\n      };\\n\\n      if (this.options.verifyClient.length === 2) {\\n        this.options.verifyClient(info, (verified, code, message, headers) => {\\n          if (!verified) {\\n            return abortHandshake(socket, code || 401, message, headers);\\n          }\\n\\n          this.completeUpgrade(extensions, req, socket, head, cb);\\n        });\\n        return;\\n      }\\n\\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\\n    }\\n\\n    this.completeUpgrade(extensions, req, socket, head, cb);\\n  }\\n\\n  /**\\n   * Upgrade the connection to WebSocket.\\n   *\\n   * @param {Object} extensions The accepted extensions\\n   * @param {http.IncomingMessage} req The request object\\n   * @param {net.Socket} socket The network socket between the server and client\\n   * @param {Buffer} head The first packet of the upgraded stream\\n   * @param {Function} cb Callback\\n   * @private\\n   */\\n  completeUpgrade (extensions, req, socket, head, cb) {\\n    //\\n    // Destroy the socket if the client has already sent a FIN packet.\\n    //\\n    if (!socket.readable || !socket.writable) return socket.destroy();\\n\\n    const key = crypto.createHash('sha1')\\n      .update(req.headers['sec-websocket-key'] + constants.GUID, 'binary')\\n      .digest('base64');\\n\\n    const headers = [\\n      'HTTP/1.1 101 Switching Protocols',\\n      'Upgrade: websocket',\\n      'Connection: Upgrade',\\n      `Sec-WebSocket-Accept: ${key}`\\n    ];\\n\\n    const ws = new WebSocket(null);\\n    var protocol = req.headers['sec-websocket-protocol'];\\n\\n    if (protocol) {\\n      protocol = protocol.trim().split(/ *, */);\\n\\n      //\\n      // Optionally call external protocol selection handler.\\n      //\\n      if (this.options.handleProtocols) {\\n        protocol = this.options.handleProtocols(protocol, req);\\n      } else {\\n        protocol = protocol[0];\\n      }\\n\\n      if (protocol) {\\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\\n        ws.protocol = protocol;\\n      }\\n    }\\n\\n    if (extensions[PerMessageDeflate.extensionName]) {\\n      const params = extensions[PerMessageDeflate.extensionName].params;\\n      const value = extension.format({\\n        [PerMessageDeflate.extensionName]: [params]\\n      });\\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\\n      ws._extensions = extensions;\\n    }\\n\\n    //\\n    // Allow external modification/inspection of handshake headers.\\n    //\\n    this.emit('headers', headers, req);\\n\\n    socket.write(headers.concat('\\\\r\\\\n').join('\\\\r\\\\n'));\\n    socket.removeListener('error', socketOnError);\\n\\n    ws.setSocket(socket, head, this.options.maxPayload);\\n\\n    if (this.clients) {\\n      this.clients.add(ws);\\n      ws.on('close', () => this.clients.delete(ws));\\n    }\\n\\n    cb(ws);\\n  }\\n}\\n\\nmodule.exports = WebSocketServer;\\n\\n/**\\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\\n * pairs.\\n *\\n * @param {EventEmitter} server The event emitter\\n * @param {Object.<String, Function>} map The listeners to add\\n * @return {Function} A function that will remove the added listeners when called\\n * @private\\n */\\nfunction addListeners (server, map) {\\n  for (const event of Object.keys(map)) server.on(event, map[event]);\\n\\n  return function removeListeners () {\\n    for (const event of Object.keys(map)) {\\n      server.removeListener(event, map[event]);\\n    }\\n  };\\n}\\n\\n/**\\n * Handle premature socket errors.\\n *\\n * @private\\n */\\nfunction socketOnError () {\\n  this.destroy();\\n}\\n\\n/**\\n * Close the connection when preconditions are not fulfilled.\\n *\\n * @param {net.Socket} socket The socket of the upgrade request\\n * @param {Number} code The HTTP response status code\\n * @param {String} [message] The HTTP response body\\n * @param {Object} [headers] Additional HTTP response headers\\n * @private\\n */\\nfunction abortHandshake (socket, code, message, headers) {\\n  if (socket.writable) {\\n    message = message || http.STATUS_CODES[code];\\n    headers = Object.assign({\\n      'Connection': 'close',\\n      'Content-type': 'text/html',\\n      'Content-Length': Buffer.byteLength(message)\\n    }, headers);\\n\\n    socket.write(\\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\\\r\\\\n` +\\n      Object.keys(headers).map(h => `${h}: ${headers[h]}`).join('\\\\r\\\\n') +\\n      '\\\\r\\\\n\\\\r\\\\n' +\\n      message\\n    );\\n  }\\n\\n  socket.removeListener('error', socketOnError);\\n  socket.destroy();\\n}\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/lib/websocket-server.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/WS/lib/websocket.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\nconst EventEmitter = require('events');\\nconst crypto = require('crypto');\\nconst https = require('https');\\nconst http = require('http');\\nconst net = require('net');\\nconst tls = require('tls');\\nconst url = require('url');\\n\\nconst PerMessageDeflate = require('./permessage-deflate');\\nconst EventTarget = require('./event-target');\\nconst extension = require('./extension');\\nconst constants = require('./constants');\\nconst Receiver = require('./receiver');\\nconst Sender = require('./sender');\\n\\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\\nconst kWebSocket = constants.kWebSocket;\\nconst protocolVersions = [8, 13];\\nconst closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.\\n\\n/**\\n * Class representing a WebSocket.\\n *\\n * @extends EventEmitter\\n */\\nclass WebSocket extends EventEmitter {\\n  /**\\n   * Create a new `WebSocket`.\\n   *\\n   * @param {(String|url.Url|url.URL)} address The URL to which to connect\\n   * @param {(String|String[])} protocols The subprotocols\\n   * @param {Object} options Connection options\\n   */\\n  constructor (address, protocols, options) {\\n    super();\\n\\n    this.readyState = WebSocket.CONNECTING;\\n    this.protocol = '';\\n\\n    this._binaryType = constants.BINARY_TYPES[0];\\n    this._closeFrameReceived = false;\\n    this._closeFrameSent = false;\\n    this._closeMessage = '';\\n    this._closeTimer = null;\\n    this._closeCode = 1006;\\n    this._extensions = {};\\n    this._isServer = true;\\n    this._receiver = null;\\n    this._sender = null;\\n    this._socket = null;\\n\\n    if (address !== null) {\\n      if (Array.isArray(protocols)) {\\n        protocols = protocols.join(', ');\\n      } else if (typeof protocols === 'object' && protocols !== null) {\\n        options = protocols;\\n        protocols = undefined;\\n      }\\n\\n      initAsClient.call(this, address, protocols, options);\\n    }\\n  }\\n\\n  get CONNECTING () { return WebSocket.CONNECTING; }\\n  get CLOSING () { return WebSocket.CLOSING; }\\n  get CLOSED () { return WebSocket.CLOSED; }\\n  get OPEN () { return WebSocket.OPEN; }\\n\\n  /**\\n   * This deviates from the WHATWG interface since ws doesn't support the required\\n   * default \\\"blob\\\" type (instead we define a custom \\\"nodebuffer\\\" type).\\n   *\\n   * @type {String}\\n   */\\n  get binaryType () {\\n    return this._binaryType;\\n  }\\n\\n  set binaryType (type) {\\n    if (constants.BINARY_TYPES.indexOf(type) < 0) return;\\n\\n    this._binaryType = type;\\n\\n    //\\n    // Allow to change `binaryType` on the fly.\\n    //\\n    if (this._receiver) this._receiver._binaryType = type;\\n  }\\n\\n  /**\\n   * @type {Number}\\n   */\\n  get bufferedAmount () {\\n    if (!this._socket) return 0;\\n\\n    //\\n    // `socket.bufferSize` is `undefined` if the socket is closed.\\n    //\\n    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;\\n  }\\n\\n  /**\\n   * @type {String}\\n   */\\n  get extensions () {\\n    return Object.keys(this._extensions).join();\\n  }\\n\\n  /**\\n   * Set up the socket and the internal resources.\\n   *\\n   * @param {net.Socket} socket The network socket between the server and client\\n   * @param {Buffer} head The first packet of the upgraded stream\\n   * @param {Number} maxPayload The maximum allowed message size\\n   * @private\\n   */\\n  setSocket (socket, head, maxPayload) {\\n    const receiver = new Receiver(\\n      this._binaryType,\\n      this._extensions,\\n      maxPayload\\n    );\\n\\n    this._sender = new Sender(socket, this._extensions);\\n    this._receiver = receiver;\\n    this._socket = socket;\\n\\n    receiver[kWebSocket] = this;\\n    socket[kWebSocket] = this;\\n\\n    receiver.on('conclude', receiverOnConclude);\\n    receiver.on('drain', receiverOnDrain);\\n    receiver.on('error', receiverOnError);\\n    receiver.on('message', receiverOnMessage);\\n    receiver.on('ping', receiverOnPing);\\n    receiver.on('pong', receiverOnPong);\\n\\n    socket.setTimeout(0);\\n    socket.setNoDelay();\\n\\n    if (head.length > 0) socket.unshift(head);\\n\\n    socket.on('close', socketOnClose);\\n    socket.on('data', socketOnData);\\n    socket.on('end', socketOnEnd);\\n    socket.on('error', socketOnError);\\n\\n    this.readyState = WebSocket.OPEN;\\n    this.emit('open');\\n  }\\n\\n  /**\\n   * Emit the `'close'` event.\\n   *\\n   * @private\\n   */\\n  emitClose () {\\n    this.readyState = WebSocket.CLOSED;\\n\\n    if (!this._socket) {\\n      this.emit('close', this._closeCode, this._closeMessage);\\n      return;\\n    }\\n\\n    if (this._extensions[PerMessageDeflate.extensionName]) {\\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\\n    }\\n\\n    this._receiver.removeAllListeners();\\n    this.emit('close', this._closeCode, this._closeMessage);\\n  }\\n\\n  /**\\n   * Start a closing handshake.\\n   *\\n   *          +----------+   +-----------+   +----------+\\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\\n   *    |     +----------+   +-----------+   +----------+     |\\n   *          +----------+   +-----------+         |\\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\\n   *          +----------+   +-----------+   |\\n   *    |           |                        |   +---+        |\\n   *                +------------------------+-->|fin| - - - -\\n   *    |         +---+                      |   +---+\\n   *     - - - - -|fin|<---------------------+\\n   *              +---+\\n   *\\n   * @param {Number} code Status code explaining why the connection is closing\\n   * @param {String} data A string explaining why the connection is closing\\n   * @public\\n   */\\n  close (code, data) {\\n    if (this.readyState === WebSocket.CLOSED) return;\\n    if (this.readyState === WebSocket.CONNECTING) {\\n      const msg = 'WebSocket was closed before the connection was established';\\n      return abortHandshake(this, this._req, msg);\\n    }\\n\\n    if (this.readyState === WebSocket.CLOSING) {\\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\\n      return;\\n    }\\n\\n    this.readyState = WebSocket.CLOSING;\\n    this._sender.close(code, data, !this._isServer, (err) => {\\n      //\\n      // This error is handled by the `'error'` listener on the socket. We only\\n      // want to know if the close frame has been sent here.\\n      //\\n      if (err) return;\\n\\n      this._closeFrameSent = true;\\n\\n      if (this._socket.writable) {\\n        if (this._closeFrameReceived) this._socket.end();\\n\\n        //\\n        // Ensure that the connection is closed even if the closing handshake\\n        // fails.\\n        //\\n        this._closeTimer = setTimeout(\\n          this._socket.destroy.bind(this._socket),\\n          closeTimeout\\n        );\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Send a ping.\\n   *\\n   * @param {*} data The data to send\\n   * @param {Boolean} mask Indicates whether or not to mask `data`\\n   * @param {Function} cb Callback which is executed when the ping is sent\\n   * @public\\n   */\\n  ping (data, mask, cb) {\\n    if (typeof data === 'function') {\\n      cb = data;\\n      data = mask = undefined;\\n    } else if (typeof mask === 'function') {\\n      cb = mask;\\n      mask = undefined;\\n    }\\n\\n    if (this.readyState !== WebSocket.OPEN) {\\n      const err = new Error(\\n        `WebSocket is not open: readyState ${this.readyState} ` +\\n          `(${readyStates[this.readyState]})`\\n      );\\n\\n      if (cb) return cb(err);\\n      throw err;\\n    }\\n\\n    if (typeof data === 'number') data = data.toString();\\n    if (mask === undefined) mask = !this._isServer;\\n    this._sender.ping(data || constants.EMPTY_BUFFER, mask, cb);\\n  }\\n\\n  /**\\n   * Send a pong.\\n   *\\n   * @param {*} data The data to send\\n   * @param {Boolean} mask Indicates whether or not to mask `data`\\n   * @param {Function} cb Callback which is executed when the pong is sent\\n   * @public\\n   */\\n  pong (data, mask, cb) {\\n    if (typeof data === 'function') {\\n      cb = data;\\n      data = mask = undefined;\\n    } else if (typeof mask === 'function') {\\n      cb = mask;\\n      mask = undefined;\\n    }\\n\\n    if (this.readyState !== WebSocket.OPEN) {\\n      const err = new Error(\\n        `WebSocket is not open: readyState ${this.readyState} ` +\\n          `(${readyStates[this.readyState]})`\\n      );\\n\\n      if (cb) return cb(err);\\n      throw err;\\n    }\\n\\n    if (typeof data === 'number') data = data.toString();\\n    if (mask === undefined) mask = !this._isServer;\\n    this._sender.pong(data || constants.EMPTY_BUFFER, mask, cb);\\n  }\\n\\n  /**\\n   * Send a data message.\\n   *\\n   * @param {*} data The message to send\\n   * @param {Object} options Options object\\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\\n   * @param {Function} cb Callback which is executed when data is written out\\n   * @public\\n   */\\n  send (data, options, cb) {\\n    if (typeof options === 'function') {\\n      cb = options;\\n      options = {};\\n    }\\n\\n    if (this.readyState !== WebSocket.OPEN) {\\n      const err = new Error(\\n        `WebSocket is not open: readyState ${this.readyState} ` +\\n          `(${readyStates[this.readyState]})`\\n      );\\n\\n      if (cb) return cb(err);\\n      throw err;\\n    }\\n\\n    if (typeof data === 'number') data = data.toString();\\n\\n    const opts = Object.assign({\\n      binary: typeof data !== 'string',\\n      mask: !this._isServer,\\n      compress: true,\\n      fin: true\\n    }, options);\\n\\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\\n      opts.compress = false;\\n    }\\n\\n    this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);\\n  }\\n\\n  /**\\n   * Forcibly close the connection.\\n   *\\n   * @public\\n   */\\n  terminate () {\\n    if (this.readyState === WebSocket.CLOSED) return;\\n    if (this.readyState === WebSocket.CONNECTING) {\\n      const msg = 'WebSocket was closed before the connection was established';\\n      return abortHandshake(this, this._req, msg);\\n    }\\n\\n    if (this._socket) {\\n      this.readyState = WebSocket.CLOSING;\\n      this._socket.destroy();\\n    }\\n  }\\n}\\n\\nreadyStates.forEach((readyState, i) => {\\n  WebSocket[readyStates[i]] = i;\\n});\\n\\n//\\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\\n//\\n['open', 'error', 'close', 'message'].forEach((method) => {\\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\\n    /**\\n     * Return the listener of the event.\\n     *\\n     * @return {(Function|undefined)} The event listener or `undefined`\\n     * @public\\n     */\\n    get () {\\n      const listeners = this.listeners(method);\\n      for (var i = 0; i < listeners.length; i++) {\\n        if (listeners[i]._listener) return listeners[i]._listener;\\n      }\\n    },\\n    /**\\n     * Add a listener for the event.\\n     *\\n     * @param {Function} listener The listener to add\\n     * @public\\n     */\\n    set (listener) {\\n      const listeners = this.listeners(method);\\n      for (var i = 0; i < listeners.length; i++) {\\n        //\\n        // Remove only the listeners added via `addEventListener`.\\n        //\\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\\n      }\\n      this.addEventListener(method, listener);\\n    }\\n  });\\n});\\n\\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\\n\\nmodule.exports = WebSocket;\\n\\n/**\\n * Initialize a WebSocket client.\\n *\\n * @param {(String|url.Url|url.URL)} address The URL to which to connect\\n * @param {String} protocols The subprotocols\\n * @param {Object} options Connection options\\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request\\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header\\n * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header\\n * @param {Number} options.maxPayload The maximum allowed message size\\n * @private\\n */\\nfunction initAsClient (address, protocols, options) {\\n  options = Object.assign({\\n    protocolVersion: protocolVersions[1],\\n    perMessageDeflate: true,\\n    maxPayload: 100 * 1024 * 1024\\n  }, options, {\\n    createConnection: undefined,\\n    socketPath: undefined,\\n    hostname: undefined,\\n    protocol: undefined,\\n    timeout: undefined,\\n    method: undefined,\\n    auth: undefined,\\n    host: undefined,\\n    path: undefined,\\n    port: undefined\\n  });\\n\\n  if (protocolVersions.indexOf(options.protocolVersion) === -1) {\\n    throw new RangeError(\\n      `Unsupported protocol version: ${options.protocolVersion} ` +\\n        `(supported versions: ${protocolVersions.join(', ')})`\\n    );\\n  }\\n\\n  this._isServer = false;\\n\\n  var parsedUrl;\\n\\n  if (typeof address === 'object' && address.href !== undefined) {\\n    parsedUrl = address;\\n    this.url = address.href;\\n  } else {\\n    parsedUrl = url.parse(address);\\n    this.url = address;\\n  }\\n\\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\\n\\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\\n    throw new Error(`Invalid URL: ${this.url}`);\\n  }\\n\\n  const isSecure = parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\\n  const key = crypto.randomBytes(16).toString('base64');\\n  const httpObj = isSecure ? https : http;\\n  const path = parsedUrl.search\\n    ? `${parsedUrl.pathname || '/'}${parsedUrl.search}`\\n    : parsedUrl.pathname || '/';\\n  var perMessageDeflate;\\n\\n  options.createConnection = isSecure ? tlsConnect : netConnect;\\n  options.port = parsedUrl.port || (isSecure ? 443 : 80);\\n  options.host = parsedUrl.hostname.startsWith('[')\\n    ? parsedUrl.hostname.slice(1, -1)\\n    : parsedUrl.hostname;\\n  options.headers = Object.assign({\\n    'Sec-WebSocket-Version': options.protocolVersion,\\n    'Sec-WebSocket-Key': key,\\n    'Connection': 'Upgrade',\\n    'Upgrade': 'websocket'\\n  }, options.headers);\\n  options.path = path;\\n\\n  if (options.perMessageDeflate) {\\n    perMessageDeflate = new PerMessageDeflate(\\n      options.perMessageDeflate !== true ? options.perMessageDeflate : {},\\n      false,\\n      options.maxPayload\\n    );\\n    options.headers['Sec-WebSocket-Extensions'] = extension.format({\\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\\n    });\\n  }\\n  if (protocols) {\\n    options.headers['Sec-WebSocket-Protocol'] = protocols;\\n  }\\n  if (options.origin) {\\n    if (options.protocolVersion < 13) {\\n      options.headers['Sec-WebSocket-Origin'] = options.origin;\\n    } else {\\n      options.headers.Origin = options.origin;\\n    }\\n  }\\n  if (parsedUrl.auth) {\\n    options.auth = parsedUrl.auth;\\n  } else if (parsedUrl.username || parsedUrl.password) {\\n    options.auth = `${parsedUrl.username}:${parsedUrl.password}`;\\n  }\\n\\n  if (isUnixSocket) {\\n    const parts = path.split(':');\\n\\n    options.socketPath = parts[0];\\n    options.path = parts[1];\\n  }\\n\\n  var req = this._req = httpObj.get(options);\\n\\n  if (options.handshakeTimeout) {\\n    req.setTimeout(\\n      options.handshakeTimeout,\\n      () => abortHandshake(this, req, 'Opening handshake has timed out')\\n    );\\n  }\\n\\n  req.on('error', (err) => {\\n    if (this._req.aborted) return;\\n\\n    req = this._req = null;\\n    this.readyState = WebSocket.CLOSING;\\n    this.emit('error', err);\\n    this.emitClose();\\n  });\\n\\n  req.on('response', (res) => {\\n    if (this.emit('unexpected-response', req, res)) return;\\n\\n    abortHandshake(this, req, `Unexpected server response: ${res.statusCode}`);\\n  });\\n\\n  req.on('upgrade', (res, socket, head) => {\\n    this.emit('upgrade', res);\\n\\n    //\\n    // The user may have closed the connection from a listener of the `upgrade`\\n    // event.\\n    //\\n    if (this.readyState !== WebSocket.CONNECTING) return;\\n\\n    req = this._req = null;\\n\\n    const digest = crypto.createHash('sha1')\\n      .update(key + constants.GUID, 'binary')\\n      .digest('base64');\\n\\n    if (res.headers['sec-websocket-accept'] !== digest) {\\n      abortHandshake(this, socket, 'Invalid Sec-WebSocket-Accept header');\\n      return;\\n    }\\n\\n    const serverProt = res.headers['sec-websocket-protocol'];\\n    const protList = (protocols || '').split(/, */);\\n    var protError;\\n\\n    if (!protocols && serverProt) {\\n      protError = 'Server sent a subprotocol but none was requested';\\n    } else if (protocols && !serverProt) {\\n      protError = 'Server sent no subprotocol';\\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\\n      protError = 'Server sent an invalid subprotocol';\\n    }\\n\\n    if (protError) {\\n      abortHandshake(this, socket, protError);\\n      return;\\n    }\\n\\n    if (serverProt) this.protocol = serverProt;\\n\\n    if (perMessageDeflate) {\\n      try {\\n        const extensions = extension.parse(\\n          res.headers['sec-websocket-extensions']\\n        );\\n\\n        if (extensions[PerMessageDeflate.extensionName]) {\\n          perMessageDeflate.accept(\\n            extensions[PerMessageDeflate.extensionName]\\n          );\\n          this._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\\n        }\\n      } catch (err) {\\n        abortHandshake(this, socket, 'Invalid Sec-WebSocket-Extensions header');\\n        return;\\n      }\\n    }\\n\\n    this.setSocket(socket, head, options.maxPayload);\\n  });\\n}\\n\\n/**\\n * Create a `net.Socket` and initiate a connection.\\n *\\n * @param {Object} options Connection options\\n * @return {net.Socket} The newly created socket used to start the connection\\n * @private\\n */\\nfunction netConnect (options) {\\n  //\\n  // Override `options.path` only if `options` is a copy of the original options\\n  // object. This is always true on Node.js >= 8 but not on Node.js 6 where\\n  // `options.socketPath` might be `undefined` even if the `socketPath` option\\n  // was originally set.\\n  //\\n  if (options.protocolVersion) options.path = options.socketPath;\\n  return net.connect(options);\\n}\\n\\n/**\\n * Create a `tls.TLSSocket` and initiate a connection.\\n *\\n * @param {Object} options Connection options\\n * @return {tls.TLSSocket} The newly created socket used to start the connection\\n * @private\\n */\\nfunction tlsConnect (options) {\\n  options.path = undefined;\\n  options.servername = options.servername || options.host;\\n  return tls.connect(options);\\n}\\n\\n/**\\n * Abort the handshake and emit an error.\\n *\\n * @param {WebSocket} websocket The WebSocket instance\\n * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the\\n *     socket to destroy\\n * @param {String} message The error message\\n * @private\\n */\\nfunction abortHandshake (websocket, stream, message) {\\n  websocket.readyState = WebSocket.CLOSING;\\n\\n  const err = new Error(message);\\n  Error.captureStackTrace(err, abortHandshake);\\n\\n  if (stream.setHeader) {\\n    stream.abort();\\n    stream.once('abort', websocket.emitClose.bind(websocket));\\n    websocket.emit('error', err);\\n  } else {\\n    stream.destroy(err);\\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\\n    stream.once('close', websocket.emitClose.bind(websocket));\\n  }\\n}\\n\\n/**\\n * The listener of the `Receiver` `'conclude'` event.\\n *\\n * @param {Number} code The status code\\n * @param {String} reason The reason for closing\\n * @private\\n */\\nfunction receiverOnConclude (code, reason) {\\n  const websocket = this[kWebSocket];\\n\\n  websocket._socket.removeListener('data', socketOnData);\\n  websocket._socket.resume();\\n\\n  websocket._closeFrameReceived = true;\\n  websocket._closeMessage = reason;\\n  websocket._closeCode = code;\\n\\n  if (code === 1005) websocket.close();\\n  else websocket.close(code, reason);\\n}\\n\\n/**\\n * The listener of the `Receiver` `'drain'` event.\\n *\\n * @private\\n */\\nfunction receiverOnDrain () {\\n  this[kWebSocket]._socket.resume();\\n}\\n\\n/**\\n * The listener of the `Receiver` `'error'` event.\\n *\\n * @param {(RangeError|Error)} err The emitted error\\n * @private\\n */\\nfunction receiverOnError (err) {\\n  const websocket = this[kWebSocket];\\n\\n  websocket._socket.removeListener('data', socketOnData);\\n\\n  websocket.readyState = WebSocket.CLOSING;\\n  websocket._closeCode = err[constants.kStatusCode];\\n  websocket.emit('error', err);\\n  websocket._socket.destroy();\\n}\\n\\n/**\\n * The listener of the `Receiver` `'finish'` event.\\n *\\n * @private\\n */\\nfunction receiverOnFinish () {\\n  this[kWebSocket].emitClose();\\n}\\n\\n/**\\n * The listener of the `Receiver` `'message'` event.\\n *\\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\\n * @private\\n */\\nfunction receiverOnMessage (data) {\\n  this[kWebSocket].emit('message', data);\\n}\\n\\n/**\\n * The listener of the `Receiver` `'ping'` event.\\n *\\n * @param {Buffer} data The data included in the ping frame\\n * @private\\n */\\nfunction receiverOnPing (data) {\\n  const websocket = this[kWebSocket];\\n\\n  websocket.pong(data, !websocket._isServer, constants.NOOP);\\n  websocket.emit('ping', data);\\n}\\n\\n/**\\n * The listener of the `Receiver` `'pong'` event.\\n *\\n * @param {Buffer} data The data included in the pong frame\\n * @private\\n */\\nfunction receiverOnPong (data) {\\n  this[kWebSocket].emit('pong', data);\\n}\\n\\n/**\\n * The listener of the `net.Socket` `'close'` event.\\n *\\n * @private\\n */\\nfunction socketOnClose () {\\n  const websocket = this[kWebSocket];\\n\\n  this.removeListener('close', socketOnClose);\\n  this.removeListener('end', socketOnEnd);\\n\\n  websocket.readyState = WebSocket.CLOSING;\\n\\n  //\\n  // The close frame might not have been received or the `'end'` event emitted,\\n  // for example, if the socket was destroyed due to an error. Ensure that the\\n  // `receiver` stream is closed after writing any remaining buffered data to\\n  // it. If the readable side of the socket is in flowing mode then there is no\\n  // buffered data as everything has been already written and `readable.read()`\\n  // will return `null`. If instead, the socket is paused, any possible buffered\\n  // data will be read as a single chunk and emitted synchronously in a single\\n  // `'data'` event.\\n  //\\n  websocket._socket.read();\\n  websocket._receiver.end();\\n\\n  this.removeListener('data', socketOnData);\\n  this[kWebSocket] = undefined;\\n\\n  clearTimeout(websocket._closeTimer);\\n\\n  if (\\n    websocket._receiver._writableState.finished ||\\n    websocket._receiver._writableState.errorEmitted\\n  ) {\\n    websocket.emitClose();\\n  } else {\\n    websocket._receiver.on('error', receiverOnFinish);\\n    websocket._receiver.on('finish', receiverOnFinish);\\n  }\\n}\\n\\n/**\\n * The listener of the `net.Socket` `'data'` event.\\n *\\n * @param {Buffer} chunk A chunk of data\\n * @private\\n */\\nfunction socketOnData (chunk) {\\n  if (!this[kWebSocket]._receiver.write(chunk)) {\\n    this.pause();\\n  }\\n}\\n\\n/**\\n * The listener of the `net.Socket` `'end'` event.\\n *\\n * @private\\n */\\nfunction socketOnEnd () {\\n  const websocket = this[kWebSocket];\\n\\n  websocket.readyState = WebSocket.CLOSING;\\n  websocket._receiver.end();\\n  this.end();\\n}\\n\\n/**\\n * The listener of the `net.Socket` `'error'` event.\\n *\\n * @private\\n */\\nfunction socketOnError () {\\n  const websocket = this[kWebSocket];\\n\\n  this.removeListener('error', socketOnError);\\n  this.on('error', constants.NOOP);\\n\\n  if (websocket) {\\n    websocket.readyState = WebSocket.CLOSING;\\n    this.destroy();\\n  }\\n}\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/WS/lib/websocket.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/async-limiter/async-limiter.js\": {\n            \"text\": \"(function(){\\n'use strict';\\n\\nfunction Queue(options) {\\n  if (!(this instanceof Queue)) {\\n    return new Queue(options);\\n  }\\n\\n  options = options || {};\\n  this.concurrency = options.concurrency || Infinity;\\n  this.pending = 0;\\n  this.jobs = [];\\n  this.cbs = [];\\n  this._done = done.bind(this);\\n}\\n\\nvar arrayAddMethods = [\\n  'push',\\n  'unshift',\\n  'splice'\\n];\\n\\narrayAddMethods.forEach(function(method) {\\n  Queue.prototype[method] = function() {\\n    var methodResult = Array.prototype[method].apply(this.jobs, arguments);\\n    this._run();\\n    return methodResult;\\n  };\\n});\\n\\nObject.defineProperty(Queue.prototype, 'length', {\\n  get: function() {\\n    return this.pending + this.jobs.length;\\n  }\\n});\\n\\nQueue.prototype._run = function() {\\n  if (this.pending === this.concurrency) {\\n    return;\\n  }\\n  if (this.jobs.length) {\\n    var job = this.jobs.shift();\\n    this.pending++;\\n    job(this._done);\\n    this._run();\\n  }\\n\\n  if (this.pending === 0) {\\n    while (this.cbs.length !== 0) {\\n      var cb = this.cbs.pop();\\n      process.nextTick(cb);\\n    }\\n  }\\n};\\n\\nQueue.prototype.onDone = function(cb) {\\n  if (typeof cb === 'function') {\\n    this.cbs.push(cb);\\n    this._run();\\n  }\\n};\\n\\nfunction done() {\\n  this.pending--;\\n  this._run();\\n}\\n\\nmodule.exports = Queue;\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/async-limiter/async-limiter.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/async-limiter/README\": {\n            \"text\": \"# Async-Limiter\\n\\nA module for limiting concurrent asynchronous actions in flight. Forked from [queue](https://github.com/jessetane/queue).\\n\\n[![npm](http://img.shields.io/npm/v/async-limiter.svg?style=flat-square)](http://www.npmjs.org/async-limiter)\\n[![tests](https://img.shields.io/travis/STRML/async-limiter.svg?style=flat-square&branch=master)](https://travis-ci.org/STRML/async-limiter)\\n[![coverage](https://img.shields.io/coveralls/STRML/async-limiter.svg?style=flat-square&branch=master)](https://coveralls.io/r/STRML/async-limiter)\\n\\nThis module exports a class `Limiter` that implements some of the `Array` API.\\nPass async functions (ones that accept a callback or return a promise) to an instance's additive array methods.\\n\\n## Motivation\\n\\nCertain functions, like `zlib`, have [undesirable behavior](https://github.com/nodejs/node/issues/8871#issuecomment-250915913) when\\nrun at infinite concurrency.\\n\\nIn this case, it is actually faster, and takes far less memory, to limit concurrency.\\n\\nThis module should do the absolute minimum work necessary to queue up functions. PRs are welcome that would\\nmake this module faster or lighter, but new functionality is not desired.\\n\\nStyle should confirm to nodejs/node style.\\n\\n## Example\\n\\n``` javascript\\nvar Limiter = require('async-limiter')\\n\\nvar t = new Limiter({concurrency: 2});\\nvar results = []\\n\\n// add jobs using the familiar Array API\\nt.push(function (cb) {\\n  results.push('two')\\n  cb()\\n})\\n\\nt.push(\\n  function (cb) {\\n    results.push('four')\\n    cb()\\n  },\\n  function (cb) {\\n    results.push('five')\\n    cb()\\n  }\\n)\\n\\nt.unshift(function (cb) {\\n  results.push('one')\\n  cb()\\n})\\n\\nt.splice(2, 0, function (cb) {\\n  results.push('three')\\n  cb()\\n})\\n\\n// Jobs run automatically. If you want a callback when all are done,\\n// call 'onDone()'.\\nt.onDone(function () {\\n  console.log('all done:', results)\\n})\\n```\\n\\n## Zlib Example\\n\\n```js\\nconst zlib = require('zlib');\\nconst Limiter = require('async-limiter');\\n\\nconst message = {some: \\\"data\\\"};\\nconst payload = new Buffer(JSON.stringify(message));\\n\\n// Try with different concurrency values to see how this actually\\n// slows significantly with higher concurrency!\\n//\\n// 5:        1398.607ms\\n// 10:       1375.668ms\\n// Infinity: 4423.300ms\\n//\\nconst t = new Limiter({concurrency: 5});\\nfunction deflate(payload, cb) {\\n  t.push(function(done) {\\n    zlib.deflate(payload, function(err, buffer) {\\n      done();\\n      cb(err, buffer);\\n    });\\n  });\\n}\\n\\nconsole.time('deflate');\\nfor(let i = 0; i < 30000; ++i) {\\n  deflate(payload, function (err, buffer) {});\\n}\\nq.onDone(function() {\\n  console.timeEnd('deflate');\\n});\\n```\\n\\n## Install\\n\\n`npm install async-limiter`\\n\\n## Test\\n\\n`npm test`\\n\\n## API\\n\\n### `var t = new Limiter([opts])`\\nConstructor. `opts` may contain inital values for:\\n* `q.concurrency`\\n\\n## Instance methods\\n\\n### `q.onDone(fn)`\\n`fn` will be called once and only once, when the queue is empty.\\n\\n## Instance methods mixed in from `Array`\\nMozilla has docs on how these methods work [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).\\n### `q.push(element1, ..., elementN)`\\n### `q.unshift(element1, ..., elementN)`\\n### `q.splice(index , howMany[, element1[, ...[, elementN]]])`\\n\\n## Properties\\n### `q.concurrency`\\nMax number of jobs the queue should process concurrently, defaults to `Infinity`.\\n\\n### `q.length`\\nJobs pending + jobs to process (readonly).\\n\\n\",\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/async-limiter/README\"\n        },\n        \"$:/plugins/OokTech/Bob/External/async-limiter/LICENSE\": {\n            \"text\": \"The MIT License (MIT)\\nCopyright (c) 2017 Samuel Reed <samuel.trace.reed@gmail.com>\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \\\"Software\\\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\",\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/async-limiter/LICENSE\"\n        },\n        \"$:/plugins/OokTech/Bob/External/followRedirects/followRedirects.js\": {\n            \"text\": \"(function(){\\nconst url = require(\\\"url\\\");\\nconst URL = url.URL;\\nconst http = require(\\\"http\\\");\\nconst https = require(\\\"https\\\");\\nconst assert = require(\\\"assert\\\");\\nconst Writable = require(\\\"stream\\\").Writable;\\n//var debug = require(\\\"debug\\\")(\\\"follow-redirects\\\");\\n\\n// RFC72314.2.1: Of the request methods defined by this specification,\\n// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.\\nvar SAFE_METHODS = { GET: true, HEAD: true, OPTIONS: true, TRACE: true };\\n\\n// Create handlers that pass events from native requests\\nvar eventHandlers = Object.create(null);\\n[\\\"abort\\\", \\\"aborted\\\", \\\"error\\\", \\\"socket\\\", \\\"timeout\\\"].forEach(function (event) {\\n  eventHandlers[event] = function (arg) {\\n    this._redirectable.emit(event, arg);\\n  };\\n});\\n\\n// An HTTP(S) request that can be redirected\\nfunction RedirectableRequest(options, responseCallback) {\\n  // Initialize the request\\n  Writable.call(this);\\n  options.headers = options.headers || {};\\n  this._options = options;\\n  this._ended = false;\\n  this._ending = false;\\n  this._redirectCount = 0;\\n  this._redirects = [];\\n  this._requestBodyLength = 0;\\n  this._requestBodyBuffers = [];\\n\\n  // Since http.request treats host as an alias of hostname,\\n  // but the url module interprets host as hostname plus port,\\n  // eliminate the host property to avoid confusion.\\n  if (options.host) {\\n    // Use hostname if set, because it has precedence\\n    if (!options.hostname) {\\n      options.hostname = options.host;\\n    }\\n    delete options.host;\\n  }\\n\\n  // Attach a callback if passed\\n  if (responseCallback) {\\n    this.on(\\\"response\\\", responseCallback);\\n  }\\n\\n  // React to responses of native requests\\n  var self = this;\\n  this._onNativeResponse = function (response) {\\n    self._processResponse(response);\\n  };\\n\\n  // Complete the URL object when necessary\\n  if (!options.pathname && options.path) {\\n    var searchPos = options.path.indexOf(\\\"?\\\");\\n    if (searchPos < 0) {\\n      options.pathname = options.path;\\n    }\\n    else {\\n      options.pathname = options.path.substring(0, searchPos);\\n      options.search = options.path.substring(searchPos);\\n    }\\n  }\\n\\n  // Perform the first request\\n  this._performRequest();\\n}\\nRedirectableRequest.prototype = Object.create(Writable.prototype);\\n\\n// Writes buffered data to the current native request\\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\\n  // Writing is not allowed if end has been called\\n  if (this._ending) {\\n    throw new Error(\\\"write after end\\\");\\n  }\\n\\n  // Validate input and shift parameters if necessary\\n  if (!(typeof data === \\\"string\\\" || typeof data === \\\"object\\\" && (\\\"length\\\" in data))) {\\n    throw new Error(\\\"data should be a string, Buffer or Uint8Array\\\");\\n  }\\n  if (typeof encoding === \\\"function\\\") {\\n    callback = encoding;\\n    encoding = null;\\n  }\\n\\n  // Ignore empty buffers, since writing them doesn't invoke the callback\\n  // https://github.com/nodejs/node/issues/22066\\n  if (data.length === 0) {\\n    if (callback) {\\n      callback();\\n    }\\n    return;\\n  }\\n  // Only write when we don't exceed the maximum body length\\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\\n    this._requestBodyLength += data.length;\\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\\n    this._currentRequest.write(data, encoding, callback);\\n  }\\n  // Error when we exceed the maximum body length\\n  else {\\n    this.emit(\\\"error\\\", new Error(\\\"Request body larger than maxBodyLength limit\\\"));\\n    this.abort();\\n  }\\n};\\n\\n// Ends the current native request\\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\\n  // Shift parameters if necessary\\n  if (typeof data === \\\"function\\\") {\\n    callback = data;\\n    data = encoding = null;\\n  }\\n  else if (typeof encoding === \\\"function\\\") {\\n    callback = encoding;\\n    encoding = null;\\n  }\\n\\n  // Write data if needed and end\\n  if (!data) {\\n    this._ended = this._ending = true;\\n    this._currentRequest.end(null, null, callback);\\n  }\\n  else {\\n    var self = this;\\n    var currentRequest = this._currentRequest;\\n    this.write(data, encoding, function () {\\n      self._ended = true;\\n      currentRequest.end(null, null, callback);\\n    });\\n    this._ending = true;\\n  }\\n};\\n\\n// Sets a header value on the current native request\\nRedirectableRequest.prototype.setHeader = function (name, value) {\\n  this._options.headers[name] = value;\\n  this._currentRequest.setHeader(name, value);\\n};\\n\\n// Clears a header value on the current native request\\nRedirectableRequest.prototype.removeHeader = function (name) {\\n  delete this._options.headers[name];\\n  this._currentRequest.removeHeader(name);\\n};\\n\\n// Global timeout for all underlying requests\\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\\n  if (callback) {\\n    this.once(\\\"timeout\\\", callback);\\n  }\\n\\n  if (this.socket) {\\n    startTimer(this, msecs);\\n  }\\n  else {\\n    var self = this;\\n    this._currentRequest.once(\\\"socket\\\", function () {\\n      startTimer(self, msecs);\\n    });\\n  }\\n\\n  this.once(\\\"response\\\", clearTimer);\\n  this.once(\\\"error\\\", clearTimer);\\n\\n  return this;\\n};\\n\\nfunction startTimer(request, msecs) {\\n  clearTimeout(request._timeout);\\n  request._timeout = setTimeout(function () {\\n    request.emit(\\\"timeout\\\");\\n  }, msecs);\\n}\\n\\nfunction clearTimer() {\\n  clearTimeout(this._timeout);\\n}\\n\\n// Proxy all other public ClientRequest methods\\n[\\n  \\\"abort\\\", \\\"flushHeaders\\\", \\\"getHeader\\\",\\n  \\\"setNoDelay\\\", \\\"setSocketKeepAlive\\\",\\n].forEach(function (method) {\\n  RedirectableRequest.prototype[method] = function (a, b) {\\n    return this._currentRequest[method](a, b);\\n  };\\n});\\n\\n// Proxy all public ClientRequest properties\\n[\\\"aborted\\\", \\\"connection\\\", \\\"socket\\\"].forEach(function (property) {\\n  Object.defineProperty(RedirectableRequest.prototype, property, {\\n    get: function () { return this._currentRequest[property]; },\\n  });\\n});\\n\\n// Executes the next native request (initial or redirect)\\nRedirectableRequest.prototype._performRequest = function () {\\n  // Load the native protocol\\n  var protocol = this._options.protocol;\\n  var nativeProtocol = this._options.nativeProtocols[protocol];\\n  if (!nativeProtocol) {\\n    this.emit(\\\"error\\\", new Error(\\\"Unsupported protocol \\\" + protocol));\\n    return;\\n  }\\n\\n  // If specified, use the agent corresponding to the protocol\\n  // (HTTP and HTTPS use different types of agents)\\n  if (this._options.agents) {\\n    var scheme = protocol.substr(0, protocol.length - 1);\\n    this._options.agent = this._options.agents[scheme];\\n  }\\n\\n  // Create the native request\\n  var request = this._currentRequest =\\n        nativeProtocol.request(this._options, this._onNativeResponse);\\n  this._currentUrl = url.format(this._options);\\n\\n  // Set up event handlers\\n  request._redirectable = this;\\n  for (var event in eventHandlers) {\\n    /* istanbul ignore else */\\n    if (event) {\\n      request.on(event, eventHandlers[event]);\\n    }\\n  }\\n\\n  // End a redirected request\\n  // (The first request must be ended explicitly with RedirectableRequest#end)\\n  if (this._isRedirect) {\\n    // Write the request entity and end.\\n    var i = 0;\\n    var self = this;\\n    var buffers = this._requestBodyBuffers;\\n    (function writeNext(error) {\\n      // Only write if this request has not been redirected yet\\n      /* istanbul ignore else */\\n      if (request === self._currentRequest) {\\n        // Report any write errors\\n        /* istanbul ignore if */\\n        if (error) {\\n          self.emit(\\\"error\\\", error);\\n        }\\n        // Write the next buffer if there are still left\\n        else if (i < buffers.length) {\\n          var buffer = buffers[i++];\\n          /* istanbul ignore else */\\n          if (!request.finished) {\\n            request.write(buffer.data, buffer.encoding, writeNext);\\n          }\\n        }\\n        // End the request if `end` has been called on us\\n        else if (self._ended) {\\n          request.end();\\n        }\\n      }\\n    }());\\n  }\\n};\\n\\n// Processes a response from the current native request\\nRedirectableRequest.prototype._processResponse = function (response) {\\n  // Store the redirected response\\n  if (this._options.trackRedirects) {\\n    this._redirects.push({\\n      url: this._currentUrl,\\n      headers: response.headers,\\n      statusCode: response.statusCode,\\n    });\\n  }\\n\\n  // RFC72316.4: The 3xx (Redirection) class of status code indicates\\n  // that further action needs to be taken by the user agent in order to\\n  // fulfill the request. If a Location header field is provided,\\n  // the user agent MAY automatically redirect its request to the URI\\n  // referenced by the Location field value,\\n  // even if the specific status code is not understood.\\n  var location = response.headers.location;\\n  if (location && this._options.followRedirects !== false &&\\n      response.statusCode >= 300 && response.statusCode < 400) {\\n    // Abort the current request\\n    this._currentRequest.removeAllListeners();\\n    this._currentRequest.on(\\\"error\\\", noop);\\n    this._currentRequest.abort();\\n\\n    // RFC72316.4: A client SHOULD detect and intervene\\n    // in cyclical redirections (i.e., \\\"infinite\\\" redirection loops).\\n    if (++this._redirectCount > this._options.maxRedirects) {\\n      this.emit(\\\"error\\\", new Error(\\\"Max redirects exceeded.\\\"));\\n      return;\\n    }\\n\\n    // RFC72316.4: Automatic redirection needs to done with\\n    // care for methods not known to be safe [],\\n    // since the user might not wish to redirect an unsafe request.\\n    // RFC72316.4.7: The 307 (Temporary Redirect) status code indicates\\n    // that the target resource resides temporarily under a different URI\\n    // and the user agent MUST NOT change the request method\\n    // if it performs an automatic redirection to that URI.\\n    var header;\\n    var headers = this._options.headers;\\n    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {\\n      this._options.method = \\\"GET\\\";\\n      // Drop a possible entity and headers related to it\\n      this._requestBodyBuffers = [];\\n      for (header in headers) {\\n        if (/^content-/i.test(header)) {\\n          delete headers[header];\\n        }\\n      }\\n    }\\n\\n    // Drop the Host header, as the redirect might lead to a different host\\n    if (!this._isRedirect) {\\n      for (header in headers) {\\n        if (/^host$/i.test(header)) {\\n          delete headers[header];\\n        }\\n      }\\n    }\\n\\n    // Perform the redirected request\\n    var redirectUrl = url.resolve(this._currentUrl, location);\\n    //debug(\\\"redirecting to\\\", redirectUrl);\\n    Object.assign(this._options, url.parse(redirectUrl));\\n    this._isRedirect = true;\\n    this._performRequest();\\n\\n    // Discard the remainder of the response to avoid waiting for data\\n    response.destroy();\\n  }\\n  else {\\n    // The response is not a redirect; return it as-is\\n    response.responseUrl = this._currentUrl;\\n    response.redirects = this._redirects;\\n    this.emit(\\\"response\\\", response);\\n\\n    // Clean up\\n    this._requestBodyBuffers = [];\\n  }\\n};\\n\\n// Wraps the key/value object of protocols with redirect functionality\\nfunction wrap(protocols) {\\n  // Default settings\\n  var exports = {\\n    maxRedirects: 21,\\n    maxBodyLength: 10 * 1024 * 1024,\\n  };\\n\\n  // Wrap each protocol\\n  var nativeProtocols = {};\\n  Object.keys(protocols).forEach(function (scheme) {\\n    var protocol = scheme + \\\":\\\";\\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\\n\\n    // Executes a request, following redirects\\n    wrappedProtocol.request = function (input, options, callback) {\\n      // Parse parameters\\n      if (typeof input === \\\"string\\\") {\\n        var urlStr = input;\\n        try {\\n          input = urlToOptions(new URL(urlStr));\\n        }\\n        catch (err) {\\n          /* istanbul ignore next */\\n          input = url.parse(urlStr);\\n        }\\n      }\\n      else if (URL && (input instanceof URL)) {\\n        input = urlToOptions(input);\\n      }\\n      else {\\n        callback = options;\\n        options = input;\\n        input = { protocol: protocol };\\n      }\\n      if (typeof options === \\\"function\\\") {\\n        callback = options;\\n        options = null;\\n      }\\n\\n      // Set defaults\\n      options = Object.assign({\\n        maxRedirects: exports.maxRedirects,\\n        maxBodyLength: exports.maxBodyLength,\\n      }, input, options);\\n      options.nativeProtocols = nativeProtocols;\\n\\n      assert.equal(options.protocol, protocol, \\\"protocol mismatch\\\");\\n      //debug(\\\"options\\\", options);\\n      return new RedirectableRequest(options, callback);\\n    };\\n\\n    // Executes a GET request, following redirects\\n    wrappedProtocol.get = function (input, options, callback) {\\n      var request = wrappedProtocol.request(input, options, callback);\\n      request.end();\\n      return request;\\n    };\\n  });\\n  return exports;\\n}\\n\\n/* istanbul ignore next */\\nfunction noop() { /* empty */ }\\n\\n// from https://github.com/nodejs/node/blob/master/lib/internal/url.js\\nfunction urlToOptions(urlObject) {\\n  var options = {\\n    protocol: urlObject.protocol,\\n    hostname: urlObject.hostname.startsWith(\\\"[\\\") ?\\n      /* istanbul ignore next */\\n      urlObject.hostname.slice(1, -1) :\\n      urlObject.hostname,\\n    hash: urlObject.hash,\\n    search: urlObject.search,\\n    pathname: urlObject.pathname,\\n    path: urlObject.pathname + urlObject.search,\\n    href: urlObject.href,\\n  };\\n  if (urlObject.port !== \\\"\\\") {\\n    options.port = Number(urlObject.port);\\n  }\\n  return options;\\n}\\n\\n// Exports\\nmodule.exports = wrap({ http: http, https: https });\\nmodule.exports.wrap = wrap;\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/followRedirects/followRedirects.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/External/followRedirects/README.tid\": {\n            \"text\": \"## Follow Redirects\\n\\nDrop-in replacement for Node's `http` and `https` modules that automatically follows redirects.\\n\\n[![npm version](https://img.shields.io/npm/v/follow-redirects.svg)](https://www.npmjs.com/package/follow-redirects)\\n[![Build Status](https://travis-ci.org/follow-redirects/follow-redirects.svg?branch=master)](https://travis-ci.org/follow-redirects/follow-redirects)\\n[![Coverage Status](https://coveralls.io/repos/follow-redirects/follow-redirects/badge.svg?branch=master)](https://coveralls.io/r/follow-redirects/follow-redirects?branch=master)\\n[![npm downloads](https://img.shields.io/npm/dm/follow-redirects.svg)](https://www.npmjs.com/package/follow-redirects)\\n\\n`follow-redirects` provides [request](https://nodejs.org/api/http.html#http_http_request_options_callback) and [get](https://nodejs.org/api/http.html#http_http_get_options_callback)\\n methods that behave identically to those found on the native [http](https://nodejs.org/api/http.html#http_http_request_options_callback) and [https](https://nodejs.org/api/https.html#https_https_request_options_callback)\\n modules, with the exception that they will seamlessly follow redirects.\\n\\n```javascript\\nvar http = require('follow-redirects').http;\\nvar https = require('follow-redirects').https;\\n\\nhttp.get('http://bit.ly/900913', function (response) {\\n  response.on('data', function (chunk) {\\n    console.log(chunk);\\n  });\\n}).on('error', function (err) {\\n  console.error(err);\\n});\\n```\\n\\nYou can inspect the final redirected URL through the `responseUrl` property on the `response`.\\nIf no redirection happened, `responseUrl` is the original request URL.\\n\\n```javascript\\nhttps.request({\\n  host: 'bitly.com',\\n  path: '/UHfDGO',\\n}, function (response) {\\n  console.log(response.responseUrl);\\n  // 'http://duckduckgo.com/robots.txt'\\n});\\n```\\n\\n## Options\\n### Global options\\nGlobal options are set directly on the `follow-redirects` module:\\n\\n```javascript\\nvar followRedirects = require('follow-redirects');\\nfollowRedirects.maxRedirects = 10;\\nfollowRedirects.maxBodyLength = 20 * 1024 * 1024; // 20 MB\\n```\\n\\nThe following global options are supported:\\n\\n- `maxRedirects` (default: `21`)  sets the maximum number of allowed redirects; if exceeded, an error will be emitted.\\n\\n- `maxBodyLength` (default: 10MB)  sets the maximum size of the request body; if exceeded, an error will be emitted.\\n\\n\\n### Per-request options\\nPer-request options are set by passing an `options` object:\\n\\n```javascript\\nvar url = require('url');\\nvar followRedirects = require('follow-redirects');\\n\\nvar options = url.parse('http://bit.ly/900913');\\noptions.maxRedirects = 10;\\nhttp.request(options);\\n```\\n\\nIn addition to the [standard HTTP](https://nodejs.org/api/http.html#http_http_request_options_callback) and [HTTPS options](https://nodejs.org/api/https.html#https_https_request_options_callback),\\nthe following per-request options are supported:\\n- `followRedirects` (default: `true`)  whether redirects should be followed.\\n\\n- `maxRedirects` (default: `21`)  sets the maximum number of allowed redirects; if exceeded, an error will be emitted.\\n\\n- `maxBodyLength` (default: 10MB)  sets the maximum size of the request body; if exceeded, an error will be emitted.\\n\\n- `agents` (default: `undefined`)  sets the `agent` option per protocol, since HTTP and HTTPS use different agents. Example value: `{ http: new http.Agent(), https: new https.Agent() }`\\n\\n- `trackRedirects` (default: `false`)  whether to store the redirected response details into the `redirects` array on the response object.\\n\\n\\n### Advanced usage\\nBy default, `follow-redirects` will use the Node.js default implementations\\nof [`http`](https://nodejs.org/api/http.html)\\nand [`https`](https://nodejs.org/api/https.html).\\nTo enable features such as caching and/or intermediate request tracking,\\nyou might instead want to wrap `follow-redirects` around custom protocol implementations:\\n\\n```javascript\\nvar followRedirects = require('follow-redirects').wrap({\\n  http: require('your-custom-http'),\\n  https: require('your-custom-https'),\\n});\\n```\\n\\nSuch custom protocols only need an implementation of the `request` method.\\n\\n## Browser Usage\\n\\nDue to the way the browser works,\\nthe `http` and `https` browser equivalents perform redirects by default.\\n\\nBy requiring `follow-redirects` this way:\\n```javascript\\nvar http = require('follow-redirects/http');\\nvar https = require('follow-redirects/https');\\n```\\nyou can easily tell webpack and friends to replace\\n`follow-redirect` by the built-in versions:\\n\\n```json\\n{\\n  \\\"follow-redirects/http\\\"  : \\\"http\\\",\\n  \\\"follow-redirects/https\\\" : \\\"https\\\"\\n}\\n```\\n\\n## Contributing\\n\\nPull Requests are always welcome. Please [file an issue](https://github.com/follow-redirects/follow-redirects/issues)\\n detailing your proposal before you invest your valuable time. Additional features and bug fixes should be accompanied\\n by tests. You can run the test suite locally with a simple `npm test` command.\\n\\n## Debug Logging\\n\\n`follow-redirects` uses the excellent [debug](https://www.npmjs.com/package/debug) for logging. To turn on logging\\n set the environment variable `DEBUG=follow-redirects` for debug output from just this module. When running the test\\n suite it is sometimes advantageous to set `DEBUG=*` to see output from the express server as well.\\n\\n## Authors\\n\\n- Olivier Lalonde (olalonde@gmail.com)\\n- James Talmage (james@talmage.io)\\n- [Ruben Verborgh](https://ruben.verborgh.org/)\\n\\n## License\\n\\n[MIT License](https://github.com/follow-redirects/follow-redirects/blob/master/LICENSE)\\n\",\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/followRedirects/README.tid\"\n        },\n        \"$:/plugins/OokTech/Bob/External/followRedirects/LICENSE.tid\": {\n            \"text\": \"Copyright 2014present Olivier Lalonde <olalonde@gmail.com>, James Talmage <james@talmage.io>, Ruben Verborgh\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy of\\nthis software and associated documentation files (the \\\"Software\\\"), to deal in\\nthe Software without restriction, including without limitation the rights to\\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\\nof the Software, and to permit persons to whom the Software is furnished to do\\nso, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\\nIN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\",\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/followRedirects/LICENSE.tid\"\n        },\n        \"$:/plugins/OokTech/Bob/External/followRedirects/notes.tid\": {\n            \"text\": \"title: $:/plugins/OokTech/Bob/External/followRedirects/notes.tid\\n\\nRepo url: https://github.com/follow-redirects/follow-redirects\\n\\nThis has been modified from the original repo in the following ways:\\n\\n- Everything but index.js, LICENSE and README.md has been removed\\n- In index.js lines 7, 327 and 395 have been commented out to remove the dependency on the debug npm module.\\n\",\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/followRedirects/notes.tid\"\n        },\n        \"$:/plugins/OokTech/Bob/External/jszip/jszip.js\": {\n            \"text\": \"(function(){\\n/*!\\n\\nJSZip v3.2.1 - A JavaScript class for generating and reading zip files\\n<http://stuartk.com/jszip>\\n\\n(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>\\nDual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.\\n\\nJSZip uses the library pako released under the MIT license :\\nhttps://github.com/nodeca/pako/blob/master/LICENSE\\n*/\\n!function(a){if(\\\"object\\\"==typeof exports&&\\\"undefined\\\"!=typeof module)module.exports=a();else if(\\\"function\\\"==typeof define&&define.amd)define([],a);else{var b;b=\\\"undefined\\\"!=typeof window?window:\\\"undefined\\\"!=typeof global?global:\\\"undefined\\\"!=typeof self?self:this,b.JSZip=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i=\\\"function\\\"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error(\\\"Cannot find module '\\\"+g+\\\"'\\\");throw j.code=\\\"MODULE_NOT_FOUND\\\",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f=\\\"function\\\"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){\\\"use strict\\\";var d=a(\\\"./utils\\\"),e=a(\\\"./support\\\"),f=\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\\";c.encode=function(a){for(var b,c,e,g,h,i,j,k=[],l=0,m=a.length,n=m,o=\\\"string\\\"!==d.getTypeOf(a);l<a.length;)n=m-l,o?(b=a[l++],c=l<m?a[l++]:0,e=l<m?a[l++]:0):(b=a.charCodeAt(l++),c=l<m?a.charCodeAt(l++):0,e=l<m?a.charCodeAt(l++):0),g=b>>2,h=(3&b)<<4|c>>4,i=n>1?(15&c)<<2|e>>6:64,j=n>2?63&e:64,k.push(f.charAt(g)+f.charAt(h)+f.charAt(i)+f.charAt(j));return k.join(\\\"\\\")},c.decode=function(a){var b,c,d,g,h,i,j,k=0,l=0,m=\\\"data:\\\";if(a.substr(0,m.length)===m)throw new Error(\\\"Invalid base64 input, it looks like a data url.\\\");a=a.replace(/[^A-Za-z0-9\\\\+\\\\/\\\\=]/g,\\\"\\\");var n=3*a.length/4;if(a.charAt(a.length-1)===f.charAt(64)&&n--,a.charAt(a.length-2)===f.charAt(64)&&n--,n%1!==0)throw new Error(\\\"Invalid base64 input, bad content length.\\\");var o;for(o=e.uint8array?new Uint8Array(0|n):new Array(0|n);k<a.length;)g=f.indexOf(a.charAt(k++)),h=f.indexOf(a.charAt(k++)),i=f.indexOf(a.charAt(k++)),j=f.indexOf(a.charAt(k++)),b=g<<2|h>>4,c=(15&h)<<4|i>>2,d=(3&i)<<6|j,o[l++]=b,64!==i&&(o[l++]=c),64!==j&&(o[l++]=d);return o}},{\\\"./support\\\":30,\\\"./utils\\\":32}],2:[function(a,b,c){\\\"use strict\\\";function d(a,b,c,d,e){this.compressedSize=a,this.uncompressedSize=b,this.crc32=c,this.compression=d,this.compressedContent=e}var e=a(\\\"./external\\\"),f=a(\\\"./stream/DataWorker\\\"),g=a(\\\"./stream/DataLengthProbe\\\"),h=a(\\\"./stream/Crc32Probe\\\"),g=a(\\\"./stream/DataLengthProbe\\\");d.prototype={getContentWorker:function(){var a=new f(e.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new g(\\\"data_length\\\")),b=this;return a.on(\\\"end\\\",function(){if(this.streamInfo.data_length!==b.uncompressedSize)throw new Error(\\\"Bug : uncompressed data size mismatch\\\")}),a},getCompressedWorker:function(){return new f(e.Promise.resolve(this.compressedContent)).withStreamInfo(\\\"compressedSize\\\",this.compressedSize).withStreamInfo(\\\"uncompressedSize\\\",this.uncompressedSize).withStreamInfo(\\\"crc32\\\",this.crc32).withStreamInfo(\\\"compression\\\",this.compression)}},d.createWorkerFrom=function(a,b,c){return a.pipe(new h).pipe(new g(\\\"uncompressedSize\\\")).pipe(b.compressWorker(c)).pipe(new g(\\\"compressedSize\\\")).withStreamInfo(\\\"compression\\\",b)},b.exports=d},{\\\"./external\\\":6,\\\"./stream/Crc32Probe\\\":25,\\\"./stream/DataLengthProbe\\\":26,\\\"./stream/DataWorker\\\":27}],3:[function(a,b,c){\\\"use strict\\\";var d=a(\\\"./stream/GenericWorker\\\");c.STORE={magic:\\\"\\\\0\\\\0\\\",compressWorker:function(a){return new d(\\\"STORE compression\\\")},uncompressWorker:function(){return new d(\\\"STORE decompression\\\")}},c.DEFLATE=a(\\\"./flate\\\")},{\\\"./flate\\\":7,\\\"./stream/GenericWorker\\\":28}],4:[function(a,b,c){\\\"use strict\\\";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b[g])];return a^-1}function f(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b.charCodeAt(g))];return a^-1}var g=a(\\\"./utils\\\"),h=d();b.exports=function(a,b){if(\\\"undefined\\\"==typeof a||!a.length)return 0;var c=\\\"string\\\"!==g.getTypeOf(a);return c?e(0|b,a,a.length,0):f(0|b,a,a.length,0)}},{\\\"./utils\\\":32}],5:[function(a,b,c){\\\"use strict\\\";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!0,c.date=null,c.compression=null,c.compressionOptions=null,c.comment=null,c.unixPermissions=null,c.dosPermissions=null},{}],6:[function(a,b,c){\\\"use strict\\\";var d=null;d=\\\"undefined\\\"!=typeof Promise?Promise:a(\\\"lie\\\"),b.exports={Promise:d}},{lie:37}],7:[function(a,b,c){\\\"use strict\\\";function d(a,b){h.call(this,\\\"FlateWorker/\\\"+a),this._pako=null,this._pakoAction=a,this._pakoOptions=b,this.meta={}}var e=\\\"undefined\\\"!=typeof Uint8Array&&\\\"undefined\\\"!=typeof Uint16Array&&\\\"undefined\\\"!=typeof Uint32Array,f=a(\\\"pako\\\"),g=a(\\\"./utils\\\"),h=a(\\\"./stream/GenericWorker\\\"),i=e?\\\"uint8array\\\":\\\"array\\\";c.magic=\\\"\\\\b\\\\0\\\",g.inherits(d,h),d.prototype.processChunk=function(a){this.meta=a.meta,null===this._pako&&this._createPako(),this._pako.push(g.transformTo(i,a.data),!1)},d.prototype.flush=function(){h.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},d.prototype.cleanUp=function(){h.prototype.cleanUp.call(this),this._pako=null},d.prototype._createPako=function(){this._pako=new f[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var a=this;this._pako.onData=function(b){a.push({data:b,meta:a.meta})}},c.compressWorker=function(a){return new d(\\\"Deflate\\\",a)},c.uncompressWorker=function(){return new d(\\\"Inflate\\\",{})}},{\\\"./stream/GenericWorker\\\":28,\\\"./utils\\\":32,pako:38}],8:[function(a,b,c){\\\"use strict\\\";function d(a,b,c,d){f.call(this,\\\"ZipFileWorker\\\"),this.bytesWritten=0,this.zipComment=b,this.zipPlatform=c,this.encodeFileName=d,this.streamFiles=a,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}var e=a(\\\"../utils\\\"),f=a(\\\"../stream/GenericWorker\\\"),g=a(\\\"../utf8\\\"),h=a(\\\"../crc32\\\"),i=a(\\\"../signature\\\"),j=function(a,b){var c,d=\\\"\\\";for(c=0;c<b;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},k=function(a,b){var c=a;return a||(c=b?16893:33204),(65535&c)<<16},l=function(a,b){return 63&(a||0)},m=function(a,b,c,d,f,m){var n,o,p=a.file,q=a.compression,r=m!==g.utf8encode,s=e.transformTo(\\\"string\\\",m(p.name)),t=e.transformTo(\\\"string\\\",g.utf8encode(p.name)),u=p.comment,v=e.transformTo(\\\"string\\\",m(u)),w=e.transformTo(\\\"string\\\",g.utf8encode(u)),x=t.length!==p.name.length,y=w.length!==u.length,z=\\\"\\\",A=\\\"\\\",B=\\\"\\\",C=p.dir,D=p.date,E={crc32:0,compressedSize:0,uncompressedSize:0};b&&!c||(E.crc32=a.crc32,E.compressedSize=a.compressedSize,E.uncompressedSize=a.uncompressedSize);var F=0;b&&(F|=8),r||!x&&!y||(F|=2048);var G=0,H=0;C&&(G|=16),\\\"UNIX\\\"===f?(H=798,G|=k(p.unixPermissions,C)):(H=20,G|=l(p.dosPermissions,C)),n=D.getUTCHours(),n<<=6,n|=D.getUTCMinutes(),n<<=5,n|=D.getUTCSeconds()/2,o=D.getUTCFullYear()-1980,o<<=4,o|=D.getUTCMonth()+1,o<<=5,o|=D.getUTCDate(),x&&(A=j(1,1)+j(h(s),4)+t,z+=\\\"up\\\"+j(A.length,2)+A),y&&(B=j(1,1)+j(h(v),4)+w,z+=\\\"uc\\\"+j(B.length,2)+B);var I=\\\"\\\";I+=\\\"\\\\n\\\\0\\\",I+=j(F,2),I+=q.magic,I+=j(n,2),I+=j(o,2),I+=j(E.crc32,4),I+=j(E.compressedSize,4),I+=j(E.uncompressedSize,4),I+=j(s.length,2),I+=j(z.length,2);var J=i.LOCAL_FILE_HEADER+I+s+z,K=i.CENTRAL_FILE_HEADER+j(H,2)+I+j(v.length,2)+\\\"\\\\0\\\\0\\\\0\\\\0\\\"+j(G,4)+j(d,4)+s+z+v;return{fileRecord:J,dirRecord:K}},n=function(a,b,c,d,f){var g=\\\"\\\",h=e.transformTo(\\\"string\\\",f(d));return g=i.CENTRAL_DIRECTORY_END+\\\"\\\\0\\\\0\\\\0\\\\0\\\"+j(a,2)+j(a,2)+j(b,4)+j(c,4)+j(h.length,2)+h},o=function(a){var b=\\\"\\\";return b=i.DATA_DESCRIPTOR+j(a.crc32,4)+j(a.compressedSize,4)+j(a.uncompressedSize,4)};e.inherits(d,f),d.prototype.push=function(a){var b=a.meta.percent||0,c=this.entriesCount,d=this._sources.length;this.accumulate?this.contentBuffer.push(a):(this.bytesWritten+=a.data.length,f.prototype.push.call(this,{data:a.data,meta:{currentFile:this.currentFile,percent:c?(b+100*(c-d-1))/c:100}}))},d.prototype.openedSource=function(a){this.currentSourceOffset=this.bytesWritten,this.currentFile=a.file.name;var b=this.streamFiles&&!a.file.dir;if(b){var c=m(a,b,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:c.fileRecord,meta:{percent:0}})}else this.accumulate=!0},d.prototype.closedSource=function(a){this.accumulate=!1;var b=this.streamFiles&&!a.file.dir,c=m(a,b,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(c.dirRecord),b)this.push({data:o(a),meta:{percent:100}});else for(this.push({data:c.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},d.prototype.flush=function(){for(var a=this.bytesWritten,b=0;b<this.dirRecords.length;b++)this.push({data:this.dirRecords[b],meta:{percent:100}});var c=this.bytesWritten-a,d=n(this.dirRecords.length,c,a,this.zipComment,this.encodeFileName);this.push({data:d,meta:{percent:100}})},d.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},d.prototype.registerPrevious=function(a){this._sources.push(a);var b=this;return a.on(\\\"data\\\",function(a){b.processChunk(a)}),a.on(\\\"end\\\",function(){b.closedSource(b.previous.streamInfo),b._sources.length?b.prepareNextSource():b.end()}),a.on(\\\"error\\\",function(a){b.error(a)}),this},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},d.prototype.error=function(a){var b=this._sources;if(!f.prototype.error.call(this,a))return!1;for(var c=0;c<b.length;c++)try{b[c].error(a)}catch(a){}return!0},d.prototype.lock=function(){f.prototype.lock.call(this);for(var a=this._sources,b=0;b<a.length;b++)a[b].lock()},b.exports=d},{\\\"../crc32\\\":4,\\\"../signature\\\":23,\\\"../stream/GenericWorker\\\":28,\\\"../utf8\\\":31,\\\"../utils\\\":32}],9:[function(a,b,c){\\\"use strict\\\";var d=a(\\\"../compressions\\\"),e=a(\\\"./ZipFileWorker\\\"),f=function(a,b){var c=a||b,e=d[c];if(!e)throw new Error(c+\\\" is not a valid compression method !\\\");return e};c.generateWorker=function(a,b,c){var d=new e(b.streamFiles,c,b.platform,b.encodeFileName),g=0;try{a.forEach(function(a,c){g++;var e=f(c.options.compression,b.compression),h=c.options.compressionOptions||b.compressionOptions||{},i=c.dir,j=c.date;c._compressWorker(e,h).withStreamInfo(\\\"file\\\",{name:a,dir:i,date:j,comment:c.comment||\\\"\\\",unixPermissions:c.unixPermissions,dosPermissions:c.dosPermissions}).pipe(d)}),d.entriesCount=g}catch(h){d.error(h)}return d}},{\\\"../compressions\\\":3,\\\"./ZipFileWorker\\\":8}],10:[function(a,b,c){\\\"use strict\\\";function d(){if(!(this instanceof d))return new d;if(arguments.length)throw new Error(\\\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\\\");this.files={},this.comment=null,this.root=\\\"\\\",this.clone=function(){var a=new d;for(var b in this)\\\"function\\\"!=typeof this[b]&&(a[b]=this[b]);return a}}d.prototype=a(\\\"./object\\\"),d.prototype.loadAsync=a(\\\"./load\\\"),d.support=a(\\\"./support\\\"),d.defaults=a(\\\"./defaults\\\"),d.version=\\\"3.2.0\\\",d.loadAsync=function(a,b){return(new d).loadAsync(a,b)},d.external=a(\\\"./external\\\"),b.exports=d},{\\\"./defaults\\\":5,\\\"./external\\\":6,\\\"./load\\\":11,\\\"./object\\\":15,\\\"./support\\\":30}],11:[function(a,b,c){\\\"use strict\\\";function d(a){return new f.Promise(function(b,c){var d=a.decompressed.getContentWorker().pipe(new i);d.on(\\\"error\\\",function(a){c(a)}).on(\\\"end\\\",function(){d.streamInfo.crc32!==a.decompressed.crc32?c(new Error(\\\"Corrupted zip : CRC32 mismatch\\\")):b()}).resume()})}var e=a(\\\"./utils\\\"),f=a(\\\"./external\\\"),g=a(\\\"./utf8\\\"),e=a(\\\"./utils\\\"),h=a(\\\"./zipEntries\\\"),i=a(\\\"./stream/Crc32Probe\\\"),j=a(\\\"./nodejsUtils\\\");b.exports=function(a,b){var c=this;return b=e.extend(b||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:g.utf8decode}),j.isNode&&j.isStream(a)?f.Promise.reject(new Error(\\\"JSZip can't accept a stream when loading a zip file.\\\")):e.prepareContent(\\\"the loaded zip file\\\",a,!0,b.optimizedBinaryString,b.base64).then(function(a){var c=new h(b);return c.load(a),c}).then(function(a){var c=[f.Promise.resolve(a)],e=a.files;if(b.checkCRC32)for(var g=0;g<e.length;g++)c.push(d(e[g]));return f.Promise.all(c)}).then(function(a){for(var d=a.shift(),e=d.files,f=0;f<e.length;f++){var g=e[f];c.file(g.fileNameStr,g.decompressed,{binary:!0,optimizedBinaryString:!0,date:g.date,dir:g.dir,comment:g.fileCommentStr.length?g.fileCommentStr:null,unixPermissions:g.unixPermissions,dosPermissions:g.dosPermissions,createFolders:b.createFolders})}return d.zipComment.length&&(c.comment=d.zipComment),c})}},{\\\"./external\\\":6,\\\"./nodejsUtils\\\":14,\\\"./stream/Crc32Probe\\\":25,\\\"./utf8\\\":31,\\\"./utils\\\":32,\\\"./zipEntries\\\":33}],12:[function(a,b,c){\\\"use strict\\\";function d(a,b){f.call(this,\\\"Nodejs stream input adapter for \\\"+a),this._upstreamEnded=!1,this._bindStream(b)}var e=a(\\\"../utils\\\"),f=a(\\\"../stream/GenericWorker\\\");e.inherits(d,f),d.prototype._bindStream=function(a){var b=this;this._stream=a,a.pause(),a.on(\\\"data\\\",function(a){b.push({data:a,meta:{percent:0}})}).on(\\\"error\\\",function(a){b.isPaused?this.generatedError=a:b.error(a)}).on(\\\"end\\\",function(){b.isPaused?b._upstreamEnded=!0:b.end()})},d.prototype.pause=function(){return!!f.prototype.pause.call(this)&&(this._stream.pause(),!0)},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},b.exports=d},{\\\"../stream/GenericWorker\\\":28,\\\"../utils\\\":32}],13:[function(a,b,c){\\\"use strict\\\";function d(a,b,c){e.call(this,b),this._helper=a;var d=this;a.on(\\\"data\\\",function(a,b){d.push(a)||d._helper.pause(),c&&c(b)}).on(\\\"error\\\",function(a){d.emit(\\\"error\\\",a)}).on(\\\"end\\\",function(){d.push(null)})}var e=a(\\\"readable-stream\\\").Readable,f=a(\\\"../utils\\\");f.inherits(d,e),d.prototype._read=function(){this._helper.resume()},b.exports=d},{\\\"../utils\\\":32,\\\"readable-stream\\\":16}],14:[function(a,b,c){\\\"use strict\\\";b.exports={isNode:\\\"undefined\\\"!=typeof Buffer,newBufferFrom:function(a,b){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(a,b);if(\\\"number\\\"==typeof a)throw new Error('The \\\"data\\\" argument must not be a number');return new Buffer(a,b)},allocBuffer:function(a){if(Buffer.alloc)return Buffer.alloc(a);var b=new Buffer(a);return b.fill(0),b},isBuffer:function(a){return Buffer.isBuffer(a)},isStream:function(a){return a&&\\\"function\\\"==typeof a.on&&\\\"function\\\"==typeof a.pause&&\\\"function\\\"==typeof a.resume}}},{}],15:[function(a,b,c){\\\"use strict\\\";function d(a){return\\\"[object RegExp]\\\"===Object.prototype.toString.call(a)}var e=a(\\\"./utf8\\\"),f=a(\\\"./utils\\\"),g=a(\\\"./stream/GenericWorker\\\"),h=a(\\\"./stream/StreamHelper\\\"),i=a(\\\"./defaults\\\"),j=a(\\\"./compressedObject\\\"),k=a(\\\"./zipObject\\\"),l=a(\\\"./generate\\\"),m=a(\\\"./nodejsUtils\\\"),n=a(\\\"./nodejs/NodejsStreamInputAdapter\\\"),o=function(a,b,c){var d,e=f.getTypeOf(b),h=f.extend(c||{},i);h.date=h.date||new Date,null!==h.compression&&(h.compression=h.compression.toUpperCase()),\\\"string\\\"==typeof h.unixPermissions&&(h.unixPermissions=parseInt(h.unixPermissions,8)),h.unixPermissions&&16384&h.unixPermissions&&(h.dir=!0),h.dosPermissions&&16&h.dosPermissions&&(h.dir=!0),h.dir&&(a=q(a)),h.createFolders&&(d=p(a))&&r.call(this,d,!0);var l=\\\"string\\\"===e&&h.binary===!1&&h.base64===!1;c&&\\\"undefined\\\"!=typeof c.binary||(h.binary=!l);var o=b instanceof j&&0===b.uncompressedSize;(o||h.dir||!b||0===b.length)&&(h.base64=!1,h.binary=!0,b=\\\"\\\",h.compression=\\\"STORE\\\",e=\\\"string\\\");var s=null;s=b instanceof j||b instanceof g?b:m.isNode&&m.isStream(b)?new n(a,b):f.prepareContent(a,b,h.binary,h.optimizedBinaryString,h.base64);var t=new k(a,s,h);this.files[a]=t},p=function(a){\\\"/\\\"===a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf(\\\"/\\\");return b>0?a.substring(0,b):\\\"\\\"},q=function(a){return\\\"/\\\"!==a.slice(-1)&&(a+=\\\"/\\\"),a},r=function(a,b){return b=\\\"undefined\\\"!=typeof b?b:i.createFolders,a=q(a),this.files[a]||o.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},s={load:function(){throw new Error(\\\"This method has been removed in JSZip 3.0, please check the upgrade guide.\\\")},forEach:function(a){var b,c,d;for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],c=b.slice(this.root.length,b.length),c&&b.slice(0,this.root.length)===this.root&&a(c,d))},filter:function(a){var b=[];return this.forEach(function(c,d){a(c,d)&&b.push(d)}),b},file:function(a,b,c){if(1===arguments.length){if(d(a)){var e=a;return this.filter(function(a,b){return!b.dir&&e.test(a)})}var f=this.files[this.root+a];return f&&!f.dir?f:null}return a=this.root+a,o.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(d(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=r.call(this,b),e=this.clone();return e.root=c.name,e},remove:function(a){a=this.root+a;var b=this.files[a];if(b||(\\\"/\\\"!==a.slice(-1)&&(a+=\\\"/\\\"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){throw new Error(\\\"This method has been removed in JSZip 3.0, please check the upgrade guide.\\\")},generateInternalStream:function(a){var b,c={};try{if(c=f.extend(a||{},{streamFiles:!1,compression:\\\"STORE\\\",compressionOptions:null,type:\\\"\\\",platform:\\\"DOS\\\",comment:null,mimeType:\\\"application/zip\\\",encodeFileName:e.utf8encode}),c.type=c.type.toLowerCase(),c.compression=c.compression.toUpperCase(),\\\"binarystring\\\"===c.type&&(c.type=\\\"string\\\"),!c.type)throw new Error(\\\"No output type specified.\\\");f.checkSupport(c.type),\\\"darwin\\\"!==c.platform&&\\\"freebsd\\\"!==c.platform&&\\\"linux\\\"!==c.platform&&\\\"sunos\\\"!==c.platform||(c.platform=\\\"UNIX\\\"),\\\"win32\\\"===c.platform&&(c.platform=\\\"DOS\\\");var d=c.comment||this.comment||\\\"\\\";b=l.generateWorker(this,c,d)}catch(i){b=new g(\\\"error\\\"),b.error(i)}return new h(b,c.type||\\\"string\\\",c.mimeType)},generateAsync:function(a,b){return this.generateInternalStream(a).accumulate(b)},generateNodeStream:function(a,b){return a=a||{},a.type||(a.type=\\\"nodebuffer\\\"),this.generateInternalStream(a).toNodejsStream(b)}};b.exports=s},{\\\"./compressedObject\\\":2,\\\"./defaults\\\":5,\\\"./generate\\\":9,\\\"./nodejs/NodejsStreamInputAdapter\\\":12,\\\"./nodejsUtils\\\":14,\\\"./stream/GenericWorker\\\":28,\\\"./stream/StreamHelper\\\":29,\\\"./utf8\\\":31,\\\"./utils\\\":32,\\\"./zipObject\\\":35}],16:[function(a,b,c){b.exports=a(\\\"stream\\\")},{stream:void 0}],17:[function(a,b,c){\\\"use strict\\\";function d(a){e.call(this,a);for(var b=0;b<this.data.length;b++)a[b]=255&a[b]}var e=a(\\\"./DataReader\\\"),f=a(\\\"../utils\\\");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data[this.zero+a]},d.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f-this.zero;return-1},d.prototype.readAndCheckSignature=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.readData(4);return b===f[0]&&c===f[1]&&d===f[2]&&e===f[3]},d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return[];var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{\\\"../utils\\\":32,\\\"./DataReader\\\":18}],18:[function(a,b,c){\\\"use strict\\\";function d(a){this.data=a,this.length=a.length,this.index=0,this.zero=0}var e=a(\\\"../utils\\\");d.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<this.zero+a||a<0)throw new Error(\\\"End of data reached (data length = \\\"+this.length+\\\", asked index = \\\"+a+\\\"). Corrupted zip ?\\\")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(a){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return e.transformTo(\\\"string\\\",this.readData(a))},readData:function(a){},lastIndexOfSignature:function(a){},readAndCheckSignature:function(a){},readDate:function(){var a=this.readInt(4);return new Date(Date.UTC((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1))}},b.exports=d},{\\\"../utils\\\":32}],19:[function(a,b,c){\\\"use strict\\\";function d(a){e.call(this,a)}var e=a(\\\"./Uint8ArrayReader\\\"),f=a(\\\"../utils\\\");f.inherits(d,e),d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{\\\"../utils\\\":32,\\\"./Uint8ArrayReader\\\":21}],20:[function(a,b,c){\\\"use strict\\\";function d(a){e.call(this,a)}var e=a(\\\"./DataReader\\\"),f=a(\\\"../utils\\\");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data.charCodeAt(this.zero+a)},d.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)-this.zero},d.prototype.readAndCheckSignature=function(a){var b=this.readData(4);return a===b},d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{\\\"../utils\\\":32,\\\"./DataReader\\\":18}],21:[function(a,b,c){\\\"use strict\\\";function d(a){e.call(this,a)}var e=a(\\\"./ArrayReader\\\"),f=a(\\\"../utils\\\");f.inherits(d,e),d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{\\\"../utils\\\":32,\\\"./ArrayReader\\\":17}],22:[function(a,b,c){\\\"use strict\\\";var d=a(\\\"../utils\\\"),e=a(\\\"../support\\\"),f=a(\\\"./ArrayReader\\\"),g=a(\\\"./StringReader\\\"),h=a(\\\"./NodeBufferReader\\\"),i=a(\\\"./Uint8ArrayReader\\\");b.exports=function(a){var b=d.getTypeOf(a);return d.checkSupport(b),\\\"string\\\"!==b||e.uint8array?\\\"nodebuffer\\\"===b?new h(a):e.uint8array?new i(d.transformTo(\\\"uint8array\\\",a)):new f(d.transformTo(\\\"array\\\",a)):new g(a)}},{\\\"../support\\\":30,\\\"../utils\\\":32,\\\"./ArrayReader\\\":17,\\\"./NodeBufferReader\\\":19,\\\"./StringReader\\\":20,\\\"./Uint8ArrayReader\\\":21}],23:[function(a,b,c){\\\"use strict\\\";c.LOCAL_FILE_HEADER=\\\"PK\\u0003\\u0004\\\",c.CENTRAL_FILE_HEADER=\\\"PK\\u0001\\u0002\\\",c.CENTRAL_DIRECTORY_END=\\\"PK\\u0005\\u0006\\\",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR=\\\"PK\\u0006\\u0007\\\",c.ZIP64_CENTRAL_DIRECTORY_END=\\\"PK\\u0006\\u0006\\\",c.DATA_DESCRIPTOR=\\\"PK\\u0007\\\\b\\\"},{}],24:[function(a,b,c){\\\"use strict\\\";function d(a){e.call(this,\\\"ConvertWorker to \\\"+a),this.destType=a}var e=a(\\\"./GenericWorker\\\"),f=a(\\\"../utils\\\");f.inherits(d,e),d.prototype.processChunk=function(a){this.push({data:f.transformTo(this.destType,a.data),meta:a.meta})},b.exports=d},{\\\"../utils\\\":32,\\\"./GenericWorker\\\":28}],25:[function(a,b,c){\\\"use strict\\\";function d(){e.call(this,\\\"Crc32Probe\\\"),this.withStreamInfo(\\\"crc32\\\",0)}var e=a(\\\"./GenericWorker\\\"),f=a(\\\"../crc32\\\"),g=a(\\\"../utils\\\");g.inherits(d,e),d.prototype.processChunk=function(a){this.streamInfo.crc32=f(a.data,this.streamInfo.crc32||0),this.push(a)},b.exports=d},{\\\"../crc32\\\":4,\\\"../utils\\\":32,\\\"./GenericWorker\\\":28}],26:[function(a,b,c){\\\"use strict\\\";function d(a){f.call(this,\\\"DataLengthProbe for \\\"+a),this.propName=a,this.withStreamInfo(a,0)}var e=a(\\\"../utils\\\"),f=a(\\\"./GenericWorker\\\");e.inherits(d,f),d.prototype.processChunk=function(a){if(a){var b=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=b+a.data.length}f.prototype.processChunk.call(this,a)},b.exports=d},{\\\"../utils\\\":32,\\\"./GenericWorker\\\":28}],27:[function(a,b,c){\\\"use strict\\\";function d(a){f.call(this,\\\"DataWorker\\\");var b=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type=\\\"\\\",this._tickScheduled=!1,a.then(function(a){b.dataIsReady=!0,b.data=a,b.max=a&&a.length||0,b.type=e.getTypeOf(a),b.isPaused||b._tickAndRepeat()},function(a){b.error(a)})}var e=a(\\\"../utils\\\"),f=a(\\\"./GenericWorker\\\"),g=16384;e.inherits(d,f),d.prototype.cleanUp=function(){f.prototype.cleanUp.call(this),this.data=null},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,e.delay(this._tickAndRepeat,[],this)),!0)},d.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(e.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},d.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var a=g,b=null,c=Math.min(this.max,this.index+a);if(this.index>=this.max)return this.end();switch(this.type){case\\\"string\\\":b=this.data.substring(this.index,c);break;case\\\"uint8array\\\":b=this.data.subarray(this.index,c);break;case\\\"array\\\":case\\\"nodebuffer\\\":b=this.data.slice(this.index,c)}return this.index=c,this.push({data:b,meta:{percent:this.max?this.index/this.max*100:0}})},b.exports=d},{\\\"../utils\\\":32,\\\"./GenericWorker\\\":28}],28:[function(a,b,c){\\\"use strict\\\";function d(a){this.name=a||\\\"default\\\",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}d.prototype={push:function(a){this.emit(\\\"data\\\",a)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit(\\\"end\\\"),this.cleanUp(),this.isFinished=!0}catch(a){this.emit(\\\"error\\\",a)}return!0},error:function(a){return!this.isFinished&&(this.isPaused?this.generatedError=a:(this.isFinished=!0,this.emit(\\\"error\\\",a),this.previous&&this.previous.error(a),this.cleanUp()),!0)},on:function(a,b){return this._listeners[a].push(b),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(a,b){if(this._listeners[a])for(var c=0;c<this._listeners[a].length;c++)this._listeners[a][c].call(this,b)},pipe:function(a){return a.registerPrevious(this)},registerPrevious:function(a){if(this.isLocked)throw new Error(\\\"The stream '\\\"+this+\\\"' has already been used.\\\");this.streamInfo=a.streamInfo,this.mergeStreamInfo(),this.previous=a;var b=this;return a.on(\\\"data\\\",function(a){b.processChunk(a)}),a.on(\\\"end\\\",function(){b.end()}),a.on(\\\"error\\\",function(a){b.error(a)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;this.isPaused=!1;var a=!1;return this.generatedError&&(this.error(this.generatedError),a=!0),this.previous&&this.previous.resume(),!a},flush:function(){},processChunk:function(a){this.push(a)},withStreamInfo:function(a,b){return this.extraStreamInfo[a]=b,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var a in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(a)&&(this.streamInfo[a]=this.extraStreamInfo[a])},lock:function(){if(this.isLocked)throw new Error(\\\"The stream '\\\"+this+\\\"' has already been used.\\\");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var a=\\\"Worker \\\"+this.name;return this.previous?this.previous+\\\" -> \\\"+a:a}},b.exports=d},{}],29:[function(a,b,c){\\\"use strict\\\";function d(a,b,c){switch(a){case\\\"blob\\\":return h.newBlob(h.transformTo(\\\"arraybuffer\\\",b),c);case\\\"base64\\\":return k.encode(b);default:return h.transformTo(a,b)}}function e(a,b){var c,d=0,e=null,f=0;for(c=0;c<b.length;c++)f+=b[c].length;switch(a){case\\\"string\\\":return b.join(\\\"\\\");case\\\"array\\\":return Array.prototype.concat.apply([],b);case\\\"uint8array\\\":for(e=new Uint8Array(f),c=0;c<b.length;c++)e.set(b[c],d),d+=b[c].length;return e;case\\\"nodebuffer\\\":return Buffer.concat(b);default:throw new Error(\\\"concat : unsupported type '\\\"+a+\\\"'\\\")}}function f(a,b){return new m.Promise(function(c,f){var g=[],h=a._internalType,i=a._outputType,j=a._mimeType;a.on(\\\"data\\\",function(a,c){g.push(a),b&&b(c)}).on(\\\"error\\\",function(a){g=[],f(a)}).on(\\\"end\\\",function(){try{var a=d(i,e(h,g),j);c(a)}catch(b){f(b)}g=[]}).resume()})}function g(a,b,c){var d=b;switch(b){case\\\"blob\\\":case\\\"arraybuffer\\\":d=\\\"uint8array\\\";break;case\\\"base64\\\":d=\\\"string\\\"}try{this._internalType=d,this._outputType=b,this._mimeType=c,h.checkSupport(d),this._worker=a.pipe(new i(d)),a.lock()}catch(e){this._worker=new j(\\\"error\\\"),this._worker.error(e)}}var h=a(\\\"../utils\\\"),i=a(\\\"./ConvertWorker\\\"),j=a(\\\"./GenericWorker\\\"),k=a(\\\"../base64\\\"),l=a(\\\"../support\\\"),m=a(\\\"../external\\\"),n=null;if(l.nodestream)try{n=a(\\\"../nodejs/NodejsStreamOutputAdapter\\\")}catch(o){}g.prototype={accumulate:function(a){return f(this,a)},on:function(a,b){var c=this;return\\\"data\\\"===a?this._worker.on(a,function(a){b.call(c,a.data,a.meta)}):this._worker.on(a,function(){h.delay(b,arguments,c)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(a){if(h.checkSupport(\\\"nodestream\\\"),\\\"nodebuffer\\\"!==this._outputType)throw new Error(this._outputType+\\\" is not supported by this method\\\");return new n(this,{objectMode:\\\"nodebuffer\\\"!==this._outputType},a)}},b.exports=g},{\\\"../base64\\\":1,\\\"../external\\\":6,\\\"../nodejs/NodejsStreamOutputAdapter\\\":13,\\\"../support\\\":30,\\\"../utils\\\":32,\\\"./ConvertWorker\\\":24,\\\"./GenericWorker\\\":28}],30:[function(a,b,c){\\\"use strict\\\";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer=\\\"undefined\\\"!=typeof ArrayBuffer&&\\\"undefined\\\"!=typeof Uint8Array,c.nodebuffer=\\\"undefined\\\"!=typeof Buffer,c.uint8array=\\\"undefined\\\"!=typeof Uint8Array,\\\"undefined\\\"==typeof ArrayBuffer)c.blob=!1;else{var d=new ArrayBuffer(0);try{c.blob=0===new Blob([d],{type:\\\"application/zip\\\"}).size}catch(e){try{var f=self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder,g=new f;g.append(d),c.blob=0===g.getBlob(\\\"application/zip\\\").size}catch(e){c.blob=!1}}}try{c.nodestream=!!a(\\\"readable-stream\\\").Readable}catch(e){c.nodestream=!1}},{\\\"readable-stream\\\":16}],31:[function(a,b,c){\\\"use strict\\\";function d(){i.call(this,\\\"utf-8 decode\\\"),this.leftOver=null}function e(){i.call(this,\\\"utf-8 encode\\\")}for(var f=a(\\\"./utils\\\"),g=a(\\\"./support\\\"),h=a(\\\"./nodejsUtils\\\"),i=a(\\\"./stream/GenericWorker\\\"),j=new Array(256),k=0;k<256;k++)j[k]=k>=252?6:k>=248?5:k>=240?4:k>=224?3:k>=192?2:1;j[254]=j[254]=1;var l=function(a){var b,c,d,e,f,h=a.length,i=0;for(e=0;e<h;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=g.uint8array?new Uint8Array(i):new Array(i),f=0,e=0;f<i;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),c<128?b[f++]=c:c<2048?(b[f++]=192|c>>>6,b[f++]=128|63&c):c<65536?(b[f++]=224|c>>>12,b[f++]=128|c>>>6&63,b[f++]=128|63&c):(b[f++]=240|c>>>18,b[f++]=128|c>>>12&63,b[f++]=128|c>>>6&63,b[f++]=128|63&c);return b},m=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+j[a[c]]>b?c:b},n=function(a){var b,c,d,e,g=a.length,h=new Array(2*g);for(c=0,b=0;b<g;)if(d=a[b++],d<128)h[c++]=d;else if(e=j[d],e>4)h[c++]=65533,b+=e-1;else{for(d&=2===e?31:3===e?15:7;e>1&&b<g;)d=d<<6|63&a[b++],e--;e>1?h[c++]=65533:d<65536?h[c++]=d:(d-=65536,h[c++]=55296|d>>10&1023,h[c++]=56320|1023&d)}return h.length!==c&&(h.subarray?h=h.subarray(0,c):h.length=c),f.applyFromCharCode(h)};c.utf8encode=function(a){return g.nodebuffer?h.newBufferFrom(a,\\\"utf-8\\\"):l(a)},c.utf8decode=function(a){return g.nodebuffer?f.transformTo(\\\"nodebuffer\\\",a).toString(\\\"utf-8\\\"):(a=f.transformTo(g.uint8array?\\\"uint8array\\\":\\\"array\\\",a),n(a))},f.inherits(d,i),d.prototype.processChunk=function(a){var b=f.transformTo(g.uint8array?\\\"uint8array\\\":\\\"array\\\",a.data);if(this.leftOver&&this.leftOver.length){if(g.uint8array){var d=b;b=new Uint8Array(d.length+this.leftOver.length),b.set(this.leftOver,0),b.set(d,this.leftOver.length)}else b=this.leftOver.concat(b);this.leftOver=null}var e=m(b),h=b;e!==b.length&&(g.uint8array?(h=b.subarray(0,e),this.leftOver=b.subarray(e,b.length)):(h=b.slice(0,e),this.leftOver=b.slice(e,b.length))),this.push({data:c.utf8decode(h),meta:a.meta})},d.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:c.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},c.Utf8DecodeWorker=d,f.inherits(e,i),e.prototype.processChunk=function(a){this.push({data:c.utf8encode(a.data),meta:a.meta})},c.Utf8EncodeWorker=e},{\\\"./nodejsUtils\\\":14,\\\"./stream/GenericWorker\\\":28,\\\"./support\\\":30,\\\"./utils\\\":32}],32:[function(a,b,c){\\\"use strict\\\";function d(a){var b=null;return b=i.uint8array?new Uint8Array(a.length):new Array(a.length),f(a,b)}function e(a){return a}function f(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function g(a){var b=65536,d=c.getTypeOf(a),e=!0;if(\\\"uint8array\\\"===d?e=n.applyCanBeUsed.uint8array:\\\"nodebuffer\\\"===d&&(e=n.applyCanBeUsed.nodebuffer),\\ne)for(;b>1;)try{return n.stringifyByChunk(a,d,b)}catch(f){b=Math.floor(b/2)}return n.stringifyByChar(a)}function h(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];return b}var i=a(\\\"./support\\\"),j=a(\\\"./base64\\\"),k=a(\\\"./nodejsUtils\\\"),l=a(\\\"set-immediate-shim\\\"),m=a(\\\"./external\\\");c.newBlob=function(a,b){c.checkSupport(\\\"blob\\\");try{return new Blob([a],{type:b})}catch(d){try{var e=self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder,f=new e;return f.append(a),f.getBlob(b)}catch(d){throw new Error(\\\"Bug : can't construct the Blob.\\\")}}};var n={stringifyByChunk:function(a,b,c){var d=[],e=0,f=a.length;if(f<=c)return String.fromCharCode.apply(null,a);for(;e<f;)\\\"array\\\"===b||\\\"nodebuffer\\\"===b?d.push(String.fromCharCode.apply(null,a.slice(e,Math.min(e+c,f)))):d.push(String.fromCharCode.apply(null,a.subarray(e,Math.min(e+c,f)))),e+=c;return d.join(\\\"\\\")},stringifyByChar:function(a){for(var b=\\\"\\\",c=0;c<a.length;c++)b+=String.fromCharCode(a[c]);return b},applyCanBeUsed:{uint8array:function(){try{return i.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(a){return!1}}(),nodebuffer:function(){try{return i.nodebuffer&&1===String.fromCharCode.apply(null,k.allocBuffer(1)).length}catch(a){return!1}}()}};c.applyFromCharCode=g;var o={};o.string={string:e,array:function(a){return f(a,new Array(a.length))},arraybuffer:function(a){return o.string.uint8array(a).buffer},uint8array:function(a){return f(a,new Uint8Array(a.length))},nodebuffer:function(a){return f(a,k.allocBuffer(a.length))}},o.array={string:g,array:e,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBufferFrom(a)}},o.arraybuffer={string:function(a){return g(new Uint8Array(a))},array:function(a){return h(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:e,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBufferFrom(new Uint8Array(a))}},o.uint8array={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:e,nodebuffer:function(a){return k.newBufferFrom(a)}},o.nodebuffer={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){return o.nodebuffer.uint8array(a).buffer},uint8array:function(a){return h(a,new Uint8Array(a.length))},nodebuffer:e},c.transformTo=function(a,b){if(b||(b=\\\"\\\"),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=o[d][a](b);return e},c.getTypeOf=function(a){return\\\"string\\\"==typeof a?\\\"string\\\":\\\"[object Array]\\\"===Object.prototype.toString.call(a)?\\\"array\\\":i.nodebuffer&&k.isBuffer(a)?\\\"nodebuffer\\\":i.uint8array&&a instanceof Uint8Array?\\\"uint8array\\\":i.arraybuffer&&a instanceof ArrayBuffer?\\\"arraybuffer\\\":void 0},c.checkSupport=function(a){var b=i[a.toLowerCase()];if(!b)throw new Error(a+\\\" is not supported by this platform\\\")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d=\\\"\\\";for(c=0;c<(a||\\\"\\\").length;c++)b=a.charCodeAt(c),d+=\\\"\\\\\\\\x\\\"+(b<16?\\\"0\\\":\\\"\\\")+b.toString(16).toUpperCase();return d},c.delay=function(a,b,c){l(function(){a.apply(c||null,b||[])})},c.inherits=function(a,b){var c=function(){};c.prototype=b.prototype,a.prototype=new c},c.extend=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&\\\"undefined\\\"==typeof c[b]&&(c[b]=arguments[a][b]);return c},c.prepareContent=function(a,b,e,f,g){var h=m.Promise.resolve(b).then(function(a){var b=i.blob&&(a instanceof Blob||[\\\"[object File]\\\",\\\"[object Blob]\\\"].indexOf(Object.prototype.toString.call(a))!==-1);return b&&\\\"undefined\\\"!=typeof FileReader?new m.Promise(function(b,c){var d=new FileReader;d.onload=function(a){b(a.target.result)},d.onerror=function(a){c(a.target.error)},d.readAsArrayBuffer(a)}):a});return h.then(function(b){var h=c.getTypeOf(b);return h?(\\\"arraybuffer\\\"===h?b=c.transformTo(\\\"uint8array\\\",b):\\\"string\\\"===h&&(g?b=j.decode(b):e&&f!==!0&&(b=d(b))),b):m.Promise.reject(new Error(\\\"Can't read the data of '\\\"+a+\\\"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\\\"))})}},{\\\"./base64\\\":1,\\\"./external\\\":6,\\\"./nodejsUtils\\\":14,\\\"./support\\\":30,\\\"set-immediate-shim\\\":54}],33:[function(a,b,c){\\\"use strict\\\";function d(a){this.files=[],this.loadOptions=a}var e=a(\\\"./reader/readerFor\\\"),f=a(\\\"./utils\\\"),g=a(\\\"./signature\\\"),h=a(\\\"./zipEntry\\\"),i=(a(\\\"./utf8\\\"),a(\\\"./support\\\"));d.prototype={checkSignature:function(a){if(!this.reader.readAndCheckSignature(a)){this.reader.index-=4;var b=this.reader.readString(4);throw new Error(\\\"Corrupted zip or bug: unexpected signature (\\\"+f.pretty(b)+\\\", expected \\\"+f.pretty(a)+\\\")\\\")}},isSignature:function(a,b){var c=this.reader.index;this.reader.setIndex(a);var d=this.reader.readString(4),e=d===b;return this.reader.setIndex(c),e},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var a=this.reader.readData(this.zipCommentLength),b=i.uint8array?\\\"uint8array\\\":\\\"array\\\",c=f.transformTo(b,a);this.zipComment=this.loadOptions.decodeFileName(c)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;e<d;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readData(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error(\\\"Multi-volumes zip are not supported\\\")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(g.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8(),b.processAttributes()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(g.CENTRAL_FILE_HEADER);)a=new h({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error(\\\"Corrupted zip or bug: expected \\\"+this.centralDirRecords+\\\" records in central dir, got \\\"+this.files.length)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(g.CENTRAL_DIRECTORY_END);if(a<0){var b=!this.isSignature(0,g.LOCAL_FILE_HEADER);throw b?new Error(\\\"Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\\\"):new Error(\\\"Corrupted zip: can't find end of central directory\\\")}this.reader.setIndex(a);var c=a;if(this.checkSignature(g.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===f.MAX_VALUE_16BITS||this.diskWithCentralDirStart===f.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===f.MAX_VALUE_16BITS||this.centralDirRecords===f.MAX_VALUE_16BITS||this.centralDirSize===f.MAX_VALUE_32BITS||this.centralDirOffset===f.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),a<0)throw new Error(\\\"Corrupted zip: can't find the ZIP64 end of central directory locator\\\");if(this.reader.setIndex(a),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,g.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error(\\\"Corrupted zip: can't find the ZIP64 end of central directory\\\");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var d=this.centralDirOffset+this.centralDirSize;this.zip64&&(d+=20,d+=12+this.zip64EndOfCentralSize);var e=c-d;if(e>0)this.isSignature(c,g.CENTRAL_FILE_HEADER)||(this.reader.zero=e);else if(e<0)throw new Error(\\\"Corrupted zip: missing \\\"+Math.abs(e)+\\\" bytes.\\\")},prepareReader:function(a){this.reader=e(a)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=d},{\\\"./reader/readerFor\\\":22,\\\"./signature\\\":23,\\\"./support\\\":30,\\\"./utf8\\\":31,\\\"./utils\\\":32,\\\"./zipEntry\\\":34}],34:[function(a,b,c){\\\"use strict\\\";function d(a,b){this.options=a,this.loadOptions=b}var e=a(\\\"./reader/readerFor\\\"),f=a(\\\"./utils\\\"),g=a(\\\"./compressedObject\\\"),h=a(\\\"./crc32\\\"),i=a(\\\"./utf8\\\"),j=a(\\\"./compressions\\\"),k=a(\\\"./support\\\"),l=0,m=3,n=function(a){for(var b in j)if(j.hasOwnProperty(b)&&j[b].magic===a)return j[b];return null};d.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readData(this.fileNameLength),a.skip(c),this.compressedSize===-1||this.uncompressedSize===-1)throw new Error(\\\"Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize === -1 || uncompressedSize === -1)\\\");if(b=n(this.compressionMethod),null===b)throw new Error(\\\"Corrupted zip : compression \\\"+f.pretty(this.compressionMethod)+\\\" unknown (inner file : \\\"+f.transformTo(\\\"string\\\",this.fileName)+\\\")\\\");this.decompressed=new g(this.compressedSize,this.uncompressedSize,this.crc32,b,a.readData(this.compressedSize))},readCentralPart:function(a){this.versionMadeBy=a.readInt(2),a.skip(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4);var b=a.readInt(2);if(this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error(\\\"Encrypted zip are not supported\\\");a.skip(b),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var a=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),a===l&&(this.dosPermissions=63&this.externalFileAttributes),a===m&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||\\\"/\\\"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(a){if(this.extraFields[1]){var b=e(this.extraFields[1].value);this.uncompressedSize===f.MAX_VALUE_32BITS&&(this.uncompressedSize=b.readInt(8)),this.compressedSize===f.MAX_VALUE_32BITS&&(this.compressedSize=b.readInt(8)),this.localHeaderOffset===f.MAX_VALUE_32BITS&&(this.localHeaderOffset=b.readInt(8)),this.diskNumberStart===f.MAX_VALUE_32BITS&&(this.diskNumberStart=b.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});a.index<e;)b=a.readInt(2),c=a.readInt(2),d=a.readData(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){var a=k.uint8array?\\\"uint8array\\\":\\\"array\\\";if(this.useUTF8())this.fileNameStr=i.utf8decode(this.fileName),this.fileCommentStr=i.utf8decode(this.fileComment);else{var b=this.findExtraFieldUnicodePath();if(null!==b)this.fileNameStr=b;else{var c=f.transformTo(a,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(c)}var d=this.findExtraFieldUnicodeComment();if(null!==d)this.fileCommentStr=d;else{var e=f.transformTo(a,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(e)}}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileName)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileComment)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null}},b.exports=d},{\\\"./compressedObject\\\":2,\\\"./compressions\\\":3,\\\"./crc32\\\":4,\\\"./reader/readerFor\\\":22,\\\"./support\\\":30,\\\"./utf8\\\":31,\\\"./utils\\\":32}],35:[function(a,b,c){\\\"use strict\\\";var d=a(\\\"./stream/StreamHelper\\\"),e=a(\\\"./stream/DataWorker\\\"),f=a(\\\"./utf8\\\"),g=a(\\\"./compressedObject\\\"),h=a(\\\"./stream/GenericWorker\\\"),i=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this.unixPermissions=c.unixPermissions,this.dosPermissions=c.dosPermissions,this._data=b,this._dataBinary=c.binary,this.options={compression:c.compression,compressionOptions:c.compressionOptions}};i.prototype={internalStream:function(a){var b=null,c=\\\"string\\\";try{if(!a)throw new Error(\\\"No output type specified.\\\");c=a.toLowerCase();var e=\\\"string\\\"===c||\\\"text\\\"===c;\\\"binarystring\\\"!==c&&\\\"text\\\"!==c||(c=\\\"string\\\"),b=this._decompressWorker();var g=!this._dataBinary;g&&!e&&(b=b.pipe(new f.Utf8EncodeWorker)),!g&&e&&(b=b.pipe(new f.Utf8DecodeWorker))}catch(i){b=new h(\\\"error\\\"),b.error(i)}return new d(b,c,\\\"\\\")},async:function(a,b){return this.internalStream(a).accumulate(b)},nodeStream:function(a,b){return this.internalStream(a||\\\"nodebuffer\\\").toNodejsStream(b)},_compressWorker:function(a,b){if(this._data instanceof g&&this._data.compression.magic===a.magic)return this._data.getCompressedWorker();var c=this._decompressWorker();return this._dataBinary||(c=c.pipe(new f.Utf8EncodeWorker)),g.createWorkerFrom(c,a,b)},_decompressWorker:function(){return this._data instanceof g?this._data.getContentWorker():this._data instanceof h?this._data:new e(this._data)}};for(var j=[\\\"asText\\\",\\\"asBinary\\\",\\\"asNodeBuffer\\\",\\\"asUint8Array\\\",\\\"asArrayBuffer\\\"],k=function(){throw new Error(\\\"This method has been removed in JSZip 3.0, please check the upgrade guide.\\\")},l=0;l<j.length;l++)i.prototype[j[l]]=k;b.exports=i},{\\\"./compressedObject\\\":2,\\\"./stream/DataWorker\\\":27,\\\"./stream/GenericWorker\\\":28,\\\"./stream/StreamHelper\\\":29,\\\"./utf8\\\":31}],36:[function(a,b,c){(function(a){\\\"use strict\\\";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode(\\\"\\\");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||\\\"undefined\\\"==typeof a.MessageChannel)e=\\\"document\\\"in a&&\\\"onreadystatechange\\\"in a.document.createElement(\\\"script\\\")?function(){var b=a.document.createElement(\\\"script\\\");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,\\\"undefined\\\"!=typeof global?global:\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{})},{}],37:[function(a,b,c){\\\"use strict\\\";function d(){}function e(a){if(\\\"function\\\"!=typeof a)throw new TypeError(\\\"resolver must be a function\\\");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,\\\"function\\\"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),\\\"function\\\"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(e){return p.reject(a,e)}d===a?p.reject(a,new TypeError(\\\"Cannot resolve promise with itself\\\")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&(\\\"object\\\"==typeof a||\\\"function\\\"==typeof a)&&\\\"function\\\"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);\\\"error\\\"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status=\\\"success\\\"}catch(d){c.status=\\\"error\\\",c.value=d}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if(\\\"[object Array]\\\"!==Object.prototype.toString.call(a))return this.reject(new TypeError(\\\"must be an array\\\"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if(\\\"[object Array]\\\"!==Object.prototype.toString.call(a))return this.reject(new TypeError(\\\"must be an array\\\"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a(\\\"immediate\\\"),p={},q=[\\\"REJECTED\\\"],r=[\\\"FULFILLED\\\"],s=[\\\"PENDING\\\"];b.exports=e,e.prototype[\\\"finally\\\"]=function(a){function b(b){function c(){return b}return d.resolve(a()).then(c)}function c(b){function c(){throw b}return d.resolve(a()).then(c)}if(\\\"function\\\"!=typeof a)return this;var d=this.constructor;return this.then(b,c)},e.prototype[\\\"catch\\\"]=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if(\\\"function\\\"!=typeof a&&this.state===r||\\\"function\\\"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){var e=this.state===r?a:b;g(c,e,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if(\\\"error\\\"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n},{immediate:36}],38:[function(a,b,c){\\\"use strict\\\";var d=a(\\\"./lib/utils/common\\\").assign,e=a(\\\"./lib/deflate\\\"),f=a(\\\"./lib/inflate\\\"),g=a(\\\"./lib/zlib/constants\\\"),h={};d(h,e,f,g),b.exports=h},{\\\"./lib/deflate\\\":39,\\\"./lib/inflate\\\":40,\\\"./lib/utils/common\\\":41,\\\"./lib/zlib/constants\\\":44}],39:[function(a,b,c){\\\"use strict\\\";function d(a){if(!(this instanceof d))return new d(a);this.options=i.assign({level:s,method:u,chunkSize:16384,windowBits:15,memLevel:8,strategy:t,to:\\\"\\\"},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg=\\\"\\\",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=h.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==p)throw new Error(k[c]);if(b.header&&h.deflateSetHeader(this.strm,b.header),b.dictionary){var e;if(e=\\\"string\\\"==typeof b.dictionary?j.string2buf(b.dictionary):\\\"[object ArrayBuffer]\\\"===m.call(b.dictionary)?new Uint8Array(b.dictionary):b.dictionary,c=h.deflateSetDictionary(this.strm,e),c!==p)throw new Error(k[c]);this._dict_set=!0}}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg||k[c.err];return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}function g(a,b){return b=b||{},b.gzip=!0,e(a,b)}var h=a(\\\"./zlib/deflate\\\"),i=a(\\\"./utils/common\\\"),j=a(\\\"./utils/strings\\\"),k=a(\\\"./zlib/messages\\\"),l=a(\\\"./zlib/zstream\\\"),m=Object.prototype.toString,n=0,o=4,p=0,q=1,r=2,s=-1,t=0,u=8;d.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?o:n,\\\"string\\\"==typeof a?e.input=j.string2buf(a):\\\"[object ArrayBuffer]\\\"===m.call(a)?e.input=new Uint8Array(a):e.input=a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new i.Buf8(f),e.next_out=0,e.avail_out=f),c=h.deflate(e,d),c!==q&&c!==p)return this.onEnd(c),this.ended=!0,!1;0!==e.avail_out&&(0!==e.avail_in||d!==o&&d!==r)||(\\\"string\\\"===this.options.to?this.onData(j.buf2binstring(i.shrinkBuf(e.output,e.next_out))):this.onData(i.shrinkBuf(e.output,e.next_out)))}while((e.avail_in>0||0===e.avail_out)&&c!==q);return d===o?(c=h.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===p):d!==r||(this.onEnd(p),e.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===p&&(\\\"string\\\"===this.options.to?this.result=this.chunks.join(\\\"\\\"):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=d,c.deflate=e,c.deflateRaw=f,c.gzip=g},{\\\"./utils/common\\\":41,\\\"./utils/strings\\\":42,\\\"./zlib/deflate\\\":46,\\\"./zlib/messages\\\":51,\\\"./zlib/zstream\\\":53}],40:[function(a,b,c){\\\"use strict\\\";function d(a){if(!(this instanceof d))return new d(a);this.options=h.assign({chunkSize:16384,windowBits:0,to:\\\"\\\"},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg=\\\"\\\",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=g.inflateInit2(this.strm,b.windowBits);if(c!==j.Z_OK)throw new Error(k[c]);this.header=new m,g.inflateGetHeader(this.strm,this.header)}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg||k[c.err];return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}var g=a(\\\"./zlib/inflate\\\"),h=a(\\\"./utils/common\\\"),i=a(\\\"./utils/strings\\\"),j=a(\\\"./zlib/constants\\\"),k=a(\\\"./zlib/messages\\\"),l=a(\\\"./zlib/zstream\\\"),m=a(\\\"./zlib/gzheader\\\"),n=Object.prototype.toString;d.prototype.push=function(a,b){var c,d,e,f,k,l,m=this.strm,o=this.options.chunkSize,p=this.options.dictionary,q=!1;if(this.ended)return!1;d=b===~~b?b:b===!0?j.Z_FINISH:j.Z_NO_FLUSH,\\\"string\\\"==typeof a?m.input=i.binstring2buf(a):\\\"[object ArrayBuffer]\\\"===n.call(a)?m.input=new Uint8Array(a):m.input=a,m.next_in=0,m.avail_in=m.input.length;do{if(0===m.avail_out&&(m.output=new h.Buf8(o),m.next_out=0,m.avail_out=o),c=g.inflate(m,j.Z_NO_FLUSH),c===j.Z_NEED_DICT&&p&&(l=\\\"string\\\"==typeof p?i.string2buf(p):\\\"[object ArrayBuffer]\\\"===n.call(p)?new Uint8Array(p):p,c=g.inflateSetDictionary(this.strm,l)),c===j.Z_BUF_ERROR&&q===!0&&(c=j.Z_OK,q=!1),c!==j.Z_STREAM_END&&c!==j.Z_OK)return this.onEnd(c),this.ended=!0,!1;m.next_out&&(0!==m.avail_out&&c!==j.Z_STREAM_END&&(0!==m.avail_in||d!==j.Z_FINISH&&d!==j.Z_SYNC_FLUSH)||(\\\"string\\\"===this.options.to?(e=i.utf8border(m.output,m.next_out),f=m.next_out-e,k=i.buf2string(m.output,e),m.next_out=f,m.avail_out=o-f,f&&h.arraySet(m.output,m.output,e,f,0),this.onData(k)):this.onData(h.shrinkBuf(m.output,m.next_out)))),0===m.avail_in&&0===m.avail_out&&(q=!0)}while((m.avail_in>0||0===m.avail_out)&&c!==j.Z_STREAM_END);return c===j.Z_STREAM_END&&(d=j.Z_FINISH),d===j.Z_FINISH?(c=g.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===j.Z_OK):d!==j.Z_SYNC_FLUSH||(this.onEnd(j.Z_OK),m.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===j.Z_OK&&(\\\"string\\\"===this.options.to?this.result=this.chunks.join(\\\"\\\"):this.result=h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=d,c.inflate=e,c.inflateRaw=f,c.ungzip=e},{\\\"./utils/common\\\":41,\\\"./utils/strings\\\":42,\\\"./zlib/constants\\\":44,\\\"./zlib/gzheader\\\":47,\\\"./zlib/inflate\\\":49,\\\"./zlib/messages\\\":51,\\\"./zlib/zstream\\\":53}],41:[function(a,b,c){\\\"use strict\\\";var d=\\\"undefined\\\"!=typeof Uint8Array&&\\\"undefined\\\"!=typeof Uint16Array&&\\\"undefined\\\"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if(\\\"object\\\"!=typeof c)throw new TypeError(c+\\\"must be non-object\\\");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;b<c;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;b<c;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],42:[function(a,b,c){\\\"use strict\\\";function d(a,b){if(b<65537&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c=\\\"\\\",d=0;d<b;d++)c+=String.fromCharCode(a[d]);return c}var e=a(\\\"./common\\\"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;j<256;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;f<h;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=new e.Buf8(i),g=0,f=0;g<i;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),c<128?b[g++]=c:c<2048?(b[g++]=192|c>>>6,b[g++]=128|63&c):c<65536?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;c<d;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;c<h;)if(f=a[c++],f<128)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&c<h;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:f<65536?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+i[a[c]]>b?c:b}},{\\\"./common\\\":41}],43:[function(a,b,c){\\\"use strict\\\";function d(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0}b.exports=d},{}],44:[function(a,b,c){\\\"use strict\\\";b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(a,b,c){\\\"use strict\\\";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=f,g=d+c;a^=-1;for(var h=d;h<g;h++)a=a>>>8^e[255&(a^b[h])];return a^-1}var f=d();b.exports=e},{}],46:[function(a,b,c){\\\"use strict\\\";function d(a,b){return a.msg=I[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(E.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){F._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,E.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=G(a.adler,b,e,c):2===a.state.wrap&&(a.adler=H(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-la?a.strstart-(a.w_size-la):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ka,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&f<m);if(d=ka-(m-f),f=m-ka,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-la)){E.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=ja)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+ja-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<ja)););}while(a.lookahead<la&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===J)return ua;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return ua;if(a.strstart-a.block_start>=a.w_size-la&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?ua:ua}function o(a,b){for(var c,d;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c)),a.match_length>=ja)if(d=F._tr_tally(a,a.strstart-a.match_start,a.match_length-ja),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=ja){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function p(a,b){for(var c,d,e;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=ja-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c),\\na.match_length<=5&&(a.strategy===U||a.match_length===ja&&a.strstart-a.match_start>4096)&&(a.match_length=ja-1)),a.prev_length>=ja&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-ja,d=F._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-ja),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=ja-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return ua}else if(a.match_available){if(d=F._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return ua}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=F._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ka){if(m(a),a.lookahead<=ka&&b===J)return ua;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=ja&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ka;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&e<f);a.match_length=ka-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=ja?(c=F._tr_tally(a,1,a.match_length-ja),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===J)return ua;break}if(a.match_length=0,c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function s(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e}function t(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=D[a.level].max_lazy,a.good_match=D[a.level].good_length,a.nice_match=D[a.level].nice_length,a.max_chain_length=D[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=ja-1,a.match_available=0,a.ins_h=0}function u(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=$,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new E.Buf16(2*ha),this.dyn_dtree=new E.Buf16(2*(2*fa+1)),this.bl_tree=new E.Buf16(2*(2*ga+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new E.Buf16(ia+1),this.heap=new E.Buf16(2*ea+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new E.Buf16(2*ea+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function v(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=Z,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?na:sa,a.adler=2===b.wrap?0:1,b.last_flush=J,F._tr_init(b),O):d(a,Q)}function w(a){var b=v(a);return b===O&&t(a.state),b}function x(a,b){return a&&a.state?2!==a.state.wrap?Q:(a.state.gzhead=b,O):Q}function y(a,b,c,e,f,g){if(!a)return Q;var h=1;if(b===T&&(b=6),e<0?(h=0,e=-e):e>15&&(h=2,e-=16),f<1||f>_||c!==$||e<8||e>15||b<0||b>9||g<0||g>X)return d(a,Q);8===e&&(e=9);var i=new u;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+ja-1)/ja),i.window=new E.Buf8(2*i.w_size),i.head=new E.Buf16(i.hash_size),i.prev=new E.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new E.Buf8(i.pending_buf_size),i.d_buf=1*i.lit_bufsize,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,w(a)}function z(a,b){return y(a,b,$,aa,ba,Y)}function A(a,b){var c,h,k,l;if(!a||!a.state||b>N||b<0)return a?d(a,Q):Q;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===ta&&b!==M)return d(a,0===a.avail_out?S:Q);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===na)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=H(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=oa):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,ya),h.status=sa);else{var m=$+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=V||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=ma),m+=31-m%31,h.status=sa,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===oa)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=pa)}else h.status=pa;if(h.status===pa)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=qa)}else h.status=qa;if(h.status===qa)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=ra)}else h.status=ra;if(h.status===ra&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=sa)):h.status=sa),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,O}else if(0===a.avail_in&&e(b)<=e(c)&&b!==M)return d(a,S);if(h.status===ta&&0!==a.avail_in)return d(a,S);if(0!==a.avail_in||0!==h.lookahead||b!==J&&h.status!==ta){var o=h.strategy===V?r(h,b):h.strategy===W?q(h,b):D[h.level].func(h,b);if(o!==wa&&o!==xa||(h.status=ta),o===ua||o===wa)return 0===a.avail_out&&(h.last_flush=-1),O;if(o===va&&(b===K?F._tr_align(h):b!==N&&(F._tr_stored_block(h,0,0,!1),b===L&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,O}return b!==M?O:h.wrap<=0?P:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?O:P)}function B(a){var b;return a&&a.state?(b=a.state.status,b!==na&&b!==oa&&b!==pa&&b!==qa&&b!==ra&&b!==sa&&b!==ta?d(a,Q):(a.state=null,b===sa?d(a,R):O)):Q}function C(a,b){var c,d,e,g,h,i,j,k,l=b.length;if(!a||!a.state)return Q;if(c=a.state,g=c.wrap,2===g||1===g&&c.status!==na||c.lookahead)return Q;for(1===g&&(a.adler=G(a.adler,b,l,0)),c.wrap=0,l>=c.w_size&&(0===g&&(f(c.head),c.strstart=0,c.block_start=0,c.insert=0),k=new E.Buf8(c.w_size),E.arraySet(k,b,l-c.w_size,c.w_size,0),b=k,l=c.w_size),h=a.avail_in,i=a.next_in,j=a.input,a.avail_in=l,a.next_in=0,a.input=b,m(c);c.lookahead>=ja;){d=c.strstart,e=c.lookahead-(ja-1);do c.ins_h=(c.ins_h<<c.hash_shift^c.window[d+ja-1])&c.hash_mask,c.prev[d&c.w_mask]=c.head[c.ins_h],c.head[c.ins_h]=d,d++;while(--e);c.strstart=d,c.lookahead=ja-1,m(c)}return c.strstart+=c.lookahead,c.block_start=c.strstart,c.insert=c.lookahead,c.lookahead=0,c.match_length=c.prev_length=ja-1,c.match_available=0,a.next_in=i,a.input=j,a.avail_in=h,c.wrap=g,O}var D,E=a(\\\"../utils/common\\\"),F=a(\\\"./trees\\\"),G=a(\\\"./adler32\\\"),H=a(\\\"./crc32\\\"),I=a(\\\"./messages\\\"),J=0,K=1,L=3,M=4,N=5,O=0,P=1,Q=-2,R=-3,S=-5,T=-1,U=1,V=2,W=3,X=4,Y=0,Z=2,$=8,_=9,aa=15,ba=8,ca=29,da=256,ea=da+1+ca,fa=30,ga=19,ha=2*ea+1,ia=15,ja=3,ka=258,la=ka+ja+1,ma=32,na=42,oa=69,pa=73,qa=91,ra=103,sa=113,ta=666,ua=1,va=2,wa=3,xa=4,ya=3;D=[new s(0,0,0,0,n),new s(4,4,8,4,o),new s(4,5,16,8,o),new s(4,6,32,32,o),new s(4,4,16,16,p),new s(8,16,32,32,p),new s(8,16,128,128,p),new s(8,32,128,256,p),new s(32,128,258,1024,p),new s(32,258,258,4096,p)],c.deflateInit=z,c.deflateInit2=y,c.deflateReset=w,c.deflateResetKeep=v,c.deflateSetHeader=x,c.deflate=A,c.deflateEnd=B,c.deflateSetDictionary=C,c.deflateInfo=\\\"pako deflate (from Nodeca project)\\\"},{\\\"../utils/common\\\":41,\\\"./adler32\\\":43,\\\"./crc32\\\":45,\\\"./messages\\\":51,\\\"./trees\\\":52}],47:[function(a,b,c){\\\"use strict\\\";function d(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\\\"\\\",this.comment=\\\"\\\",this.hcrc=0,this.done=!1}b.exports=d},{}],48:[function(a,b,c){\\\"use strict\\\";var d=30,e=12;b.exports=function(a,b){var c,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;c=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=c.dmax,l=c.wsize,m=c.whave,n=c.wnext,o=c.window,p=c.hold,q=c.bits,r=c.lencode,s=c.distcode,t=(1<<c.lenbits)-1,u=(1<<c.distbits)-1;a:do{q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){c.mode=e;break a}a.msg=\\\"invalid literal/length code\\\",c.mode=d;break a}x=65535&v,w&=15,w&&(q<w&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg=\\\"invalid distance code\\\",c.mode=d;break a}if(y=65535&v,w&=15,q<w&&(p+=B[f++]<<q,q+=8,q<w&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg=\\\"invalid distance too far back\\\",c.mode=d;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&c.sane){a.msg=\\\"invalid distance too far back\\\",c.mode=d;break a}if(z=0,A=o,0===n){if(z+=l-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(n<w){if(z+=l+n-w,w-=n,w<x){x-=w;do C[h++]=o[z++];while(--w);if(z=0,n<x){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(f<g&&h<j);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=f<g?5+(g-f):5-(f-g),a.avail_out=h<j?257+(j-h):257-(h-j),c.hold=p,c.bits=q}},{}],49:[function(a,b,c){\\\"use strict\\\";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new s.Buf16(320),this.work=new s.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg=\\\"\\\",b.wrap&&(a.adler=1&b.wrap),b.mode=L,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new s.Buf32(pa),b.distcode=b.distdyn=new s.Buf32(qa),b.sane=1,b.back=-1,D):G}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):G}function h(a,b){var c,d;return a&&a.state?(d=a.state,b<0?(c=0,b=-b):(c=(b>>4)+1,b<48&&(b&=15)),b&&(b<8||b>15)?G:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):G}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==D&&(a.state=null),c):G}function j(a){return i(a,sa)}function k(a){if(ta){var b;for(q=new s.Buf32(512),r=new s.Buf32(32),b=0;b<144;)a.lens[b++]=8;for(;b<256;)a.lens[b++]=9;for(;b<280;)a.lens[b++]=7;for(;b<288;)a.lens[b++]=8;for(w(y,a.lens,0,288,q,0,a.work,{bits:9}),b=0;b<32;)a.lens[b++]=5;w(z,a.lens,0,32,r,0,a.work,{bits:5}),ta=!1}a.lencode=q,a.lenbits=9,a.distcode=r,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new s.Buf8(f.wsize)),d>=f.wsize?(s.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),s.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(s.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,r,pa,qa,ra,sa,ta,ua,va,wa,xa,ya,za,Aa=0,Ba=new s.Buf8(4),Ca=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return G;c=a.state,c.mode===W&&(c.mode=X),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xa=D;a:for(;;)switch(c.mode){case L:if(0===c.wrap){c.mode=X;break}for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0),m=0,n=0,c.mode=M;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg=\\\"incorrect header check\\\",c.mode=ma;break}if((15&m)!==K){a.msg=\\\"unknown compression method\\\",c.mode=ma;break}if(m>>>=4,n-=4,wa=(15&m)+8,0===c.wbits)c.wbits=wa;else if(wa>c.wbits){a.msg=\\\"invalid window size\\\",c.mode=ma;break}c.dmax=1<<wa,a.adler=c.check=1,c.mode=512&m?U:W,m=0,n=0;break;case M:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==K){a.msg=\\\"unknown compression method\\\",c.mode=ma;break}if(57344&c.flags){a.msg=\\\"unknown header flags set\\\",c.mode=ma;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=N;case N:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,Ba[2]=m>>>16&255,Ba[3]=m>>>24&255,c.check=u(c.check,Ba,4,0)),m=0,n=0,c.mode=O;case O:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=P;case P:if(1024&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=Q;case Q:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wa=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),s.arraySet(c.head.extra,e,g,q,wa)),512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=R;case R:if(2048&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.name+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=S;case S:if(4096&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.comment+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.comment=null);c.mode=T;case T:if(512&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg=\\\"header crc mismatch\\\",c.mode=ma;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=W;break;case U:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=V;case V:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,F;a.adler=c.check=1,c.mode=W;case W:if(b===B||b===C)break a;case X:if(c.last){m>>>=7&n,n-=7&n,c.mode=ja;break}for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=Y;break;case 1:if(k(c),c.mode=ca,b===C){m>>>=2,n-=2;break a}break;case 2:c.mode=_;break;case 3:a.msg=\\\"invalid block type\\\",c.mode=ma}m>>>=2,n-=2;break;case Y:for(m>>>=7&n,n-=7&n;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg=\\\"invalid stored block lengths\\\",c.mode=ma;break}if(c.length=65535&m,m=0,n=0,c.mode=Z,b===C)break a;case Z:c.mode=$;case $:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;s.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=W;break;case _:for(;n<14;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg=\\\"too many length or distance symbols\\\",c.mode=ma;break}c.have=0,c.mode=aa;case aa:for(;c.have<c.ncode;){for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Ca[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Ca[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,ya={bits:c.lenbits},xa=w(x,c.lens,0,19,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg=\\\"invalid code lengths set\\\",c.mode=ma;break}c.have=0,c.mode=ba;case ba:for(;c.have<c.nlen+c.ndist;){for(;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(sa<16)m>>>=qa,n-=qa,c.lens[c.have++]=sa;else{if(16===sa){for(za=qa+2;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qa,n-=qa,0===c.have){a.msg=\\\"invalid bit length repeat\\\",c.mode=ma;break}wa=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sa){for(za=qa+3;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=3+(7&m),m>>>=3,n-=3}else{for(za=qa+7;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg=\\\"invalid bit length repeat\\\",c.mode=ma;break}for(;q--;)c.lens[c.have++]=wa}}if(c.mode===ma)break;if(0===c.lens[256]){a.msg=\\\"invalid code -- missing end-of-block\\\",c.mode=ma;break}if(c.lenbits=9,ya={bits:c.lenbits},xa=w(y,c.lens,0,c.nlen,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg=\\\"invalid literal/lengths set\\\",c.mode=ma;break}if(c.distbits=6,c.distcode=c.distdyn,ya={bits:c.distbits},xa=w(z,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,ya),c.distbits=ya.bits,xa){a.msg=\\\"invalid distances set\\\",c.mode=ma;break}if(c.mode=ca,b===C)break a;case ca:c.mode=da;case da:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,v(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===W&&(c.back=-1);break}for(c.back=0;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(ra&&0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.lencode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,c.length=sa,0===ra){c.mode=ia;break}if(32&ra){c.back=-1,c.mode=W;break}if(64&ra){a.msg=\\\"invalid literal/length code\\\",c.mode=ma;break}c.extra=15&ra,c.mode=ea;case ea:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=fa;case fa:for(;Aa=c.distcode[m&(1<<c.distbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.distcode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,64&ra){a.msg=\\\"invalid distance code\\\",c.mode=ma;break}c.offset=sa,c.extra=15&ra,c.mode=ga;case ga:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg=\\\"invalid distance too far back\\\",c.mode=ma;break}c.mode=ha;case ha:if(0===j)break a;if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg=\\\"invalid distance too far back\\\",c.mode=ma;break}q>c.wnext?(q-=c.wnext,r=c.wsize-q):r=c.wnext-q,q>c.length&&(q=c.length),pa=c.window}else pa=f,r=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pa[r++];while(--q);0===c.length&&(c.mode=da);break;case ia:if(0===j)break a;f[h++]=c.length,j--,c.mode=da;break;case ja:if(c.wrap){for(;n<32;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?u(c.check,f,p,h-p):t(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg=\\\"incorrect data check\\\",c.mode=ma;break}m=0,n=0}c.mode=ka;case ka:if(c.wrap&&c.flags){for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg=\\\"incorrect length check\\\",c.mode=ma;break}m=0,n=0}c.mode=la;case la:xa=E;break a;case ma:xa=H;break a;case na:return I;case oa:default:return G}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<ma&&(c.mode<ja||b!==A))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=na,I):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?u(c.check,f,p,a.next_out-p):t(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===W?128:0)+(c.mode===ca||c.mode===Z?256:0),(0===o&&0===p||b===A)&&xa===D&&(xa=J),xa)}function n(a){if(!a||!a.state)return G;var b=a.state;return b.window&&(b.window=null),a.state=null,D}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?G:(c.head=b,b.done=!1,D)):G}function p(a,b){var c,d,e,f=b.length;return a&&a.state?(c=a.state,0!==c.wrap&&c.mode!==V?G:c.mode===V&&(d=1,d=t(d,b,f,0),d!==c.check)?H:(e=l(a,b,f,f))?(c.mode=na,I):(c.havedict=1,D)):G}var q,r,s=a(\\\"../utils/common\\\"),t=a(\\\"./adler32\\\"),u=a(\\\"./crc32\\\"),v=a(\\\"./inffast\\\"),w=a(\\\"./inftrees\\\"),x=0,y=1,z=2,A=4,B=5,C=6,D=0,E=1,F=2,G=-2,H=-3,I=-4,J=-5,K=8,L=1,M=2,N=3,O=4,P=5,Q=6,R=7,S=8,T=9,U=10,V=11,W=12,X=13,Y=14,Z=15,$=16,_=17,aa=18,ba=19,ca=20,da=21,ea=22,fa=23,ga=24,ha=25,ia=26,ja=27,ka=28,la=29,ma=30,na=31,oa=32,pa=852,qa=592,ra=15,sa=ra,ta=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateSetDictionary=p,c.inflateInfo=\\\"pako inflate (from Nodeca project)\\\"},{\\\"../utils/common\\\":41,\\\"./adler32\\\":43,\\\"./crc32\\\":45,\\\"./inffast\\\":48,\\\"./inftrees\\\":50}],50:[function(a,b,c){\\\"use strict\\\";var d=a(\\\"../utils/common\\\"),e=15,f=852,g=592,h=0,i=1,j=2,k=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],l=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],m=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],n=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,c,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new d.Buf16(e+1),Q=new d.Buf16(e+1),R=null,S=0;for(D=0;D<=e;D++)P[D]=0;for(E=0;E<o;E++)P[b[c+E]]++;for(H=C,G=e;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;F<G&&0===P[F];F++);for(H<F&&(H=F),K=1,D=1;D<=e;D++)if(K<<=1,K-=P[D],K<0)return-1;if(K>0&&(a===h||1!==G))return-1;for(Q[1]=0,D=1;D<e;D++)Q[D+1]=Q[D]+P[D];for(E=0;E<o;E++)0!==b[c+E]&&(r[Q[b[c+E]]++]=E);if(a===h?(N=R=r,y=19):a===i?(N=k,O-=257,R=l,S-=257,y=256):(N=m,R=n,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===i&&L>f||a===j&&L>g)return 1;for(;;){z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[c+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;I+J<G&&(K-=P[I+J],!(K<=0));)I++,K<<=1;if(L+=1<<I,a===i&&L>f||a===j&&L>g)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{\\\"../utils/common\\\":41}],51:[function(a,b,c){\\\"use strict\\\";b.exports={2:\\\"need dictionary\\\",1:\\\"stream end\\\",0:\\\"\\\",\\\"-1\\\":\\\"file error\\\",\\\"-2\\\":\\\"stream error\\\",\\\"-3\\\":\\\"data error\\\",\\\"-4\\\":\\\"insufficient memory\\\",\\\"-5\\\":\\\"buffer error\\\",\\\"-6\\\":\\\"incompatible version\\\"}},{}],52:[function(a,b,c){\\\"use strict\\\";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length}function f(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b}function g(a){return a<256?ia[a]:ia[256+(a>>>7)]}function h(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function i(a,b,c){a.bi_valid>X-c?(a.bi_buf|=b<<a.bi_valid&65535,h(a,a.bi_buf),a.bi_buf=b>>X-a.bi_valid,a.bi_valid+=c-X):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function j(a,b,c){i(a,c[2*b],c[2*b+1])}function k(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function l(a){16===a.bi_valid?(h(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function m(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;f<=W;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,c=a.heap_max+1;c<V;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function n(a,b,c){var d,e,f=new Array(W+1),g=0;for(d=1;d<=W;d++)f[d]=g=g+c[d-1]<<1;for(e=0;e<=b;e++){var h=a[2*e+1];0!==h&&(a[2*e]=k(f[h]++,h))}}function o(){var a,b,c,d,f,g=new Array(W+1);for(c=0,d=0;d<Q-1;d++)for(ka[d]=c,a=0;a<1<<ba[d];a++)ja[c++]=d;for(ja[c-1]=d,f=0,d=0;d<16;d++)for(la[d]=f,a=0;a<1<<ca[d];a++)ia[f++]=d;for(f>>=7;d<T;d++)for(la[d]=f<<7,a=0;a<1<<ca[d]-7;a++)ia[256+f++]=d;for(b=0;b<=W;b++)g[b]=0;for(a=0;a<=143;)ga[2*a+1]=8,a++,g[8]++;for(;a<=255;)ga[2*a+1]=9,a++,g[9]++;for(;a<=279;)ga[2*a+1]=7,a++,g[7]++;for(;a<=287;)ga[2*a+1]=8,a++,g[8]++;for(n(ga,S+1,g),a=0;a<T;a++)ha[2*a+1]=5,ha[2*a]=k(a,5);ma=new e(ga,ba,R+1,S,W),na=new e(ha,ca,0,T,W),oa=new e(new Array(0),da,0,U,Y)}function p(a){var b;for(b=0;b<S;b++)a.dyn_ltree[2*b]=0;for(b=0;b<T;b++)a.dyn_dtree[2*b]=0;for(b=0;b<U;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*Z]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function q(a){a.bi_valid>8?h(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function r(a,b,c,d){q(a),d&&(h(a,c),h(a,~c)),G.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function s(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function t(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&s(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!s(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function u(a,b,c){var d,e,f,h,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],e=a.pending_buf[a.l_buf+k],k++,0===d?j(a,e,b):(f=ja[e],j(a,f+R+1,b),h=ba[f],0!==h&&(e-=ka[f],i(a,e,h)),d--,f=g(d),j(a,f,c),h=ca[f],0!==h&&(d-=la[f],i(a,d,h)));while(k<a.last_lit);j(a,Z,b)}function v(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=V,c=0;c<i;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=j<2?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)t(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],t(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,t(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],m(a,b),n(f,j,a.bl_count)}function w(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;d<=c;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(h<j?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*$]++):h<=10?a.bl_tree[2*_]++:a.bl_tree[2*aa]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function x(a,b,c){var d,e,f=-1,g=b[1],h=0,k=7,l=4;for(0===g&&(k=138,l=3),d=0;d<=c;d++)if(e=g,g=b[2*(d+1)+1],!(++h<k&&e===g)){if(h<l){do j(a,e,a.bl_tree);while(0!==--h)}else 0!==e?(e!==f&&(j(a,e,a.bl_tree),h--),j(a,$,a.bl_tree),i(a,h-3,2)):h<=10?(j(a,_,a.bl_tree),i(a,h-3,3)):(j(a,aa,a.bl_tree),i(a,h-11,7));h=0,f=e,0===g?(k=138,l=3):e===g?(k=6,l=3):(k=7,l=4)}}function y(a){var b;for(w(a,a.dyn_ltree,a.l_desc.max_code),w(a,a.dyn_dtree,a.d_desc.max_code),v(a,a.bl_desc),b=U-1;b>=3&&0===a.bl_tree[2*ea[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function z(a,b,c,d){var e;for(i(a,b-257,5),i(a,c-1,5),i(a,d-4,4),e=0;e<d;e++)i(a,a.bl_tree[2*ea[e]+1],3);x(a,a.dyn_ltree,b-1),x(a,a.dyn_dtree,c-1)}function A(a){var b,c=4093624447;for(b=0;b<=31;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return I;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return J;for(b=32;b<R;b++)if(0!==a.dyn_ltree[2*b])return J;return I}function B(a){pa||(o(),pa=!0),a.l_desc=new f(a.dyn_ltree,ma),a.d_desc=new f(a.dyn_dtree,na),a.bl_desc=new f(a.bl_tree,oa),a.bi_buf=0,a.bi_valid=0,p(a)}function C(a,b,c,d){i(a,(L<<1)+(d?1:0),3),r(a,b,c,!0)}function D(a){i(a,M<<1,3),j(a,Z,ga),l(a)}function E(a,b,c,d){var e,f,g=0;a.level>0?(a.strm.data_type===K&&(a.strm.data_type=A(a)),v(a,a.l_desc),v(a,a.d_desc),g=y(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,f<=e&&(e=f)):e=f=c+5,c+4<=e&&b!==-1?C(a,b,c,d):a.strategy===H||f===e?(i(a,(M<<1)+(d?1:0),3),u(a,ga,ha)):(i(a,(N<<1)+(d?1:0),3),z(a,a.l_desc.max_code+1,a.d_desc.max_code+1,g+1),u(a,a.dyn_ltree,a.dyn_dtree)),p(a),d&&q(a)}function F(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(ja[c]+R+1)]++,a.dyn_dtree[2*g(b)]++),a.last_lit===a.lit_bufsize-1}var G=a(\\\"../utils/common\\\"),H=4,I=0,J=1,K=2,L=0,M=1,N=2,O=3,P=258,Q=29,R=256,S=R+1+Q,T=30,U=19,V=2*S+1,W=15,X=16,Y=7,Z=256,$=16,_=17,aa=18,ba=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ca=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],da=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ea=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa=512,ga=new Array(2*(S+2));\\nd(ga);var ha=new Array(2*T);d(ha);var ia=new Array(fa);d(ia);var ja=new Array(P-O+1);d(ja);var ka=new Array(Q);d(ka);var la=new Array(T);d(la);var ma,na,oa,pa=!1;c._tr_init=B,c._tr_stored_block=C,c._tr_flush_block=E,c._tr_tally=F,c._tr_align=D},{\\\"../utils/common\\\":41}],53:[function(a,b,c){\\\"use strict\\\";function d(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\\\"\\\",this.state=null,this.data_type=2,this.adler=0}b.exports=d},{}],54:[function(a,b,c){\\\"use strict\\\";b.exports=\\\"function\\\"==typeof setImmediate?setImmediate:function(){var a=[].slice.apply(arguments);a.splice(1,0,0),setTimeout.apply(null,a)}},{}]},{},[10])(10)});\\n})();\",\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/OokTech/Bob/External/jszip/jszip.js\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/FederatedChatMessageHandlers.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/FederatedChatMessageHandlers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/Federation/FederatedChatMessageHandlers.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThese are message handler functions for the federated chat server.\\nThis handles messages sent to the node process.\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"federation-chat-messages\\\";\\nexports.platforms = [\\\"node\\\"];\\nexports.after = [\\\"render\\\"];\\nexports.synchronous = true;\\n\\nif(false && $tw.node && $tw.settings.enableFederation === 'yes') {\\n  $tw.Bob.Federation = $tw.Bob.Federation || {};\\n  $tw.Bob.Federation.remoteConnections = $tw.Bob.Federation.remoteConnections || {};\\n  $tw.Bob.Federation.messageHandlers = $tw.Bob.Federation.messageHandlers || {};\\n\\n  /*\\n    Receive a federated chat message\\n  */\\n  $tw.Bob.Federation.messageHandlers.chatMessage = function(data) {\\n    data.wiki = data.wiki || 'RootWiki';\\n    const conversationTiddler = data.conversation || 'DefaultChat';\\n    if (conversationTiddler && data.message) {\\n      // Get the history tiddler\\n      const historyTiddler = $tw.Bob.Wikis[data.wiki].wiki.getTiddler(`$:/chat/${conversationTiddler}`);\\n      let history = {};\\n      if (historyTiddler) {\\n        // Make sure that the fields aren't read only\\n        history = JSON.parse(JSON.stringify(historyTiddler.fields.text));\\n      }\\n      const theTime = $tw.utils.stringifyDate(new Date());\\n      history = JSON.parse(history) || history;\\n      history[theTime] = {\\n        message:data.message,\\n        from: data.from,\\n        server: data.server\\n      }\\n      // save the updated tiddler\\n      $tw.syncadaptor.saveTiddler(new $tw.Tiddler({\\n        text:JSON.stringify(history, null, 2),\\n        title: `$:/chat/${conversationTiddler}`,\\n        type: 'application/json'\\n      }), data.wiki);\\n    }\\n  }\\n\\n  /*\\n    Receive a chat history from a federated server\\n\\n    This is for when you join an existing conversation.\\n\\n    It combines the local messages with the received messages.\\n  */\\n  $tw.Bob.Federation.messageHandlers.chatHistory = function(data) {\\n    //$tw.Bob.Shared.sendAck(data);\\n    const conversationTiddler = data.conversation || 'DefaultChat'\\n    if (data.conversation && data.messages) {\\n      // Get the history tiddler\\n      const historyTiddler = $tw.Bob.Wikis[data.wiki].wiki.getTiddler(`$:/chat/${conversationTiddler}`)\\n      let history = {}\\n      if (historyTiddler) {\\n        // Update the history tiddler\\n        history = JSON.parse(JSON.stringify(historyTiddler.fields));\\n      }\\n      Object.keys(data.messages).forEach(function(message) {\\n        history[message.time] = {\\n          message: message.message,\\n          from: message.from || ''\\n        }\\n      })\\n      // save the updated tiddler\\n      $tw.syncadaptor.saveTiddler(new $tw.Tiddler({\\n        text:JSON.stringify(history, null, 2),\\n        title: `$:/chat/${conversationTiddler}`,\\n        type: 'application/json'\\n      }), data.wiki);\\n    }\\n  }\\n}\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/FederatedNodeDiscovery\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/FederatedNodeDiscovery\",\n            \"text\": \"For the local network multicast udp is used to discover other Bob servers to\\nfederate with.\\n\\nIf you have your server set up to announce itself than it will use a multicast\\nmessage on the local network to let any other Bob servers know that it is\\nthere.\\n\\nFor nodes that are off the local network I will use Dodo. I am not sure about\\npackaging that with Bob.\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/FederationSyncing\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/FederationSyncing\",\n            \"text\": \"Federated syncing refers to two separate servers syncing the state of a wiki on\\neach server.\\nEach server uses its wikis normally without external influence, but when\\ndesired two servers can share their changes to a wiki so both servers have the\\nsame information.\\n\\nPerhaps the most useful case for this is to have Bob running on multiple\\ncomputers (like a desktop at home and a laptop that travels), when the\\ncomputers aren't in the same location each one can use Bob and edit the wikis\\nhowever they wish.\\nWhen the two computers are on the same network they can sync their changes.\\n\\n!! The process\\n\\nDue to the security model used syncing can be two-way, but two way syncing is\\none way syncing done by each server separately.\\nThis is because nothing that affects a server can be initiated by another\\nserver.\\n\\n!!! A high level view\\n\\n# Server A wants to sync\\n# Server A asks server B for all of the tiddlers that are different in the wiki they want to sync\\n# Server B sends the tiddlers to server A\\n# Server A saves the tiddlers\\n\\n!!! A lower level view\\n\\nThe way that syncing works at a relatively low level is:\\n\\n# Server A wishes to sync a wiki with server B\\n# Server A sends a `requestHashes` message to server B\\n#* The message contains:\\n#** A filter that determines which tiddlers server A wants hashes for\\n#** The name of the wiki server A wants information about\\n#** A nonce (see [[FederatedSecurity|$:/plugins/OokTech/Bob/Federation/FederationSecurity]])\\n# Server B receives the message and collects the tiddlers from the requested wiki that match the supplied filter.\\n# Server B calculates the hashes for each of the collected tiddlers and sends a `sendHashes` message to server A\\n#* The message contains:\\n#** The nonce send by server A with the `requestHashes`\\n#** The tiddler hashes\\n#** The name of the wiki that the tiddlers are from\\n# Server A receives the message and checks the hashes in the message against the tiddler hashes in its local wiki and makes a list of tiddlers that are different\\n# Server A sends a `requestTiddlers` message to server B that lists all of the changed tiddlers\\n#* The message contains:\\n#** A filter that is a title list of all of the changed tiddlers\\n#** The name of the wiki the tiddlers are from\\n#** A new nonce\\n# Server B receives the `requestTiddlers` message and collects the requested tiddlers from the listed wiki\\n# Server B sends a `sendTiddlers` message to server A that contains the requested tiddlers\\n#* The message contains:\\n#** The tiddlers requested\\n#** The nonce sent by server A\\n# Server A receives the `sendTiddlers` message and saves the received tiddlers using whatever conflict resolution method is set.\\n\\n!! Conflicts\\n\\nWhen two wikis want to sync and the same tiddler has been modified on both\\nwikis there needs to be some conflict resolution method.\\n\\nThe current options are:\\n\\n* `localWins` - if the conflict type is `localWins` no changes are made to existing local tiddlers regardless of the state of the remote wiki. Only new tiddlers from the remote wiki are imported.\\n* `remoteWins` - if the conflict type is `remoteWins` all the remote tiddlers are imported regardless of if they exist on the local wiki or not.\\n* `newestWins` - if the conflict type is `newestWins` and a tiddler with the same title exists in both wikis the tiddler that has the largest value in the modified fields is saved. If only one tiddler has a modified field that tiddler is saved, if neither tiddler has a modified field the local one is kept.\\n* `oldestWins` - in case of conflict the tiddler with the smallest value in the modified field is saved. If only one tiddler has a modified field the other tiddler is saved, if neither tiddler has a modified field the local one is kept.\\n* `manual` - the local tiddler is kept and a copy of the remote tiddler is saved with `$:/SyncingConflict/` prepended to the title. In this case no tiddlers that have the prefix `$:/SyncingConflict/` are saved to prevent infinite loops.\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/FederationSecurity\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/FederationSecurity\",\n            \"text\": \"* means that it expects a reply\\n-> means it is the reply\\n\\n* requestServerInfo\\n-> sendServerInfo\\n\\n* requestHashes\\n-> sendHashes\\n\\n* requestTiddlers\\n-> sendTiddlers\\n\\n!!! requestServerInfo\\n\\nsend: Nothing\\n\\nreceive: server info\\n\\nRequest details about the remote server, response is `sendInfo`\\n\\n!!! requestHash\\n\\nsend:\\n\\n* wikiName\\n* filter\\n\\nreceive:\\n\\n* one hash for all of returned tiddlers\\n** normalise all of the tiddlers, get their hashes, get the hash of all of the hashes with the tiddlers sorted\\n\\n!!! requestHashes\\n\\nsend:\\n\\n* wikiName\\n* filter\\n\\nreceive:\\n\\n* hashes for each of the tiddlers returned by the filter\\n\\nRequest a set of tiddler hashes from the remote server. Use them to determine\\nif there have been changes to the tiddlers.\\n\\n!!! requestTiddlers\\n\\nsend:\\n\\n* wikiName\\n* filter\\n\\nreceive:\\n\\n* tiddlers in json format\\n\\nrequest a set of tiddlers from the remote server.\\n\\n!!! requestRemoteSync\\n\\nRequest remote sync asks the other server to sync changes from your server.\\n\\n# -> requestRemoteSync\\n# <- requestHashes\\n# -> sendHashes\\n# <- requestTiddlers\\n# -> sendTiddlers\\n\\nan rnonce is sent with each *, it is put into the response as a nonce.\\n\\nThe basic structure of communication between different servers is the same as\\nthe communication between a server and connected browsers.\\n\\nInformation is sent in discrete messages in JSON format.\\nEach message has a `type` property that determines how it is handled.\\n\\nNew functionality is added by creating new message types and handlers.\\n\\n!Security\\n\\n''Security is a work in progress, this shouldn't be used anywhere that is\\naccessible outside a local network until more work is done.''\\n\\n!!nonce\\n\\n''Note:'' for the moment the nonce is generated using the `Math.random`\\nfunction which does not generate random numbers suitable for security in\\nproduction environments, this is just a stop-gap until a better system is made.\\nOne benefit of the nonce, even an insecure one like this, is that it allows a\\nserver to make a request without informing the remote server of anything other\\nthan that the request is being made, the nonce being sent back with the\\nresponse allows the requesting server to match the response with the correct\\nwiki without having to send out the information.\\n\\nThe most basic component for security is anything that affects the local server\\nmust originate from the local server.\\nTo achieve this we use the nonce concept.\\n\\nAny message that changes the local server has to come as a response to a\\nrequest by the local server, to enforce this the local server will only accept\\nincoming messages that make local changes if they are in response to a request.\\n\\nBecause the server is mostly stateless in its responses (that is responses are\\nnot affected by anything other than the tiddlers and wikis on the server) there\\nisn't a record of currently active transactions or communication past the\\ncurrent message queue. So to ensure that an incoming message is in response to\\na request a unique random number (called a nonce) is added to any outgoing\\nrequest and saved with the request type until a response matching the nonce is\\nreturned.\\n\\nThis means that the server is no longer stateless. We are looking into ways to\\nchange this in the future.\\n\\n!!!Messages that use nonce\\n\\nMessages that make requests or otherwise don't affect the receiving server\\ndon't require a nonce.\\nThey will require proper authentication on servers that support it.\\n\\nMessages that make requests from a server don't use a nonce themselves, but\\nthey come with one that gets returned with the response.\\n\\nOutgoing nonces are put in the key `rnonce`.\\n\\n!!encryption\\n\\n''This is unimplemented''\\n\\n!!cryptographic signing\\n\\n''This is unimplemented''\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/FederationSharedFunctions.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/FederationSharedFunctions.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/Federation/FederationSharedFunctions.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThis has some functions that are needed by Bob in different places.\\n\\n\\\\*/\\n(function () {\\n\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  // Export name and synchronous status\\n  exports.name = \\\"federation-shared-functions\\\";\\n  exports.platforms = [\\\"node\\\"];\\n  exports.after = [\\\"render\\\"];\\n  exports.synchronous = true;\\n\\n  if(false && $tw.node && $tw.settings.enableFederation === 'yes') {\\n\\n    let idNumber = 0;\\n    let messageQueue = [];\\n    let messageQueueTimer = false;\\n\\n    $tw.Bob = $tw.Bob || {};\\n    $tw.Bob.Federation = $tw.Bob.Federation || {};\\n    $tw.Bob.Federation.connections = $tw.Bob.Federation.connections || {};\\n    $tw.Bob.Federation.nonce = $tw.Bob.Federation.nonce || [];\\n    $tw.settings.federation = $tw.settings.federation || {};\\n    $tw.settings.advanced = $tw.settings.advanced || {};\\n\\n    /*\\n      This function checks the message queue to see if anything should be done.\\n\\n      It first checks to see if there are any messages in the message queue, if\\n      not than it does nothing other than removing the timer to recheck the\\n      queue. The timer is restarted elsewhere if a message is sent.\\n\\n      It then prunes the message queue, removing any messages that have been\\n      send and acknoweldeged so there is nothing more to do with them.\\n\\n      It then checks any remaining messages to check if there are any that are\\n      older than 500ms.\\n      These messages are assumed to have been missed by the other end and are\\n      resent.\\n\\n      If the queue isn't empty the timeout is reset for this function to run\\n      again in 500ms\\n    */\\n    function checkMessageQueue() {\\n      // If the queue isn't empty\\n      if(messageQueue.length > 0) {\\n        // Remove messages that have already been sent and have received all\\n        // their acks and have waited the required amonut of time.\\n        //messageQueue = pruneMessageQueue(messageQueue);\\n        clearTimeout(messageQueueTimer);\\n        // Check if there are any messages that are more than 500ms old and have\\n        // not received the acks expected.\\n        // These are assumed to have been lost and need to be resent\\n        if(messageQueue.length > 0) {\\n          const theMessage = messageQueue.shift();\\n          sendMessage(theMessage);\\n        }\\n      } else {\\n        clearTimeout(messageQueueTimer);\\n        messageQueueTimer = setTimeout(checkMessageQueue, $tw.settings.advanced.federatedMessageQueueTimeout || 500);\\n      }\\n    }\\n\\n    /*\\n      This returns a new id for a message.\\n      Federated message ids start with f, the same counter is used for every\\n      server.\\n    */\\n    function makeId() {\\n      idNumber = idNumber + 1;\\n      const newId = 'f' + idNumber;\\n      return newId;\\n    }\\n\\n    /*\\n      This takes a new message and a message queue.\\n\\n      It returns an updated queue that has any messages made irrelevant by the\\n      new message removed.\\n\\n      Irrelevant messages are defined as:\\n\\n      - any message that has the same id as the new message\\n      - any message that are an exact copy of the new message\\n    */\\n    function removeRedundantMessages(messageData, queue) {\\n      // Get a list of any duplicate messages or any that are now redundant\\n      // because of the new message.\\n      const duplicateIndicies = queue.map(function(item, index) {\\n        // Messages with the same id are the same message and not considered\\n        // redudant here. There are other checks to make sure that the same\\n        // message isn't enqueued twice.\\n        // This is needed here or we lose the ack state of our connections if we\\n        // send the same message to multiple connections.\\n        if(messageData.id === item.id) {\\n          return -1;\\n        }\\n\\n        // Finally if it isn't any of the basic messages check to see if the\\n        // message is a direct duplicate of an existing message.\\n        // match lists all the keys in message that don't have the same value in\\n        // item.message and all the keys in item.message that don't have the same\\n        // value in message.\\n        // If match has any elements in it than they are different messages.\\n        const match = Object.keys(messageData.message).filter(function(key) {\\n          return (messageData.message[key] !== item.message[key])\\n        }).concat(Object.keys(item.message).filter(function(key) {\\n          return (messageData.message[key] !== item.message[key])\\n        }));\\n        if(match.length === 0) {\\n          return index;\\n        }\\n        // If none of the above returned than there is no match.\\n        return -1;\\n      }).filter(function(item) {return item > -1;});\\n      // Remove the messages that are overruled by the new message.\\n      const outQueue = queue.filter(function(item, index) {\\n        return duplicateIndicies.indexOf(index) < 0;\\n      });\\n      // return the new queue\\n      return outQueue;\\n    }\\n\\n    /*\\n      This checks if a message is eligable to be sent and returns a boolean\\n      value true means the message should be sent or stored and false means it\\n      shouldn't.\\n\\n      This checks:\\n\\n      - if the message data and connectionIndex are defined\\n\\n      TODO figure out what else to put here\\n    */\\n    function messageIsEligible(messageData, queue) {\\n      if (!messageData || !queue) {\\n        return false;\\n      }\\n      // Make sure that the queue exists. This may be over paranoid\\n      queue = queue || [];\\n\\n      // Start out saying that a message shouldn't be sent\\n      let send = false;\\n      let ignore = false;\\n      // I am not sure what conditions we have where we should ignore a\\n      // messaege.\\n      // I think to start the only one is if the same message is already in\\n      // the queue.\\n      if(!ignore) {\\n        send = true;\\n      }\\n      return send;\\n    }\\n\\n    /*\\n      This sends the message described by messageData to the connection\\n      indicated by connectionIndex, if appropriate.\\n\\n      First the message is checked to make sure it is eligible to be send using\\n      messageIsEligible, if it isn't than nothing is sent but the messageQueue\\n      timer is still reset.\\n\\n      If the message is eligible to be sent than the message queue is checked\\n      any existing messages that the current message makes redundant are\\n      removed from the queue. Note that the same message (that is the direct\\n      duplicate with the same messageId) is not removed here, if it were than\\n      the same message being sent from the server to multiple browsers would\\n      overwrite the ack state of each browser as the message was sent to the\\n      next one.\\n\\n      Then the queue is checked to see if the same message is already enqueued,\\n      if so than only the ack state is updated so it is waiting for an ack from\\n      the current connectionIndex. If the message is not already enqueued than\\n      the ack state is updated in the messageData and it is added to the queue.\\n\\n      This modifies messageQueue as a side effect\\n    */\\n    function sendMessage(messageData) {\\n      if (!messageData) {\\n        return;\\n      }\\n      if (!messageData._target_info) {\\n        return;\\n      }\\n      if(messageIsEligible(messageData, messageQueue)) {\\n        $tw.Bob.Timers = $tw.Bob.Timers || {};\\n        // Remove any messages made redundant by this message\\n        messageQueue = removeRedundantMessages(messageData, messageQueue);\\n        // Check to see if the token has changed\\n        messageQueue = removeOldTokenMessages(messageQueue);\\n        const messageBuffer = Buffer.from(JSON.stringify(messageData.message));\\n        if(messageBuffer.length > 2000) {\\n          chunkMessage(messageData, messageBuffer);\\n          checkMessageQueue();\\n        } else {\\n          $tw.Bob.Federation.socket.send(messageBuffer, 0, messageBuffer.length, messageData._target_info.port, messageData._target_info.address, function(err) {\\n            if (err) {\\n              $tw.Bob.logger.error(err,{level: 3});\\n            } else {\\n              checkMessageQueue();\\n            }\\n          })\\n        }\\n      }\\n    }\\n\\n    function chunkMessage(messageData, messageBuffer) {\\n      $tw.Bob.Federation.chunkHistory = $tw.Bob.Federation.chunkHistory || {};\\n      $tw.Bob.Federation.chunkHistory[messageData.id] = $tw.Bob.Federation.chunkHistory[messageData.id] || {};\\n      $tw.Bob.Federation.chunkHistory[messageData.id].message = messageData.message;\\n      $tw.Bob.Federation.chunkHistory[messageData.id].serverInfo = messageData._target_info;\\n      $tw.Bob.Federation.chunkHistory[messageData.id].wiki = messageData.wiki;\\n      const totalChunks = Math.ceil(messageBuffer.length/500);\\n      let i = 0;\\n      while(i*500 < messageBuffer.length) {\\n        if(messageData.exclude.indexOf(i) === -1) {\\n          // Split message buffer into pieces and seand them individually\\n          const newMessage = {\\n            type: 'chunk',\\n            d: messageBuffer.subarray(i*500, (i+1)*500),\\n            c: messageData.id,\\n            i: i,\\n            tot: totalChunks\\n          }\\n          const newMessageData = createRemoteMessageData(newMessage, undefined, messageData._target_info, []);\\n          messageQueue.push(newMessageData);\\n        }\\n        i = i + 1;\\n      }\\n    }\\n\\n    /*\\n      If the token in the queued messages changes than remove messages that use\\n      the old token\\n    */\\n    function removeOldTokenMessages(messageQueue) {\\n      // TODO this!!\\n      return messageQueue\\n    }\\n\\n    /*\\n      This is the function for handling ack messages on both the server and\\n      browser. It is the same on both sides so it is here to prevent duplicate\\n      code.\\n\\n      It takes a messadeData object as input and checks it against the message\\n      queue. If the queue contains a message with the same id as node input\\n      messageData than the ack state for the connection the ack came from is set\\n      to true.\\n\\n      If all acks for the messageData in the queue are set to true than the ctime\\n      for that messageData is set to the current time so it can be properly\\n      removed later.\\n    */\\n    function handleAck(data) {\\n      if(data.id) {\\n        // a quick hack to make this work\\n        if($tw.browser) {\\n          data.source_connection = 0;\\n        }\\n        const index = messageQueue.findIndex(function(messageData) {\\n          return messageData.id === data.id;\\n        })\\n        if(messageQueue[index]) {\\n          // Set the message as acknowledged.\\n          messageQueue[index].ack[data.source_connection] = true;\\n          // Check if all the expected acks have been received\\n          const complete = Object.keys(messageQueue[index].ack).findIndex(function(value){\\n            return messageQueue[index].ack[value] === false;\\n          }) === -1;\\n          // If acks have been received from all connections than set the ctime.\\n          if(complete && !messageQueue[index].ctime) {\\n            messageQueue[index].ctime = Date.now();\\n          }\\n        }\\n      }\\n    }\\n\\n    function getAccessToken(connectionKey) {\\n      return false;\\n    }\\n\\n    /*\\n      This takes a messageQueue as input and returns a queue with old messages\\n      removed.\\n\\n      As part of the ack handling, once a message receives an ack from every\\n      connection it is sent to the ctime is set.\\n      This checks each message in the queue and if the ctime exists and is more\\n      than 10000ms old than it removes the message from the returned queue.\\n\\n      A message is kept past the final ack because some messages can be sent\\n      multiple times and things get stuck in an infinite loop if we don't detect\\n      that they are duplicates.\\n    */\\n    function pruneMessageQueue(inQueue) {\\n      inQueue = inQueue || [];\\n      // We can not remove messages immediately or else they won't be around to\\n      // prevent duplicates when the message from the file system monitor comes\\n      // in.\\n      // But we don't want a huge history of messages taking up all the ram, so\\n      // we set some long time to live on the message queue and remove any\\n      // messages older than this TTL when we receive a new ack.\\n      // remove the message with the id from the message queue\\n      // try removing messages that received an ack more than 10 seconds ago.\\n\\n      // messageData.ack.ctime is the time that a message received all the acks\\n      // it was waiting for. If it doesn't exist than it is still waiting.\\n      const outQueue = inQueue.filter(function(messageData) {\\n        const token = getAccessToken()\\n        if((token && messageData.message.token && messageData.message.token !== token) || (token && !messageData.message.token) ) {\\n          // If we have a token, the message has a token and they are not the\\n          // same than drop the message. (possible imposter)\\n          // If we have a token and the message doesn't have a token than drop it\\n          // (someone unathenticated trying to make changes)\\n          // If we don't have a token and the message does than what?\\n          return false\\n        } else if(messageData.ctime) {\\n          // if there is a ctime than check if it is more than 10000ms ago, if so\\n          // remove the message.\\n          if(Date.now() - messageData.ctime > 10000) {\\n            return false;\\n          } else {\\n            return true;\\n          }\\n        } else {\\n          return true;\\n        }\\n      })\\n      return outQueue;\\n    }\\n\\n    /*\\n      This acknowledges that a message has been received.\\n    */\\n    $tw.Bob.Federation.sendAck = function (data) {\\n      data = data || {};\\n      if($tw.browser) {\\n        const token = localStorage.getItem('ws-token')\\n        $tw.Bob.Federation.connections[0].socket.send(JSON.stringify({type: 'ack', id: data.id, token: token, wiki: $tw.wikiName}));\\n      } else {\\n        if(data.id) {\\n          if(data.source_connection !== undefined && data.source_connection !== -1) {\\n            $tw.Bob.Federation.connections[data.source_connection].socket.send(JSON.stringify({type: 'ack', id: data.id}));\\n          }\\n        }\\n      }\\n    }\\n\\n    /*\\n      This returns the server key used as the unique identifier for a server\\n    */\\n    function getServerKey(targetInfo) {\\n      return targetInfo.serverName || targetInfo.address + ':' + targetInfo.port;\\n    }\\n\\n    /*\\n      This creates the needed message data for remote servers\\n\\n      TODO get access token part\\n      TODO make the nonce not terrible\\n    */\\n    function createRemoteMessageData(message, wiki, targetInfo, exclude, oldId) {\\n      if(typeof message === 'string') {\\n        try{\\n          message = JSON.parse(message);\\n        } catch (e) {\\n          $tw.Bob.logger.error('err', e, {level: 3});\\n          return false;\\n        }\\n      }\\n      // The nonce is used for some privacy and to keep track of what wikis\\n      // messages are for. With the proper implementation it could also be used\\n      // for security, but the Math.random function isn't cryptographically\\n      // secure so this isn't the proper implementation.\\n      const nonce = Math.random()*99999999999999\\n      // The messages ids are shared with sending things to browsers, but this\\n      // has no effect on anything other than making the numbers increase a bit\\n      // faster.\\n      const id = oldId || makeId();\\n      const token = false;\\n      message.id = id;\\n      message.rnonce = nonce;\\n      message.serverName = $tw.settings.federation.serverName;\\n      let messageData = {\\n        message: message,\\n        id: id,\\n        time: Date.now(),\\n        type: message.type,\\n        ack: {},\\n        token: token,\\n        _target_info: targetInfo,\\n        serverName: $tw.settings.federation.serverName,\\n        exclude: exclude || [],\\n        wiki: wiki\\n      };\\n      const server = (typeof wiki === 'undefined')?true:false;\\n      $tw.Bob.Federation.nonce.push({nonce: nonce, wiki: wiki, server: server, type: message.type})\\n      return messageData;\\n    }\\n\\n    /*\\n      This sends a message to a remote server. This is used for syncing for now,\\n      in the future it may be used for other things.\\n    */\\n    $tw.Bob.Federation.sendToRemoteServer = function(message, serverInfo, wiki, exclude) {\\n      const messageData = createRemoteMessageData(message, wiki, serverInfo, exclude);\\n      if (messageData) {\\n        // This sends the message. The sendMessage function adds the message to\\n        // the queue if appropriate.\\n        messageQueue.push(messageData);\\n        checkMessageQueue();\\n      } else {\\n        $tw.Bob.logger.error('no message data?', {level: 3})\\n      }\\n    }\\n\\n    /*\\n      TODO figure out how to best specify which servers to send the message to\\n    */\\n    $tw.Bob.Federation.sendToRemoteServers = function(message) {\\n      // Don't send to the server that the message originated in!\\n      // but that shouldn't happen\\n      const targetList = getTargets(message);\\n      targetList.forEach(function(serverKey) {\\n        const target_info = {\\n          name: serverKey,\\n          port: $tw.Bob.Federation.connections[serverKey].port,\\n          address: $tw.Bob.Federation.connections[serverKey].address\\n        }\\n        $tw.Bob.Federation.sendToRemoteServer(message, target_info);\\n      })\\n    }\\n\\n    /*\\n      Determine which servers to send a message to\\n    */\\n    function getTargets(message) {\\n      const targetList = Array.isArray(message.targets) ? message.targets : Object.keys($tw.Bob.Federation.connections);\\n      return targetList;\\n    }\\n  }\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/FederationUDPSocketSetup.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/FederationUDPSocketSetup.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/Federation/FederationUDPSocketSetup.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nA module that adds the framework for inter-server communication\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"federation-websockets-setup\\\";\\nexports.platforms = [\\\"node\\\"];\\nexports.after = [\\\"websocket-server\\\"];\\nexports.synchronous = true;\\n\\nif(false && $tw.node && $tw.settings.enableFederation === 'yes') {\\n  const dgram = require('dgram');\\n  const setup = function () {\\n    $tw.Bob = $tw.Bob || {};\\n    $tw.settings.federation = $tw.settings.federation || {};\\n    $tw.Bob.Federation = $tw.Bob.Federation || {};\\n    $tw.Bob.Federation.connections = loadConnections();\\n    $tw.Bob.Federation.messageHandlers = $tw.Bob.Federation.messageHandlers || {};\\n\\n    /*\\n      Save the connections.json file in the settings folder\\n    */\\n    $tw.Bob.Federation.updateConnectionsInfo = function() {\\n      const fs = require('fs');\\n      const path = require('path');\\n      const connectionsFilePath = path.join($tw.boot.wikiPath, 'settings', 'connections.json');\\n      const userSettingsFolder = path.join($tw.boot.wikiPath, 'settings');\\n      if(!fs.existsSync(userSettingsFolder)) {\\n        // Create the settings folder\\n        fs.mkdirSync(userSettingsFolder);\\n      }\\n      const connections = JSON.stringify($tw.Bob.Federation.connections, \\\"\\\", 2);\\n      fs.writeFile(connectionsFilePath, connections, {encoding: \\\"utf8\\\"}, function (err) {\\n        if(err) {\\n          const message = {\\n            alert: 'Error saving connections:' + err,\\n            connections: [data.source_connection]\\n          };\\n          $tw.ServerSide.sendBrowserAlert(message);\\n          $tw.Bob.logger.error(err, {level:1});\\n        } else {\\n          $tw.Bob.logger.log('Updated connections file', {level:1})\\n          $tw.Bob.Federation.updateConnections()\\n        }\\n      });\\n    }\\n\\n    $tw.Bob.Federation.authenticateMessage = function (message) {\\n      return true;\\n    }\\n    /*\\n      Update the list of connections and send the updated list to the browsers\\n      TODO figure out what sort of limits we need to make on who can see what\\n      connections\\n      TODO figure out how we are going to put reasonable names on these things\\n      because this is designed to work when the ip or url of a connection\\n      changes\\n    */\\n    $tw.Bob.Federation.updateConnections = function () {\\n      $tw.Bob.logger.log('Update federated connections', {level:3});\\n      $tw.Bob.logger.log('Connections list:', Object.keys($tw.Bob.Federation.connections), {level:4});\\n      const message = {\\n        type: 'updateConnections',\\n        connections: $tw.Bob.Federation.connections\\n      };\\n      $tw.Bob.SendToBrowsers(message);\\n    }\\n\\n    // Create the UDP socket to use\\n    $tw.Bob.Federation.socket = dgram.createSocket({type:'udp4', reuseAddr: true});\\n    $tw.settings.federation.udpPort = $tw.settings.federation.udpPort || '3232';\\n    $tw.settings.federation.serverName = $tw.settings.federation.serverName || 'Server of Eternal Mystery';\\n    $tw.Bob.Federation.socket.bind($tw.settings.federation.udpPort)\\n    $tw.Bob.Federation.socket.on('listening', ()=>{\\n      $tw.Bob.Federation.updateConnections()\\n      $tw.Bob.logger.log('listening on udp port', $tw.settings.federation.udpPort, {level: 2})\\n      if ($tw.settings.federation.enableMulticast === 'yes') {\\n        $tw.settings.federation.multicastAddress = $tw.settings.federation.multicastAddress || '224.0.0.114';\\n        $tw.Bob.logger.log('using multicast address ', $tw.settings.federation.multicastAddress,{level: 2});\\n        $tw.Bob.Federation.socket.setTTL(128);\\n        $tw.Bob.Federation.socket.setBroadcast(true);\\n        $tw.Bob.Federation.socket.setMulticastLoopback(false);\\n        $tw.Bob.Federation.socket.setMulticastInterface('0.0.0.0');\\n        $tw.Bob.Federation.socket.addMembership($tw.settings.federation.multicastAddress, '0.0.0.0');\\n\\n        // Broadcast a message informing other nodes that this one is on the\\n        // local net pubKey and signed will be used later, the public key and a\\n        // signed token showing that the server has the private key\\n        $tw.Bob.Federation.multicastSearch = function() {\\n          const message = {\\n            type: 'multicastSearch',\\n            serverName: $tw.settings.federation.serverName,\\n            pubKey: '',\\n            signed: ''\\n          }\\n          const messageBuffer = Buffer.from(JSON.stringify(message))\\n          $tw.Bob.Federation.socket.send(messageBuffer, 0, messageBuffer.length, $tw.settings.federation.udpPort, $tw.settings.federation.multicastAddress, function(err) {\\n            if (err) {\\n              $tw.Bob.logger.error(err, {level: 3})\\n            }\\n          })\\n        }\\n      }\\n    })\\n    $tw.Bob.Federation.socket.on('message', (message, rinfo)=>{\\n      $tw.Bob.Federation.handleMessage(message, rinfo);\\n    });\\n    $tw.Bob.Federation.socket.on('error', (err) => {\\n      $tw.Bob.logger.error(err, {level: 3})\\n    });\\n\\n    const nonNonce = ['multicastSearch', 'requestServerInfo', 'requestHashes', 'requestTiddlers', 'requestRemoteSync', 'ping', 'chunk', 'chatMessage', 'chatHistory', 'requestResend'];\\n\\n    $tw.Bob.Federation.handleMessage = function (message, rinfo) {\\n      if (!rinfo || !message) {\\n        return;\\n      }\\n      $tw.Bob.logger.log('Received federated message ', message, {level:4});\\n      try {\\n        let messageData = JSON.parse(message);\\n        if (typeof messageData === 'string') {\\n          messageData = JSON.parse(messageData);\\n        }\\n        messageData._source_info = rinfo;\\n        messageData._source_info.serverKey = getServerKey(messageData);\\n        if (!messageData._source_info.serverKey) {\\n          return;\\n        }\\n        handleConnection(messageData);\\n        // Make sure we have a handler for the message type\\n        if(typeof $tw.Bob.Federation.messageHandlers[messageData.type] === 'function') {\\n          // Check authorisation\\n          const authorised = $tw.Bob.Federation.authenticateMessage(messageData);\\n          messageData.wiki = checkNonce(messageData);\\n          // TODO fix this dirty hack. We need a better way to list which\\n          // messages don't require a nonce.\\n          if(authorised && (messageData.wiki || nonNonce.indexOf(messageData.type) !== -1)) {\\n            messageData.decoded = authorised;\\n            $tw.Bob.Federation.messageHandlers[messageData.type](messageData);\\n          }\\n        } else {\\n          $tw.Bob.logger.error('No handler for federation message of type ', messageData.type, {level:3});\\n        }\\n      } catch (e) {\\n        $tw.Bob.logger.error(\\\"Error receiving udp message: \\\", e, {level:1});\\n      }\\n    }\\n\\n    function checkNonce(data) {\\n      if (!data.nonce) {\\n        return false;\\n      }\\n      let theWiki = undefined\\n      let server = undefined\\n      const match = $tw.Bob.Federation.nonce.filter(function(thisOne) {return thisOne.nonce === data.nonce})\\n      if (match.length > 0) {\\n        theWiki = (match[0].wiki)?match[0].wiki:undefined;\\n        server = match[0].server;\\n        $tw.Bob.Federation.nonce = $tw.Bob.Federation.nonce.filter(function(thisOne) {return thisOne.nonce !== data.nonce});\\n      }\\n      if (typeof theWiki === 'undefined' && typeof server === 'undefined') {\\n        return false;\\n      }\\n      return theWiki || server;\\n    }\\n\\n    /*\\n      Setup the websocket server if we aren't using an external one\\n    */\\n    function finishSetup () {\\n      $tw.settings.federation.rebroadcastInterval = $tw.settings.federation.rebroadcastInterval || 5000;\\n      setInterval(function() {\\n        if ($tw.settings.federation.broadcast === 'yes') {\\n          $tw.Bob.Federation.multicastSearch()\\n        }\\n        if($tw.settings.federation.checkConnections !== 'no') {\\n          pingConnections('all');\\n        }\\n      }, $tw.settings.federation.rebroadcastInterval);\\n    }\\n\\n    /*\\n      Try and send a ping to every listed connection.\\n      Optionally taking a type input to specify which connections to check\\n\\n      type can be:\\n      active - ping only connections marked as active\\n      inactive - ping only connections marked as inactive\\n      all - ping all listed connections\\n      [serverKey] - send a ping to each server listed in the array\\n    */\\n    function pingConnections(type='inactive') {\\n      const message = {type: 'ping'}\\n      if(Array.isArray(type)) {\\n        type.forEach(function(name) {\\n          if(!$tw.Bob.Federation.connections[name] || !$tw.Bob.Federation.connections[name].port || !$tw.Bob.Federation.connections[name].address) {\\n            return;\\n          }\\n          const serverInfo = {\\n            port: $tw.Bob.Federation.connections[name].port,\\n            address: $tw.Bob.Federation.connections[name].address\\n          }\\n          $tw.Bob.Federation.sendToRemoteServer(message, serverInfo);\\n        })\\n      } else if(type === 'all') {\\n        Object.keys($tw.Bob.Federation.connections).forEach(function(name) {\\n          if(!$tw.Bob.Federation.connections[name] || !$tw.Bob.Federation.connections[name].port || !$tw.Bob.Federation.connections[name].address) {\\n            return;\\n          }\\n          const serverInfo = {\\n            port: $tw.Bob.Federation.connections[name].port,\\n            address: $tw.Bob.Federation.connections[name].address\\n          }\\n          $tw.Bob.Federation.sendToRemoteServer(message, serverInfo);\\n        })\\n      } else if(type === 'active') {\\n        Object.keys($tw.Bob.Federation.connections).forEach(function(name) {\\n          if(!$tw.Bob.Federation.connections[name] || !$tw.Bob.Federation.connections[name].port || !$tw.Bob.Federation.connections[name].address) {\\n            return;\\n          }\\n          if($tw.Bob.Federation.connections[name].active === 'yes') {\\n            const serverInfo = {\\n              port: $tw.Bob.Federation.connections[name].port,\\n              address: $tw.Bob.Federation.connections[name].address\\n            }\\n            $tw.Bob.Federation.sendToRemoteServer(message, serverInfo);\\n          }\\n        })\\n      } else if(type === 'inactive') {\\n        Object.keys($tw.Bob.Federation.connections).forEach(function(name) {\\n          if(!$tw.Bob.Federation.connections[name] || !$tw.Bob.Federation.connections[name].port || !$tw.Bob.Federation.connections[name].address) {\\n            return;\\n          }\\n          if($tw.Bob.Federation.connections[name].active === 'no') {\\n            const serverInfo = {\\n              port: $tw.Bob.Federation.connections[name].port,\\n              address: $tw.Bob.Federation.connections[name].address\\n            }\\n            $tw.Bob.Federation.sendToRemoteServer(message, serverInfo);\\n          }\\n        })\\n      }\\n    }\\n\\n    /*\\n      This loads the informaiton we have about potential connections\\n    */\\n    function loadConnections() {\\n      const fs = require('fs');\\n      const path = require('path');\\n      const connectionsFilePath = path.join($tw.boot.wikiPath, 'settings', 'connections.json');\\n      const userSettingsFolder = path.join($tw.boot.wikiPath, 'settings');\\n      if(!fs.existsSync(userSettingsFolder)) {\\n        return {};\\n      }\\n      try {\\n        // We mark all connections as inactive when starting so the server\\n        // tries to establish connections with all of them.\\n        const connections = JSON.parse(fs.readFileSync(connectionsFilePath).toString('utf8'));\\n        Object.keys(connections).forEach(function(connectionName) {\\n          connections[connectionName].active = 'no';\\n        })\\n        return connections\\n      } catch (e) {\\n        $tw.Bob.logger.error('problem loading connections', e)\\n        return {};\\n      }\\n    }\\n\\n    /*\\n      This returns the server key used as the unique identifier for a server\\n    */\\n    function getServerKey(messageData) {\\n      return messageData.serverName\\n      /*\\n      if(messageData.serverName) {\\n        return messageData.serverName\\n      }\\n      if (messageData._source_info) {\\n        return messageData.serverName || messageData._source_info.address + ':' + messageData._source_info.port;\\n      } else if (messageData._target_info) {\\n        return messageData.serverName || messageData._target_info.address + ':' + messageData._source_info.port;\\n      } else {\\n        // This should never happen\\n        return false;\\n      }\\n      */\\n    }\\n\\n    /*\\n      This runs when there is a new connection and sets up the message handler\\n    */\\n    function handleConnection(messageData) {\\n      // If this is a new connection save it, otherwise just make sure that our\\n      // stored data is up to date.\\n      if (Object.keys($tw.Bob.Federation.connections).indexOf(messageData._source_info.serverKey) === -1) {\\n        $tw.Bob.logger.log(\\\"New Remote Connection\\\", messageData._source_info.serverKey, {level: 2});\\n        if (typeof $tw.Bob.Federation.connections[messageData._source_info.serverKey] === 'undefined' && messageData.type !== 'sendServerInfo') {\\n          // Add temp info\\n          $tw.Bob.Federation.connections[messageData._source_info.serverKey] = $tw.Bob.Federation.connections[messageData._source_info.serverKey] || {};\\n          $tw.Bob.Federation.connections[messageData._source_info.serverKey].address = messageData._source_info.address;\\n          $tw.Bob.Federation.connections[messageData._source_info.serverKey].port = messageData._source_info.port;\\n          // Request server info for the new one\\n          $tw.Bob.Federation.sendToRemoteServer({type:'requestServerInfo', port:$tw.settings.federation.udpPort}, messageData._source_info)\\n          $tw.Bob.Federation.updateConnectionsInfo();\\n        }\\n      } else {\\n        // Check to make sure we have the up-to-date address and port\\n        if ($tw.Bob.Federation.connections[messageData._source_info.serverKey].address !== messageData._source_info.address || $tw.Bob.Federation.connections[messageData._source_info.serverKey].port !== messageData._source_info.port) {\\n          $tw.Bob.Federation.connections[messageData._source_info.serverKey].address = messageData._source_info.address;\\n          $tw.Bob.Federation.connections[messageData._source_info.serverKey].port = messageData._source_info.port;\\n          $tw.Bob.Federation.updateConnectionsInfo();\\n        }\\n      }\\n    }\\n\\n    finishSetup();\\n  }\\n  // Only act if we are running on node. Otherwise WebSocketServer will be\\n  // undefined.\\n  // Also we don't do this if we have an external server running things\\n  // we have to use the command line arguments because the externalserver\\n  // command hasn't run yet so we can't check $tw.ExternalServer\\n  if($tw.boot.argv.indexOf('--externalserver') === -1) {\\n    setup();\\n  }\\n}\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/NodeFederationHandlers.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/NodeFederationHandlers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/Federation/NodeFederationHandlers.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThese are basic handlers for federation between different Bob servers.\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.platforms = [\\\"node\\\"];\\n\\nif(false && $tw.node && $tw.settings.enableFederation === 'yes') {\\n  $tw.settings.Federation = $tw.settings.Federation || {};\\n  $tw.Bob.Federation = $tw.Bob.Federation || {};\\n  $tw.Bob.Federation.messageHandlers = $tw.Bob.Federation.messageHandlers || {};\\n\\n  /*\\n    This is asking a remote server for an update about its current status\\n    including:\\n\\n    - Server name\\n    - Available wikis\\n    - Available chats\\n    - (TODO) its public key\\n      - For this one the requesting server would send a random number and the\\n        reply would be a signed token where the payload is the random number\\n        and the public key.\\n  */\\n  function getAvailableWikis(data) {\\n    data = data || {};\\n    function getList(obj, prefix) {\\n      let output = []\\n      Object.keys(obj).forEach(function(item) {\\n        if(typeof obj[item] === 'string') {\\n          if($tw.ServerSide.existsListed(prefix+item)) {\\n            if(item == '__path') {\\n              if(prefix.endsWith('/')) {\\n                output.push(prefix.slice(0,-1));\\n              } else {\\n                output.push(prefix);\\n              }\\n            } else {\\n              output.push(prefix+item);\\n            }\\n          }\\n        } else if(typeof obj[item] === 'object') {\\n          output = output.concat(getList(obj[item], prefix + item + '/'));\\n        }\\n      })\\n      return output;\\n    }\\n    // Get the wiki list of wiki names from the settings object\\n    const wikiList = getList($tw.settings.wikis, '')\\n    const viewableWikis = []\\n    wikiList.forEach(function(wikiName) {\\n      if($tw.Bob.AccessCheck(wikiName, {\\\"decoded\\\": data.decoded}, 'view')) {\\n        viewableWikis.push(wikiName);\\n      }\\n    })\\n    return wikiList || {};\\n  }\\n  function getAvailableChats() {\\n    return [];\\n  }\\n\\n  /*\\n    Save the connections.json file in the settings folder\\n  */\\n  function updateConnectionsInfo() {\\n    const fs = require('fs');\\n    const path = require('path');\\n    const connectionsFilePath = path.join($tw.boot.wikiPath, 'settings', 'connections.json');\\n    const userSettingsFolder = path.join($tw.boot.wikiPath, 'settings');\\n    if(!fs.existsSync(userSettingsFolder)) {\\n      // Create the settings folder\\n      fs.mkdirSync(userSettingsFolder);\\n    }\\n    const connections = JSON.stringify($tw.Bob.Federation.connections, \\\"\\\", 2);\\n    fs.writeFile(connectionsFilePath, connections, {encoding: \\\"utf8\\\"}, function (err) {\\n      if(err) {\\n        const message = {\\n          alert: 'Error saving connections:' + err,\\n          connections: [data.source_connection]\\n        };\\n        $tw.ServerSide.sendBrowserAlert(message);\\n        $tw.Bob.logger.error(err, {level:1});\\n      } else {\\n        $tw.Bob.logger.log('Updated connections file', {level:1})\\n        $tw.Bob.Federation.updateConnections()\\n      }\\n    });\\n  }\\n\\n  /*\\n    Respond when a multicast search message is received\\n  */\\n  $tw.Bob.Federation.messageHandlers.multicastSearch = function(data) {\\n    // This checks to see if we have the node the broadcast is from listed with\\n    // the same rinfo stuff as the broadcast, if so we can ignore it, if not\\n    // than we request info\\n    if (typeof $tw.Bob.Federation.connections[data._source_info.serverKey] === 'undefined' || $tw.Bob.Federation.connections[data._source_info.serverKey].active !== 'yes' || $tw.Bob.Federation.connections[data._source_info.serverKey].port !== data._source_info.port && $tw.Bob.Federation.connections[data._source_info.serverKey].address !== data._source_info.address) {\\n      $tw.Bob.Federation.connections[data._source_info.serverKey].active = 'yes';\\n      $tw.Bob.Federation.updateConnectionsInfo();\\n    }\\n  }\\n\\n  /*\\n    Pings are for checking to see if a server is still alive, and for\\n    connecting to known servers without broadcasting\\n  */\\n  $tw.Bob.Federation.messageHandlers.ping = function(data) {\\n    // respond with a pong\\n    const message = {type: 'pong', nonce: data.rnonce};\\n    $tw.Bob.Federation.sendToRemoteServer(message, data._source_info);\\n    // ask for updated info if it has been long enough, or they aren't iisted\\n  }\\n\\n  /*\\n    A pong is the response to a ping, it indicates that the other server is\\n    active.\\n  */\\n  $tw.Bob.Federation.messageHandlers.pong = function(data) {\\n    if($tw.Bob.Federation.connections[data._source_info.serverKey].active !== 'yes') {\\n      const message = {\\n        type:'requestServerInfo',\\n      };\\n      $tw.Bob.Federation.sendToRemoteServer(message, data._source_info);\\n      updateSyncing(data._source_info.serverKey);\\n    }\\n  }\\n\\n  /*\\n    Ask a remote server for updated information about the server.\\n  */\\n  $tw.Bob.Federation.messageHandlers.requestServerInfo = function(data) {\\n    // Reply with the server info listed above\\n    const reply = {\\n      type: 'sendServerInfo',\\n      serverName: $tw.settings.federation.serverName,\\n      info: {\\n        name: $tw.settings.federation.serverName || 'Sever Name',\\n        allows_login: $tw.settings.federation.allows_login || 'no',\\n        available_wikis: $tw.ServerSide.getViewableWikiList(data),\\n        available_chats: getAvailableChats(data),\\n        port: $tw.settings.federation.udpPort,\\n        publicKey: 'c minor',\\n        staticUrl: 'no'\\n      },\\n      nonce: data.rnonce\\n    };\\n    $tw.Bob.Federation.sendToRemoteServer(reply, data._source_info);\\n  }\\n\\n  function addServerInfo(data) {\\n    data = data || {};\\n    $tw.Bob.Federation.connections[data._source_info.serverKey] = $tw.Bob.Federation.connections[data._source_info.serverKey] || {};\\n    data.info = (data.message)?(data.message.info || data.info):data.info;\\n    if (data.info && data._source_info) {\\n      $tw.Bob.Federation.connections[data._source_info.serverKey].name = data.info.name;\\n      $tw.Bob.Federation.connections[data._source_info.serverKey].allows_login = data.info.allows_login || 'no';\\n      $tw.Bob.Federation.connections[data._source_info.serverKey].lastupdate = $tw.utils.stringifyDate(new Date());\\n      $tw.Bob.Federation.connections[data._source_info.serverKey].available_wikis = $tw.Bob.Federation.connections[data._source_info.serverKey].available_wikis || {};\\n      $tw.Bob.Federation.connections[data._source_info.serverKey].active = 'yes';\\n      data.info.available_wikis.forEach(function(wikiName) {\\n        if(Object.keys($tw.Bob.Federation.connections[data._source_info.serverKey].available_wikis).indexOf(wikiName) === -1) {\\n          $tw.Bob.Federation.connections[data._source_info.serverKey].available_wikis[wikiName] = {\\n            allows_login: 'no',\\n            auto_sync: 'no',\\n            conflict_type: 'manual',\\n            name: wikiName,\\n            public: 'yes',\\n            sync: 'no',\\n            sync_filter: '[is[system]!is[system]]',\\n            sync_type: '',\\n            previous_sync: 0\\n          };\\n        } else {\\n          $tw.Bob.Federation.connections[data._source_info.serverKey].available_wikis[wikiName].previous_sync = $tw.Bob.Federation.connections[data._source_info.serverKey].available_wikis[wikiName].previous_sync || 0;\\n        }\\n      });\\n      $tw.Bob.Federation.connections[data._source_info.serverKey].available_chats = data.info.available_chats || [];\\n      $tw.Bob.Federation.connections[data._source_info.serverKey].port = data.info.port;\\n      $tw.Bob.Federation.connections[data._source_info.serverKey].address = data._source_info.address;\\n      $tw.Bob.Federation.connections[data._source_info.serverKey].publicKey = data.info.publicKey;\\n      $tw.Bob.Federation.connections[data._source_info.serverKey].staticUrl = data.info.staticUrl || 'no';\\n    }\\n    $tw.Bob.Federation.updateConnectionsInfo();\\n    $tw.Bob.Federation.updateConnections();\\n  }\\n\\n  /*\\n    Add or update local information about a remote server when it is received\\n  */\\n  $tw.Bob.Federation.messageHandlers.sendServerInfo = function(data) {\\n    addServerInfo(data);\\n  }\\n\\n  /*\\n    This checks the status of automatically syncing wikis and asks to sync if\\n    appropriate.\\n  */\\n  function updateSyncing(serverName) {\\n    // if the server has any wikis synced from the sending server and it has\\n    // been long enough ask for it to sync.\\n\\n    // The time difference compares two tiddlywiki date fields, so the format\\n    // of the compared values is YYYYMMDDHHmmssmmm (4 digit year, 2 digit month, 2 digit day, 2 digit hour, 2 digit minute, 2 digit second, 3 digit millisecond)\\n    // so 10000 is 10 seconds, 1000000 is 10 minutes\\n    const syncWikis = Object.keys($tw.Bob.Federation.connections[serverName].available_wikis).filter(function(wikiName) {\\n      return $tw.Bob.Federation.connections[serverName].available_wikis[wikiName].auto_sync === 'yes' && $tw.Bob.Federation.connections[serverName].available_wikis[wikiName].sync_type !== 'push' && $tw.utils.stringifyDate(new Date()) - $tw.Bob.Federation.connections[serverName].available_wikis[wikiName].previous_sync > 1000000\\n    })\\n    // find any wikis that we want to autosync and that haven't been synced in long enough\\n    syncWikis.forEach(function(wikiName) {\\n      // request new things\\n      const message = {\\n        type: 'requestHashes',\\n        tid_param: $tw.Bob.Federation.connections[serverName].available_wikis[wikiName]\\n      }\\n      $tw.Bob.Federation.connections[serverName].available_wikis[wikiName].previous_sync = $tw.utils.stringifyDate(new Date());\\n      $tw.Bob.Federation.sendToRemoteServer(message, $tw.Bob.Federation.connections[serverName]);\\n    })\\n  }\\n\\n  /*\\n    This requests tiddler hashes from a server in preparation for syncing\\n\\n    data {\\n      filter: <some filter>,\\n      fromWiki: wiki name\\n    }\\n  */\\n  $tw.Bob.Federation.messageHandlers.requestHashes = function(data) {\\n    $tw.Bob.logger.log('receive requestHashes', {level: 4})\\n    if(data.tid_param) {\\n      setTimeout(function() {\\n        $tw.Bob.logger.log(\\\"update syncing\\\", {level: 2})\\n        updateSyncing(data._source_info.serverKey);\\n      }, 10000);\\n      // Ask for hashes for the wikis\\n      // Request the hashes\\n      const test = $tw.ServerSide.loadWiki(data.tid_param.name);\\n      if(!test) {\\n        $tw.Bob.logger.log('no wiki?', data, {level: 3});\\n        return;\\n      }\\n      // get list of tiddlers\\n      const titleList = $tw.Bob.Wikis[data.tid_param.name].wiki.filterTiddlers(data.tid_param.sync_filter);\\n      // get tiddler hashes\\n      const outputHashes = {};\\n      titleList.forEach(function(thisTitle) {\\n        outputHashes[encodeURIComponent(thisTitle)] = $tw.Bob.Shared.getTiddlerHash($tw.Bob.Wikis[data.tid_param.name].wiki.getTiddler(thisTitle));\\n      })\\n      // send them back\\n      const message = {\\n        type: 'sendHashes',\\n        hashes: outputHashes,\\n        nonce: data.rnonce,\\n        fromWiki: data.tid_param.name\\n      }\\n      $tw.Bob.logger.log('sending send hashes', {level: 4})\\n      $tw.Bob.Federation.sendToRemoteServer(message, data._source_info);\\n    }\\n  }\\n\\n  /*\\n    This takes hashes of tiddlers from the remote wiki and compares them to the\\n    local wiki and requests any that are missing.\\n  */\\n  $tw.Bob.Federation.messageHandlers.sendHashes = function(data) {\\n    $tw.Bob.logger.log('receive sendHashes', data.hashes, {level: 4})\\n    if (data.hashes && data.fromWiki) {\\n      const tiddlersToRequest = [];\\n      const localName = $tw.Bob.Federation.connections[data.serverName].available_wikis[data.fromWiki].local_name || data.fromWiki;\\n      const test = $tw.ServerSide.loadWiki(localName);\\n      if(!test) {\\n        const wikiData = {\\n          wikiName: localName\\n        }\\n        $tw.nodeMessageHandlers.createNewWiki(wikiData, nextBit);\\n      } else {\\n        nextBit();\\n      }\\n      function nextBit() {\\n        const test = $tw.ServerSide.loadWiki(localName);\\n        Object.keys(data.hashes).forEach(function(rawTitle) {\\n          const tidTitle = decodeURIComponent(rawTitle);\\n          if(typeof tidTitle !== 'string') {\\n            return;\\n          }\\n          if(tidTitle.indexOf(\\\"]]\\\") !== -1) {\\n            return;\\n          }\\n          // check if the tiddler exists locally\\n          const thisTid = $tw.Bob.Wikis[localName].wiki.getTiddler(tidTitle);\\n          if (thisTid) {\\n            // If the tiddler exists than check if the hashes match\\n            if (data.hashes[rawTitle] !== $tw.Bob.Shared.getTiddlerHash(thisTid)) {\\n              // If the hashes don't match add it to the list\\n              tiddlersToRequest.push(tidTitle);\\n            }\\n          } else {\\n            // If the tiddler doesn't exist than add it to the list\\n            tiddlersToRequest.push(tidTitle);\\n          }\\n        })\\n        $tw.Bob.logger.log('requesting ', tiddlersToRequest.length, ' tiddlers', {level: 4})\\n        tiddlersToRequest.forEach(function(tidTitle) {\\n          const message = {\\n            type: 'requestTiddlers',\\n            filter: '[[' + tidTitle + ']]',\\n            wikiName: data.fromWiki\\n          }\\n          $tw.Bob.Federation.sendToRemoteServer(message, data._source_info);\\n        })\\n      }\\n    }\\n  }\\n\\n  /*\\n    This message is used to send the actual tiddler payload between servers.\\n\\n    TODO figure out the best way to set this up so that tiddlers can be saved\\n    without the browser being open.\\n\\n    data {\\n      tiddlers: {\\n        title1: tidObject 1,\\n        title2: tidObject 2,\\n        ...\\n      }\\n    }\\n  */\\n  $tw.Bob.Federation.messageHandlers.sendTiddlers = function(data) {\\n    $tw.Bob.logger.log('receive sendTiddlers', {level: 4})\\n    if (typeof data.tiddlers === 'object') {\\n      const localName = $tw.Bob.Federation.connections[data.serverName].available_wikis[data.wikiName].local_name || data.wikiName;\\n      $tw.ServerSide.loadWiki(localName, function() {\\n        Object.values(data.tiddlers).forEach(function(tidFields) {\\n          if(!tidFields) {\\n            return;\\n          }\\n          // Save the tiddlers using the rules set for the wiki\\n          federationConflictSave(tidFields, data);\\n        })\\n      })\\n    }\\n  }\\n\\n  /*\\n    This function checks the way conflicts are setup to be handled and saves\\n    the input tiddler accordingly, or discards it is appropriate.\\n  */\\n  function federationConflictSave(tidFields, data) {\\n    const localName = $tw.Bob.Federation.connections[data.serverName].available_wikis[data.wikiName].local_name || data.wikiName;\\n    const resolution = $tw.Bob.Federation.connections[data.serverName].available_wikis[data.wikiName].conflict_type;\\n    // Check if the tiddler exists\\n    const exists = $tw.Bob.Wikis[localName].wiki.getTiddler(tidFields.title);\\n    if(exists) {\\n      // We assume the tiddler is different, otherwise it wouldn't have been\\n      // requested.\\n      // Check the conflict resolution type and act accordingly\\n      if(resolution === 'localWins') {\\n        // If local wins we ignore remote changes\\n        return;\\n      } else if(resolution === 'remoteWins') {\\n        // If remote wins always use remote changes\\n        $tw.syncadaptor.saveTiddler({fields: tidFields}, localName);\\n      } else if(resolution === 'manual') {\\n        if(tidFields.title.startsWith('$:/SyncingConflict/')) {\\n          // If the tiddler is already a sync conflict tiddler from the other\\n          // wiki, ignore it.\\n          return;\\n        }\\n        // Save a conflict version and let the person decide\\n        tidFields.title = '$:/SyncingConflict/' + tidFields.title;\\n        $tw.syncadaptor.saveTiddler({fields: tidFields}, localName);\\n      }\\n    } else if(resolution === 'newestWins') {\\n      // Save the one with the newest modified field, if no modified field keep\\n      // the local one.\\n      // If only one has a modified field, keep that one.\\n      if(tidFields.modified && exists.fields.modified) {\\n        if(tidFields.modified > exists.fields.modified) {\\n          $tw.syncadaptor.saveTiddler({fields: tidFields}, localName);\\n        }\\n        // otherwise don't do anything\\n      } else if(tidFields.modified) {\\n        $tw.syncadaptor.saveTiddler({fields: tidFields}, localName);\\n      } else {\\n        // Either neither have a modified field or only the local one does,\\n        // either way just keep the local one.\\n        return;\\n      }\\n    } else if(resolution === 'oldestWins') {\\n      // Save the one with the oldest modified field, if no modified field keep\\n      // the local one.\\n      // If only one has a modified field keep the other one.\\n      if(tidFields.modified && exists.fields.modified) {\\n        if(tidFields.modified < exists.fields.modified) {\\n          $tw.syncadaptor.saveTiddler({fields: tidFields}, localName);\\n        }\\n        // otherwise don't do anything\\n      } else if(exists.fields.modified) {\\n        $tw.syncadaptor.saveTiddler({fields: tidFields}, localName);\\n      } else {\\n        // Either neither have a modified field or only the remote one does,\\n        // either way just keep the local one.\\n        return;\\n      }\\n    } else {\\n      // If the tiddler doesn't exist locally just add it.\\n      $tw.syncadaptor.saveTiddler({fields: tidFields}, localName);\\n    }\\n  }\\n\\n  /*\\n    This requets specific tiddlers from a remote wiki using a filter.\\n\\n    TODO figure out if the response to this should be split up into one message\\n    per tiddler instead of all of the tiddlers in one message.\\n\\n    data:\\n    {\\n      wikiName: the name of the wiki to pull from,\\n      filter: requestFilter\\n    }\\n  */\\n  $tw.Bob.Federation.messageHandlers.requestTiddlers = function(data) {\\n    $tw.Bob.logger.log('receive requestTiddlers', {level: 4})\\n    data.wikiName = data.wikiName || 'RootWiki';\\n    data.filter = data.filter || '[!is[system]is[system]]';\\n\\n    $tw.Bob.Federation.connections[data._source_info.url] = $tw.Bob.Federation.connections[data._source_info.url] || {};\\n\\n    $tw.Bob.Federation.connections[data._source_info.url].socket = $tw.Bob.Federation.connections[data._source_info.url].socket || {};\\n\\n    if(data._source_info && data.rnonce) {\\n      // Get the tiddlers\\n      const tiddlerTitles = $tw.Bob.Wikis[data.wikiName].wiki.filterTiddlers(data.filter);\\n      tiddlerTitles.forEach(function(tidTitle) {\\n        const tempTid = $tw.Bob.Wikis[data.wikiName].wiki.getTiddler(tidTitle);\\n        const tidObj = {};\\n        tidObj[encodeURIComponent(tidTitle)] = $tw.Bob.Shared.normalizeTiddler(tempTid).fields;//tempTid.fields;\\n        const message = {\\n          type: 'sendTiddlers',\\n          tiddlers: tidObj,\\n          nonce: data.rnonce,\\n          wikiName: data.wikiName\\n        }\\n        $tw.Bob.Federation.sendToRemoteServer(message, data._source_info);\\n      })\\n    }\\n  }\\n\\n  /*\\n    This message asks a remote server to sync with the local server\\n\\n    data {\\n      wikis: {\\n        wikiName1: filter1,\\n        wikiName2: filter2\\n      }\\n    }\\n\\n    When receiving this message the receiving server will, if the\\n    authentication and everything is correct, request tiddlers from the sending\\n    server using the provided wikis and filters.\\n  */\\n  $tw.Bob.Federation.messageHandlers.requestRemoteSync = function(data) {\\n    // By this point the authentication has been done, so check to make sure\\n    // that the wikis are listed for syncing.\\n    Object.keys(data.wikis).forEach(function(wikiName) {\\n      const serverName = $tw.Bob.Federation.connections[data._source_info.url].name;\\n      // Get the tiddler name that has the information for the wiki\\n      const wikiInfoTid = $tw.Bob.Wikis[wikiName].wiki.getTiddler('$:/Bob/KnownServers/' + serverName + '/wikis/' + wikiName);\\n      if (wikiInfoTid) {\\n        // make sure that the wiki is set up to be synced\\n        if (['pull','bidirectional'].indexOf(wikiInfoTid.fields.sync_type)) {\\n          // Make the request for the tiddlers\\n          const message = {\\n            type: 'requestTiddlers',\\n            wikiName: wikiName,\\n            filter: data.wikis.wikiName\\n          }\\n          $tw.Bob.Federation.sendToRemoteServer(message, data._source_info);\\n        }\\n      }\\n    })\\n  }\\n\\n  $tw.Bob.Federation.messageHandlers.chunk = function(data) {\\n    $tw.Bob.Federation.messageChunks = $tw.Bob.Federation.messageChunks || {};\\n    $tw.Bob.Federation.messageChunks[data.c] = $tw.Bob.Federation.messageChunks[data.c] || {};\\n    $tw.Bob.Federation.messageChunks[data.c][data.i] = Buffer.from(data.d);\\n    clearTimeout($tw.Bob.Federation.messageChunks[data.c].timer);\\n    if(Object.keys($tw.Bob.Federation.messageChunks[data.c]).length % 100 === 0) {\\n      $tw.Bob.logger.log('Receiving message chunks:', Object.keys($tw.Bob.Federation.messageChunks[data.c]).length + '/' + data.tot, {level: 3});\\n    }\\n    if(Object.keys($tw.Bob.Federation.messageChunks[data.c]).length === data.tot + 1) {\\n      clearTimeout($tw.Bob.Federation.messageChunks[data.c].timer);\\n      const outArray = Array(data.tot);\\n      for (let i = 0; i <= data.tot; i++) {\\n        outArray[i] = $tw.Bob.Federation.messageChunks[data.c][i];\\n      }\\n      const rebuilt = Buffer.concat(outArray.filter((x) => typeof x !== 'undefined'));\\n      $tw.Bob.Federation.handleMessage(rebuilt, data._source_info);\\n    } else {\\n      $tw.Bob.Federation.messageChunks[data.c].timer = setTimeout(requestResend, 500, data);\\n    }\\n  }\\n\\n  function requestResend(data) {\\n    $tw.Bob.logger.log('request resend', {level: 4})\\n    const receivedArray = Object.keys($tw.Bob.Federation.messageChunks[data.c]);\\n    const message = {\\n      type: 'requestResend',\\n      received: receivedArray,\\n      mid: data.c\\n    };\\n    // Send the message\\n    $tw.Bob.Federation.sendToRemoteServer(message, data._source_info)\\n  }\\n\\n  $tw.Bob.Federation.messageHandlers.requestResend = function(data) {\\n    $tw.Bob.logger.log('resend request received', {level: 4})\\n    // Make sure we have it saved\\n    $tw.Bob.Federation.chunkHistory = $tw.Bob.Federation.chunkHistory || {};\\n    if($tw.Bob.Federation.chunkHistory[data.mid]) {\\n      $tw.Bob.Federation.sendToRemoteServer(\\n        $tw.Bob.Federation.chunkHistory[data.mid].message,\\n        $tw.Bob.Federation.chunkHistory[data.mid].serverInfo,\\n        $tw.Bob.Federation.chunkHistory[data.mid].wiki,\\n        data.received);\\n    }\\n  }\\n\\n  /*\\n    Sync servers takes a filter and syncs all of the tiddlers returned by the\\n    filter with a remote server.\\n    It should use the same process as the syncChanges message, possibly they\\n    should be combined.\\n\\n    The data object has:\\n    {\\n      type: 'syncServer',\\n      wiki: wikiName,\\n      token: token,\\n      id: messageID,\\n      source_connection: connectionIndex,\\n      remoteUrl: remoteUrl,\\n      remoteWikis: [remoteWikiNames],\\n      sync_filter: sync_filter,\\n      sync_type: sync_type,\\n      conflict_type: conflict_type,\\n      remoteToken: remoteToken\\n    }\\n\\n    this takes the tiddlers returned by the sync_filter in the wiki named in\\n    wikiName and syncs them with the server at remoteUrl using sync_type, any\\n    conflicts are handled using conflict_type. If the remote server requires an\\n    access token it has to be suppiled in remoteToken. If the remote wiki\\n    doesn't have the same name as the local wiki than it needs to be given as\\n    remoteWiki.\\n\\n    remoteWikis is a list of wikki names to sync.\\n\\n    sync_type can be:\\n      - pushOnly: local tiddlers are pushed to the remote server but no changes\\n      are pulled from the remote server.\\n      - pullOnly: changes on the remote server are fetched but no local\\n      tiddlers are sent.\\n      - bidirectional: local changes are sent and remote changes are pulled\\n\\n    conflict_type can be:\\n      - localWins: if there are conflicts the local tiddlers are kept even if\\n      remote tiddlers have been changed, tiddlers that didn't exist previously\\n      are synced.\\n      - remoteWins: in the case of conflicts, remote tiddlers overwrite local\\n      tiddlers, only tiddlers that don't exist on the remote server are sent,\\n      if applicable.\\n      - (LATER) manual: every conflict is listed on the server that started the\\n      sync and a human has to manually resolve it. This reqires a message and\\n      interface for resolving conflicts.\\n      - (LATER) newestWins: in case of conflicts, the tiddlers with the most\\n      recent\\n      changes are kept regardless of which server it is from.\\n      - (LATER) oldestWins: least recently modified tiddlers are kept in case of\\n      conflicts.\\n  */\\n  $tw.Bob.Federation.messageHandlers.syncServer = function(data) {\\n    // We need at least the remote url or we can't act.\\n    if(data.remoteUrl) {\\n      // Try to connect to the remote server\\n      $tw.Bob.Federation.connections[data.remoteUrl] = $tw.Bob.Federation.connections[data.remoteUrl] || {}\\n\\n      data.sync_filter = data.sync_filter || '[!is[system]]'\\n      data.sync_type = data.sync_type || 'bidirectional'\\n      data.conflict_type = data.conflict_type || 'newestWins'\\n      // Default to only syncing the current wiki\\n      data.remoteWikis = data.remoteWikis || data.wiki || 'RootWiki'\\n\\n      $tw.Bob.Federation.connections[data.remoteUrl].socket = $tw.Bob.Federation.connections[data.remoteUrl].socket || {}\\n      $tw.Bob.Federation.connections[data.remoteUrl].pendingAction = 'sync'\\n      $tw.Bob.Federation.connections[data.remoteUrl].sync_filter = data.sync_filter\\n      $tw.Bob.Federation.connections[data.remoteUrl].sync_type = data.sync_type\\n      $tw.Bob.Federation.connections[data.remoteUrl].conflict_type = data.conflict_type\\n      $tw.Bob.Federation.connections[data.remoteUrl].remoteWikis = data.remoteWikis\\n\\n      if($tw.Bob.Federation.connections[data.remoteUrl].socket.readyState !== 1) {\\n        // Get the url for the remote websocket\\n        const URL = require('url');\\n        const remoteUrl = new URL(data.remoteUrl);\\n        const WebSocket = require('$:/plugins/OokTech/Bob/External/WS/ws.js');\\n        const websocketProtocol = (remoteUrl.protocol.startsWith('https'))?'wss://':'ws://';\\n        // connect web socket\\n        const socket = new WebSocket(websocketProtocol + remoteUrl.host + remoteUrl.pathname);\\n        // Save the socket for future use\\n        $tw.Bob.Federation.connections[data.remoteUrl].socket = socket;\\n        socket.on('open', function() {\\n          startRemoteSync($tw.Bob.Federation.connections[data.remoteUrl]);\\n        })\\n        $tw.Bob.Federation.connections[data.remoteUrl].socket.on('message', function (message) {\\n          const messageData = JSON.parse(message);\\n          handleRemoteReply($tw.Bob.Federation.connections[data.remoteUrl], messageData);\\n        })\\n      } else {\\n        startRemoteSync($tw.Bob.Federation.connections[data.remoteUrl], data)\\n      }\\n    }\\n  }\\n  function startRemoteSync(remoteServerObject, data) {\\n    // Get a list of tiddlers from the local wiki that should be synced if\\n    // sync_type is bidirectional or pushOnly\\n    let pushList = []\\n    if(['bidirectional','pushOnly'].indexOf(data.sync_type) !== -1) {\\n      pushList = $tw.Bob.Wikis[data.wiki].filterTiddlers(data.sync_filter)\\n    }\\n    let tiddlerHashes = {}\\n    pushList.forEach(function(tidName) {\\n      tiddlerHashes[tidName] = $tw.Bob.Shared.getTiddlerHash(tidName)\\n    })\\n    // send a sync message with the filter and accompanying tiddler hashes.\\n    let message = {\\n      type: 'syncRequest',\\n      sync_type: data.sync_type,\\n      sync_filter: data.sync_filter,\\n      conflict_type: data.conflict_type\\n    }\\n    remoteServerObject.send(JSON.stringify(message))\\n  }\\n  function handleRemoteReply(remoteServerObject, data) {\\n    if($tw.Bob.Federation.connections[data.remoteUrl].pendingAction == 'none') {\\n      return\\n    }\\n    // This receives the tiddlers that the remote server has and teh local\\n    // server doesn't\\n    // So save the received tiddlers\\n    remoteServerObject.remoteWikis.forEach(function(wikiName) {\\n      if(data[wikiName]) {\\n        Object.keys(data[wikiName]).forEach(function(tidName) {\\n          $tw.Bob.Wikis[wikiName].wiki.addTiddler(data[wikiName][tidName])\\n        })\\n      }\\n    })\\n  }\\n  function syncRequest(remoteServerObject, data) {\\n    let reply = {\\n      type:'remoteReply'\\n    }\\n    // The local server has already sent a list of hashes for local\\n    // tiddlers that match the sync filter. The remote replies with:\\n    //   A list of any tiddlers that the remote server is missing\\n    //   Any tiddlers that aren't listed in the sent hashes, because the\\n    //    local server doesn't have them.\\n    //   A list of remote tiddlers with conflicts If the sync is bi-directional\\n    //    or pullOnly\\n    if(data.missing) {\\n      // data.missing is in the form {wikiName: [tiddlerNames]}\\n      // These are the tiddlers that the remote server is missing\\n      // Gathere these tiddlers and send them back to the remote server\\n      // Make a list of all wikis the local server wants to sync, the remote\\n      // server could send much more than the local one wants and we want to\\n      // prevent malicious behaviour.\\n      remoteServerObject.remoteWikis.forEach(function(wikiName) {\\n        if(data.missing[wikiName]) {\\n          reply[wikiName] = {}\\n          // If the remote is missing tiddlers from a wiki retreive them and put them into an object.\\n          data.missing[wikiName].forEach(function(tidName) {\\n            // TODO Add some check to make sure that the remote is allowed to\\n            // get this tiddler.\\n            reply[wikiName][tidName] = $tw.Bob.Wikis[wikiName].wiki.getTiddler(tidName)\\n          })\\n        }\\n      })\\n    }\\n    if(data.tiddlers) {\\n      // data.tiddlers is in the form {wikiName1:[tiddlers],wikiName2:[tiddlers]}\\n      // These are tiddlers the local server is missing, add them to the local\\n      // wiki.\\n      remoteServerObject.remoteWikis.forEach(function(wikiName) {\\n        if(data.tiddlers[wikiName]) {\\n          data.tiddlers[wikiName].forEach(function(tidName) {\\n            // TODO add some check to make sure that we can have some way to\\n            // filter which tiddlers are actually saved.\\n            $tw.Bob.Wikis[wikiName].wiki.addTiddler(data.tiddlers[wikiName][tidName])\\n          })\\n        }\\n      })\\n      // Send reply\\n      // TODO figure this out\\n    }\\n    // Bi-directional sync with oldest or newest wins is gonig to require more\\n    // work\\n    if(data.conflicts) {\\n      // data.conflicts is in the form {wikiName1:[tiddlers],wikiName2:[tiddlers]}\\n      // These are tiddlers that have been changed on both servers\\n      // This may mean that it has to have a persistent record of changes.\\n\\n      // TODO this bit\\n    }\\n  }\\n\\n}\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/BrowserWSAdaptor.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/BrowserWSAdaptor.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/BrowserWSAdaptor.js\\ntype: application/javascript\\nmodule-type: syncadaptor\\n\\nA sync adaptor for syncing changes using websockets with Bob\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst delayRecord = {};\\n\\nconst sendToServer = function (message, callback) {\\n  const connectionIndex = 0;\\n  // If the connection is open, send the message\\n  if($tw.connections[connectionIndex].socket.readyState === 1) {\\n    // We need to add back in some of our old queue logic here to make sure we aren't spamming save tiddler messages on every keystroke.\\n    // We have the callback passed in so that we can add a delay here before sending save messages so we don't send them too quickly, it is the same as the typing delay for the draft refresh stuff in the core.\\n    //if(false && message.type === 'saveTiddler') {\\n    if(message.type === 'saveTiddler') {\\n      delayRecord[message.tiddler.fields.title] = delayRecord[message.tiddler.fields.title] || {};\\n      if(typeof delayRecord[message.tiddler.fields.title].cb === 'function') {\\n        // Clear the callback so we don't mess up the dirty status.\\n        delayRecord[message.tiddler.fields.title].cb(null, null);\\n      }\\n      clearTimeout(delayRecord[message.tiddler.fields.title].timeout);\\n      delayRecord[message.tiddler.fields.title].cb = callback\\n      delayRecord[message.tiddler.fields.title].message = message\\n      delayRecord[message.tiddler.fields.title].timeout = setTimeout( function() {\\n        try {\\n          $tw.Bob.Shared.sendMessage(delayRecord[message.tiddler.fields.title].message, 0);\\n          delayRecord[message.tiddler.fields.title].cb(null, null);\\n          delayRecord[message.tiddler.fields.title] = undefined;\\n        } catch (e) {\\n          // nothing here\\n        }\\n\\n      }, 150);\\n      return false;\\n    } else {\\n      const messageData = $tw.Bob.Shared.sendMessage(message, 0);\\n      return messageData.id;\\n    }\\n  } else {\\n    // If the connection is not open than store the message in the queue\\n    const tiddler = $tw.wiki.getTiddler('$:/plugins/OokTech/Bob/Unsent');\\n    let queue = [];\\n    let start = Date.now();\\n    if(tiddler) {\\n      if(typeof tiddler.fields.text === 'string') {\\n        queue = JSON.parse(tiddler.fields.text);\\n      }\\n      if(tiddler.fields.start) {\\n        start = tiddler.fields.start;\\n      }\\n    }\\n    // Check to make sure that the current message is eligible to be saved\\n    const messageData = $tw.Bob.Shared.createMessageData(message)\\n    if($tw.Bob.Shared.messageIsEligible(messageData, 0, queue)) {\\n      // Prune the queue and check if the current message makes any enqueued\\n      // messages redundant or overrides old messages\\n      queue = $tw.Bob.Shared.removeRedundantMessages(messageData, queue);\\n      // Don't save any messages that are about the unsent list or you get\\n      // infinite loops of badness.\\n      if(messageData.title !== '$:/plugins/OokTech/Bob/Unsent') {\\n        queue.push(messageData);\\n      }\\n      const tiddler2 = {\\n        title: '$:/plugins/OokTech/Bob/Unsent',\\n        text: JSON.stringify(queue, '', 2),\\n        type: 'application/json',\\n        start: start\\n      };\\n      $tw.wiki.addTiddler(new $tw.Tiddler(tiddler2));\\n    }\\n  }\\n}\\n\\nfunction BrowserWSAdaptor(options) {\\n  this.wiki = options.wiki;\\n  this.idList = [];\\n\\n  $tw.browserMessageHandlers = $tw.browserMessageHandlers || {};\\n  // Ensure that the needed objects exist\\n  $tw.Bob = $tw.Bob || {};\\n  // Import shared commands\\n  $tw.Bob.Shared = require('$:/plugins/OokTech/Bob/SharedFunctions.js');\\n  $tw.Bob.ExcludeFilter = $tw.wiki.getTiddlerText('$:/plugins/OokTech/Bob/ExcludeSync');\\n  // In the browser there is only one connection, so set the connection index\\n  const connectionIndex = 0;\\n\\n  // Do all actions on startup.\\n  $tw.Bob.setup = function(reconnect) {\\n    $tw.setcookie = function(cookieName, cookieValue) {\\n      if (cookieName && cookieValue) {\\n        document.cookie = cookieName + \\\"=\\\" + cookieValue;\\n      } else if (cookieName) {\\n        // Clear the cookie if no value given.\\n        document.cookie = cookieName + \\\"= ; expires = Thu, 01 Jan 1970 00:00:00 GMT\\\";\\n      }\\n    }\\n    // Add a message that the wiki isn't connected yet\\n    const text = \\\"<div style='position:fixed;bottom:0px;width:100%;background-color:red;height:1.5em;max-height:100px;text-align:center;vertical-align:center;color:white;'>''WARNING: The connection to server hasn't been established yet.''</div>\\\";\\n    const warningTiddler = {\\n      title: '$:/plugins/OokTech/Bob/Server Warning',\\n      text: text,\\n      tags: '$:/tags/PageTemplate'\\n    };\\n    $tw.wiki.addTiddler(new $tw.Tiddler(warningTiddler));\\n    if(reconnect) {\\n      $tw.connections = null;\\n    }\\n    // Get the name for this wiki for websocket messages\\n    const tiddler = $tw.wiki.getTiddler(\\\"$:/WikiName\\\");\\n    if(tiddler) {\\n      $tw.wikiName = tiddler.fields.text;\\n    } else {\\n      $tw.wikiName = '';\\n    }\\n\\n    const IPAddress = window.location.hostname;\\n    const WSSPort = window.location.port;\\n    const WSScheme = window.location.protocol==\\\"https:\\\"?\\\"wss://\\\":\\\"ws://\\\";\\n\\n    $tw.connections = $tw.connections || [];\\n    $tw.connections[connectionIndex] = $tw.connections[connectionIndex] || {};\\n    $tw.connections[connectionIndex].index = connectionIndex;\\n    try{\\n      const r = new RegExp(\\\"\\\\\\\\/\\\"+ $tw.wikiName + \\\"\\\\\\\\/?$\\\");\\n      $tw.connections[connectionIndex].socket = new WebSocket(WSScheme + IPAddress +\\\":\\\" + WSSPort + window.location.pathname.replace(r,'') );\\n    } catch (e) {\\n      console.log(e)\\n      $tw.connections[connectionIndex].socket = {};\\n    }\\n    $tw.connections[connectionIndex].socket.onopen = openSocket;\\n    $tw.connections[connectionIndex].socket.onmessage = parseMessage;\\n    $tw.connections[connectionIndex].socket.binaryType = \\\"arraybuffer\\\";\\n\\n    if(!reconnect) {\\n      addHooks();\\n    }\\n  }\\n  /*\\n    When the socket is opened the heartbeat process starts. This lets us know\\n    if the connection to the server gets interrupted.\\n  */\\n  const openSocket = function() {\\n    console.log('Opened socket');\\n    const token = localStorage.getItem('ws-token');\\n    // Login with whatever credentials you have\\n    const data = {\\n      type: 'setLoggedIn',\\n      wiki: $tw.wikiName,\\n      heartbeat: true,\\n      token: token\\n    };\\n    $tw.Bob.Shared.sendMessage(data, 0);\\n\\n    // For some reason the settings tiddlers are not always created in some\\n    // wikis, so this tries every second until it succeds at creating them.\\n    function tryAgain() {\\n      setTimeout(function() {\\n        const tid = $tw.wiki.getTiddler(\\\"$:/WikiSettings/split\\\")\\n        if (!tid) {\\n          const data = {\\n            type: 'setLoggedIn',\\n            wiki: $tw.wikiName,\\n            heartbeat: true,\\n            token: token\\n          };\\n          $tw.Bob.Shared.sendMessage(data, 0);\\n          tryAgain()\\n        } else {\\n          try {\\n            const temp = JSON.parse(tid.fields.text);\\n            if(temp.persistentUsernames === \\\"yes\\\") {\\n              const savedName = $tw.Bob.getCookie(document.cookie, \\\"userName\\\");\\n              if(savedName) {\\n                $tw.wiki.addTiddler(new $tw.Tiddler({title: \\\"$:/status/UserName\\\", text: savedName}));\\n              }\\n            }\\n          } catch (e) {\\n            // Bleh\\n          }\\n        }\\n      },1000)\\n    }\\n\\n    tryAgain()\\n  }\\n  /*\\n    This is a wrapper function, each message from the websocket server has a\\n    message type and if that message type matches a handler that is defined\\n    than the data is passed to the handler function.\\n  */\\n  const parseMessage = function(event) {\\n    const eventData = JSON.parse(event.data);\\n    if(eventData.type) {\\n      if(typeof $tw.browserMessageHandlers[eventData.type] === 'function') {\\n        $tw.browserMessageHandlers[eventData.type](eventData);\\n      }\\n    }\\n  }\\n\\n  /*\\n    This adds actions for the different event hooks. Each hook sends a\\n    message to the node process.\\n\\n    Some unused hooks have commented out skeletons for adding those hooks in\\n    the future if they are needed.\\n  */\\n  const addHooks = function() {\\n    if(!$tw.wikiName) {\\n      $tw.wikiName = '';\\n    }\\n    $tw.hooks.addHook(\\\"th-editing-tiddler\\\", function(event) {\\n      // Special handling for unedited shadow tiddlers\\n      const token = localStorage.getItem('ws-token');\\n      if($tw.wiki.isShadowTiddler(event.tiddlerTitle) && !$tw.wiki.tiddlerExists(event.tiddlerTitle)) {\\n        // Wait for the document to have focus again and then check for the existence of a draft tiddler for the shadow, if one doesn't exist cancel the edit lock\\n        setTimeout(function(tid) {\\n          if(document.hasFocus()) {\\n            if(!$tw.wiki.findDraft(tid)) {\\n              console.log(\\\"here\\\")\\n              // Cancel the edit lock\\n              const message = {\\n                type: 'cancelEditingTiddler',\\n                tiddler:{\\n                  fields:{\\n                    title: tid\\n                  }\\n                },\\n                wiki: $tw.wikiName,\\n                token: token\\n              };\\n              sendToServer(message);\\n            }\\n          }\\n        }, 200, event.tiddlerTitle)\\n      }\\n      const message = {\\n        type: 'editingTiddler',\\n        tiddler: {\\n          fields: {\\n            title: event.tiddlerTitle\\n          }\\n        },\\n        wiki: $tw.wikiName,\\n        token: token\\n      };\\n      sendToServer(message);\\n      // do the normal editing actions for the event\\n      return true;\\n    });\\n    $tw.hooks.addHook(\\\"th-cancelling-tiddler\\\", function(event) {\\n      const token = localStorage.getItem('ws-token');\\n      const draftTitle = event.param || event.tiddlerTitle;\\n      const draftTiddler = $tw.wiki.getTiddler(draftTitle);\\n      const originalTitle = draftTiddler && draftTiddler.fields[\\\"draft.of\\\"];\\n      const message = {\\n        type: 'cancelEditingTiddler',\\n        tiddler:{\\n          fields:{\\n            title: originalTitle\\n          }\\n        },\\n        wiki: $tw.wikiName,\\n        token: token\\n      };\\n      sendToServer(message);\\n      // Do the normal handling\\n      return event;\\n    });\\n\\n    $tw.Bob.Reconnect = function (sync) {\\n      if($tw.connections[0].socket.readyState !== 1) {\\n        $tw.Bob.setup();\\n        if(sync) {\\n          $tw.Bob.syncToServer();\\n        }\\n      }\\n    }\\n    $tw.Bob.syncToServer = function () {\\n      // Use a timeout to ensure that the websocket is ready\\n      if($tw.connections[0].socket.readyState !== 1) {\\n        setTimeout($tw.Bob.syncToServer, 100)\\n        console.log('waiting')\\n      } else {\\n        /*\\n        // The process here should be:\\n\\n          Send the full list of changes from the browser to the server in a\\n          special message\\n          The server determines if any conflicts exist and marks the tiddlers as appropriate\\n          If there are no conflicts than it just applies the changes from the browser/server\\n          If there are than it marks the tiddler as needing resolution and both versions are made available\\n          All connected browsers now see the tiddlers marked as in conflict and resolution is up to the people\\n\\n          This message is sent to the server, once the server receives it it respons with a special ack for it, when the browser receives that it deletes the unsent tiddler\\n\\n          What is a conflict?\\n\\n          If both sides say to delete the same tiddler there is no conflict\\n          If one side says save and the othre delete there is a conflict\\n          if both sides say save there is a conflict if the two saved versions\\n          aren't the same.\\n        */\\n        // Get the tiddler with the info about local changes\\n        const tiddler = $tw.wiki.getTiddler('$:/plugins/OokTech/Bob/Unsent');\\n        let tiddlerHashes = {};\\n        const allTitles = $tw.wiki.allTitles()\\n        const list = $tw.wiki.filterTiddlers($tw.Bob.ExcludeFilter);\\n        allTitles.forEach(function(tidTitle) {\\n          if(list.indexOf(tidTitle) === -1) {\\n            const tid = $tw.wiki.getTiddler(tidTitle);\\n            tiddlerHashes[tidTitle] = $tw.Bob.Shared.getTiddlerHash(tid);\\n          }\\n        })\\n        // Ask the server for a listing of changes since the browser was\\n        // disconnected\\n        const token = localStorage.getItem('ws-token');\\n        const message = {\\n          type: 'syncChanges',\\n          since: tiddler.fields.start,\\n          changes: tiddler.fields.text,\\n          hashes: tiddlerHashes,\\n          wiki: $tw.wikiName,\\n          token: token\\n        };\\n        sendToServer(message);\\n        $tw.wiki.deleteTiddler('$:/plugins/OokTech/Bob/Unsent')\\n      }\\n    }\\n    /*\\n      Below here are skeletons for adding new actions to existing hooks.\\n      None are needed right now but the skeletons may help later.\\n\\n      Other available hooks are:\\n      th-importing-tiddler\\n      th-relinking-tiddler\\n      th-renaming-tiddler\\n    */\\n    /*\\n      This handles the hook for importing tiddlers.\\n    */\\n    $tw.hooks.addHook(\\\"th-importing-tiddler\\\", function (tiddler) {\\n      if ($tw.wiki.getTextReference('$:/WikiSettings/split##saveMediaOnServer') !== 'no' && $tw.wiki.getTextReference('$:/WikiSettings/split##enableFileServer') === 'yes') {\\n        function updateProgress(e) {\\n          // TODO make this work in different browsers\\n          /*\\n          if (e.lengthComputable) {\\n            var percentComplete = e.loaded/e.total*100;\\n          } else {\\n            var percentComplete = -1;\\n          }\\n          console.log(percentComplete);\\n          */\\n        }\\n        function transferComplete(e) {\\n          console.log('Complete!!');\\n        }\\n        function transferFailed(e) {\\n          console.log('Failed!');\\n        }\\n        function transferCanceled(e) {\\n          console.log('Cancelled!')\\n        }\\n        // Figure out if the thing being imported is something that should be\\n        // saved on the server.\\n        //const mimeMap = $tw.settings.mimeMap || {\\n        const mimeMap = $tw.settings.mimeMap || {\\n          '.aac': 'audio/aac',\\n          '.avi': 'video/x-msvideo',\\n          '.csv': 'text/csv',\\n          '.doc': 'application/msword',\\n          '.epub': 'application/epub+zip',\\n          '.gif': 'image/gif',\\n          '.html': 'text/html',\\n          '.htm': 'text/html',\\n          '.ico': 'image/x-icon',\\n          '.jpg': 'image/jpeg',\\n          '.jpeg': 'image/jpeg',\\n          '.mp3': 'audio/mpeg',\\n          '.mpeg': 'video/mpeg',\\n          '.oga': 'audio/ogg',\\n          '.ogv': 'video/ogg',\\n          '.ogx': 'application/ogg',\\n          '.pdf': 'application/pdf',\\n          '.png': 'image/png',\\n          '.svg': 'image/svg+xml',\\n          '.weba': 'audio/weba',\\n          '.webm': 'video/webm',\\n          '.wav': 'audio/wav'\\n        };\\n        if (Object.values(mimeMap).indexOf(tiddler.fields.type) !== -1 && !tiddler.fields._canonical_uri) {\\n          // Check if this is set up to use HTTP post or websockets to save the\\n          // image on the server.\\n          const request = new XMLHttpRequest();\\n          request.upload.addEventListener('progress', updateProgress);\\n          request.upload.addEventListener('load', transferComplete);\\n          request.upload.addEventListener('error', transferFailed);\\n          request.upload.addEventListener('abort', transferCanceled);\\n\\n          let wikiPrefix = $tw.wiki.getTiddlerText('$:/WikiName') || '';\\n          const uploadURL = '/api/upload';\\n          request.open('POST', uploadURL, true);\\n          // cookies are sent with the request so the authentication cookie\\n          // should be there if there is one.\\n          const thing = {\\n            tiddler: tiddler,\\n            wiki: $tw.wiki.getTiddlerText('$:/WikiName')\\n          }\\n          request.setRequestHeader('x-wiki-name',wikiPrefix);\\n          request.onreadystatechange = function() {\\n            if (request.readyState === XMLHttpRequest.DONE) {\\n              if (request.status === 200) {\\n                // Things should be ok\\n                // The server should send a browser message saying that the\\n                // upload was successful.\\n              } else {\\n                // There is a problem\\n                // Make a tiddler that has the tag $:/tags/Alert that has the text of\\n                // the alert.\\n                const fields = {\\n                  component: 'Server Message',\\n                  title: \\\"Upload Error\\\",\\n                  text: \\\"File failed to upload to server. Try quitting and restarting Bob.\\\"+\\\"<br/><$button>Clear Alerts<$action-deletetiddler $filter='[tag[$:/tags/Alert]component[Server Message]]'/></$button>\\\",\\n                  tags: '$:/tags/Alert'\\n                }\\n                $tw.wiki.addTiddler(new $tw.Tiddler(fields, $tw.wiki.getCreationFields()));\\n              }\\n            }\\n          }\\n          request.send(JSON.stringify(thing));\\n          // Change the tiddler fields and stuff\\n          const fields = {};\\n          wikiPrefix = $tw.wiki.getTiddlerText('$:/WikiName') || '';\\n          wikiPrefix = wikiPrefix === '' ? '' : '/' + wikiPrefix;\\n          $tw.settings.fileURLPrefix = $tw.settings.fileURLPrefix || 'files';\\n          const uri = wikiPrefix + '/' + $tw.settings.fileURLPrefix + '/' + tiddler.fields.title;\\n          fields.title = tiddler.fields.title;\\n          fields.type = tiddler.fields.type;\\n          fields._canonical_uri = uri;\\n          return new $tw.Tiddler(fields);\\n        } else {\\n          return tiddler;\\n        }\\n      } else {\\n        return tiddler;\\n      }\\n    });\\n  }\\n  // Only set up the websockets if we aren't in an iframe or opened as a file.\\n  if (window.location === window.parent.location && window.location.hostname) {\\n    // Send the message to node using the websocket\\n    $tw.Bob.setup();\\n  }\\n}\\n\\n// REQUIRED\\n// The name of the syncer\\nBrowserWSAdaptor.prototype.name = \\\"browserwsadaptor\\\"\\n\\nBrowserWSAdaptor.prototype.supportsLazyLoading = true\\n\\n// REQUIRED\\n// Tiddler info, can be left like this but must be present\\nBrowserWSAdaptor.prototype.getTiddlerInfo = function() {\\n  return {}\\n}\\n\\n// REQUIRED\\n// This does whatever is necessary to actually store a tiddler\\nBrowserWSAdaptor.prototype.saveTiddler = function (tiddler, callback) {\\n  const self = this;\\n  function handleAck(ackId) {\\n    const ind = self.idList.indexOf(ackId);\\n    if (ind > -1) {\\n      self.idList.splice(ind, 1)\\n      callback(null, null)\\n    }\\n  }\\n  if (!this.shouldSync(tiddler.fields.title) || !tiddler) {\\n    callback(null, null);\\n  } else {\\n    const token = localStorage.getItem('ws-token')\\n    let tempTid = {fields:{}};\\n    Object.keys(tiddler.fields).forEach(function (field) {\\n        if(field !== 'created' && field !== 'modified') {\\n          tempTid.fields[field] = tiddler.fields[field];\\n        } else {\\n          tempTid.fields[field] = $tw.utils.stringifyDate(tiddler.fields[field]);\\n        }\\n      }\\n    );\\n    const message = {\\n      type: 'saveTiddler',\\n      tiddler: tempTid,\\n      wiki: $tw.wikiName,\\n      token: token\\n    };\\n    const id = sendToServer(message, callback);\\n    if(id) {\\n      this.idList.push(id)\\n      $tw.rootWidget.addEventListener('handle-ack', function(e) {\\n        handleAck(e.detail)\\n      })\\n    }\\n  }\\n}\\n\\n// REQUIRED\\n// This does whatever is necessary to load a tiddler.\\n// Used for lazy loading\\nBrowserWSAdaptor.prototype.loadTiddler = function (title, callback) {\\n  function handleLoadedTiddler(tiddler) {\\n    callback(null, tiddler.fields)\\n  }\\n  if (title.slice(0,3) === '$:/') {\\n    callback(null, null)\\n  } else {\\n    const token = localStorage.getItem('ws-token')\\n    const message = {\\n      type:'getFullTiddler',\\n      title: title,\\n      token: token,\\n      wiki: $tw.wikiName\\n    }\\n    const id = sendToServer(message)\\n    $tw.rootWidget.addEventListener('loaded-tiddler', function(e) {\\n      handleLoadedTiddler(e.detail)\\n    })\\n  }\\n}\\n\\n// REQUIRED\\n// This does whatever is necessary to delete a tiddler\\nBrowserWSAdaptor.prototype.deleteTiddler = function (title, callback, options) {\\n  const self = this;\\n  function handleAck(ackId) {\\n    const ind = self.idList.indexOf(ackId)\\n    if (ind > -1) {\\n      self.idList.splice(ind, 1)\\n      callback(null, null)\\n    }\\n  }\\n  if (!this.shouldSync(title)) {\\n    callback(null);\\n  } else {\\n    // We have an additional check for tiddlers that start with\\n    // $:/state because popups get deleted before the check is done.\\n    // Without this than every time there is a popup the dirty\\n    // indicator turns on\\n    const token = localStorage.getItem('ws-token');\\n    const message = {\\n      type: 'deleteTiddler',\\n      tiddler:{\\n        fields:{\\n          title:title\\n        }\\n      },\\n      wiki: $tw.wikiName,\\n      token: token\\n    };\\n    const id = sendToServer(message);\\n    this.idList.push(id)\\n    $tw.rootWidget.addEventListener('handle-ack', function(e) {\\n      handleAck(e.detail)\\n    })\\n  }\\n}\\n\\nBrowserWSAdaptor.prototype.shouldSync = function(tiddlerTitle) {\\n  // assume that we are never syncing state and temp tiddlers.\\n  // This may change later.\\n  if (tiddlerTitle.startsWith('$:/state/') || tiddlerTitle.startsWith('$:/temp/')) {\\n    return false;\\n  }\\n  // If the changed tiddler is the one that holds the exclude filter\\n  // than update the exclude filter.\\n  if(tiddlerTitle === '$:/plugins/OokTech/Bob/ExcludeSync') {\\n    $tw.Bob.ExcludeFilter = $tw.wiki.getTiddlerText('$:/plugins/OokTech/Bob/ExcludeSync');\\n  }\\n  const list = $tw.wiki.filterTiddlers($tw.Bob.ExcludeFilter);\\n  if(list.indexOf(tiddlerTitle) === -1) {\\n    return true;\\n  } else {\\n    return false;\\n  }\\n}\\n\\n/*\\nBrowserWSAdaptor.prototype.getUpdatedTiddlers = function() {\\n\\n}\\n*/\\n\\n// OPTIONAL\\n// Returns true if the syncer` is ready, otherwise false\\n// This can be updated at any time, it gets checked when a syncing task is\\n// being run so its value can change over time.\\nBrowserWSAdaptor.prototype.isReady = function() {\\n  return true\\n}\\n/*\\n// OPTIONAL\\n// This checks the login state\\n// it can be used to give an async way to check the status and update the\\n// isReady state. The tiddlyweb adaptor does this.\\nBrowserWSAdaptor.prototype.getStatus = function(callback) {\\n\\n}\\n\\n// OPTIONAL\\n// A login thing, need specifics\\nBrowserWSAdaptor.prototype.login = function (username, password, callback) {\\n\\n}\\n\\n// OPTIONAL\\n// A logout thing, need specifics\\nBrowserWSAdaptor.prototype.logout = function (callback) {\\n\\n}\\n*/\\n\\n// OPTIONAL\\n// Loads skinny tiddlers, need specifics\\nlet thisTimerTemp = undefined\\nfunction setupSkinnyTiddlerLoading() {\\n  if(!$tw.wiki.getTiddler('$:/WikiSettings/split/ws-server')) {\\n    clearTimeout(thisTimerTemp)\\n    thisTimerTemp = setTimeout(function() {\\n      setupSkinnyTiddlerLoading()\\n    }, 100)\\n  } else {\\n    clearTimeout(thisTimerTemp)\\n    if ($tw.wiki.getTiddlerDataCached('$:/WikiSettings/split/ws-server').rootTiddler === '$:/core/save/lazy-all') {\\n      BrowserWSAdaptor.prototype.getSkinnyTiddlers = function (callback) {\\n        function handleSkinnyTiddlers(e) {\\n          callback(null, e)\\n        }\\n        function sendThing() {\\n          function setSendThingTimeout() {\\n            setTimeout(function() {\\n              if ($tw.connections) {\\n                if($tw.connections[0].socket.readyState === 1) {\\n                  id = sendToServer(message)\\n                  $tw.rootWidget.addEventListener('skinny-tiddlers', function(e) {\\n                    handleSkinnyTiddlers(e.detail)\\n                  })\\n                } else {\\n                  setSendThingTimeout()\\n                }\\n              } else {\\n                setSendThingTimeout()\\n              }\\n            }, 100)\\n          }\\n          if ($tw.connections) {\\n            if($tw.connections[0].socket.readyState === 1) {\\n              id = sendToServer(message)\\n              $tw.rootWidget.addEventListener('skinny-tiddlers', function(e) {\\n                handleSkinnyTiddlers(e.detail)\\n              })\\n            } else {\\n              setSendThingTimeout()\\n            }\\n          } else {\\n            setSendThingTimeout()\\n          }\\n        }\\n        const token = localStorage.getItem('ws-token')\\n        const message = {\\n          type: 'getSkinnyTiddlers',\\n          wiki: $tw.wikiName,\\n          token: token\\n        }\\n        let id\\n        sendThing()\\n      }\\n      $tw.syncer.syncFromServer()\\n    }\\n  }\\n}\\n\\n/*\\nconst sendToServer = function (message) {\\n  const tiddlerText = $tw.wiki.getTiddlerText('$:/plugins/OokTech/Bob/Unsent', '');\\n  // If the connection is open, send the message\\n  if($tw.connections[0].socket.readyState === 1) {\\n    const messageData = $tw.Bob.Shared.sendMessage(message, 0);\\n    return messageData.id;\\n  } else {\\n    // If the connection is not open than store the message in the queue\\n    const tiddler = $tw.wiki.getTiddler('$:/plugins/OokTech/Bob/Unsent');\\n    let queue = [];\\n    let start = Date.now();\\n    if(tiddler) {\\n      if(typeof tiddler.fields.text === 'string') {\\n        queue = JSON.parse(tiddler.fields.text);\\n      }\\n      if(tiddler.fields.start) {\\n        start = tiddler.fields.start;\\n      }\\n    }\\n    // Check to make sure that the current message is eligible to be saved\\n    const messageData = $tw.Bob.Shared.createMessageData(message)\\n    if($tw.Bob.Shared.messageIsEligible(messageData, 0, queue)) {\\n      // Prune the queue and check if the current message makes any enqueued\\n      // messages redundant or overrides old messages\\n      queue = $tw.Bob.Shared.removeRedundantMessages(messageData, queue);\\n      // Don't save any messages that are about the unsent list or you get\\n      // infinite loops of badness.\\n      if(messageData.title !== '$:/plugins/OokTech/Bob/Unsent') {\\n        queue.push(messageData);\\n      }\\n      const tiddler2 = {\\n        title: '$:/plugins/OokTech/Bob/Unsent',\\n        text: JSON.stringify(queue, '', 2),\\n        type: 'application/json',\\n        start: start\\n      };\\n      $tw.wiki.addTiddler(new $tw.Tiddler(tiddler2));\\n    }\\n  }\\n}\\n*/\\n\\n// Replace this with whatever conditions are required to use your adaptor\\nif ($tw.browser) {\\n  setupSkinnyTiddlerLoading()\\n  exports.adaptorClass = BrowserWSAdaptor\\n}\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"syncadaptor\"\n        },\n        \"$:/plugins/OokTech/Bob/FileSystemMonitor.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/FileSystemMonitor.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/FileSystemMonitor.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThis module watches the file system in the tiddlers folder and any changes to\\nthe files in the folder that don't come from the browser are reported to the\\nbrowser. So if you make a new .tid file in the tiddlers folder it will appear\\nin the wiki in the browser without needing to restart the server. You can also\\ndelete files to remove the tiddlers from the browser.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = 'FileSystemMonitor';\\nexports.after = [\\\"load-modules\\\"];\\nexports.platforms = [\\\"node\\\"];\\nexports.synchronous = true;\\n\\nif($tw.node && $tw.settings.disableFileWatchers !== 'yes') {\\n  // require the fs module if we are running node\\n  const fs = require(\\\"fs\\\");\\n  const path = require(\\\"path\\\");\\n\\n  // Initialise objects\\n  $tw.Bob = $tw.Bob || {};\\n  $tw.Bob.Files = $tw.Bob.Files || {};\\n\\n  /*\\n    This watches for changes to a folder and updates the wiki prefix when anything changes in the folder.\\n  */\\n  $tw.Bob.WatchFolder = function (folder, prefix) {\\n    // If there is no prefix set it to an empty string\\n    prefix = prefix || '';\\n    $tw.Bob.Wikis[prefix].watchers = $tw.Bob.Wikis[prefix].watchers || {};\\n    try {\\n      $tw.Bob.Wikis[prefix].watchers[folder] = fs.watch(folder, function (eventType, filename) {\\n        filename = filename || \\\"\\\";\\n        // The full path to the current item\\n        const itemPath = path.join(folder, filename);\\n        fs.stat(itemPath, function(err, fileStats) {\\n          // The file extension, if no file extension than an empty string\\n          const fileExtension = path.extname(filename);\\n          if (err) {\\n            if (err.code === 'ENOENT') {\\n              // The item doesn't exist, so it was removed\\n              // If the file doesn't exist anymore remove it from the wiki\\n              if(['.tid', '.meta'].indexOf(fileExtension) !== -1) {\\n                $tw.Bob.DeleteTiddler(folder, filename, prefix);\\n              } else {\\n                $tw.Bob.logger.log('non-tiddler file deleted:', filename, {level: 3})\\n              }\\n            } else if (err.code === 'EACCES') {\\n              // Permissions error\\n            } else {\\n              // Some other error\\n            }\\n          } else {\\n            // Item exists\\n            // If it is a new folder than watch that folder too\\n            if(fileStats.isDirectory()) {\\n              $tw.Bob.WatchFolder(itemPath, prefix)\\n            } else if (fileStats.isFile()) {\\n              const tiddlerName = Object.keys($tw.Bob.Files[prefix]).filter(function (item) {\\n                // This is to handle some edge cases I ran into while making\\n                // it.\\n                if(typeof item === 'string') {\\n                  return ($tw.Bob.Files[prefix][item].filepath === itemPath)\\n                } else {\\n                  return false;\\n                }\\n              })[0];\\n              if (['.tid', '.meta'].indexOf(fileExtension) !== -1) {\\n                let tiddlerObject = {tiddlers:[{}]}\\n                // This try block catches an annoying race condition problem\\n                // when the filesystem adaptor deletes a file the file watcher\\n                // starts acting before the deleting is completely finished.\\n                // This means that it sees the file as still existing and tries // to open it, but it is deleted so there is an error.\\n                try {\\n                  // Load tiddler data from the file\\n                  tiddlerObject = $tw.loadTiddlersFromFile(itemPath);\\n                } catch (e) {\\n                  if (e.code !== 'ENOENT') {\\n                    $tw.Bob.logger.error(e, {level: 3})\\n                  }\\n                  return\\n                }\\n                // Make sure that it at least has a title\\n                if(tiddlerObject.tiddlers[0]['title']) {\\n                  // Test to see if the filename matches what the wiki says it\\n                  // should be. If not rename the file to match the rules set by\\n                  // the wiki.\\n                  // This is the title based on the current .tid file\\n                  let newTitle = $tw.syncadaptor.generateTiddlerBaseFilepath(tiddlerObject.tiddlers[0].title, prefix);\\n                  const existingTiddler = $tw.Bob.Wikis[prefix].wiki.getTiddler(tiddlerObject.tiddlers[0].title);\\n                  // Load the tiddler from the wiki, check if they are different (non-existent is changed)\\n                  if($tw.Bob.Shared.TiddlerHasChanged(existingTiddler, {fields: tiddlerObject.tiddlers[0]})) {\\n                    // Rename the file\\n                    // If $:/config/FileSystemPaths is used than the folder and\\n                    // newTitle may overlap.\\n                    // This determines if any of the title has an overlap in the path\\n                    if(newTitle.replace('\\\\\\\\','/').indexOf('/') !== -1) {\\n                      const pieces = newTitle.replace('\\\\\\\\','/').split('/')\\n                      let pathBits = pieces.slice(0,-1);\\n                      while (pathBits.length > 0) {\\n                        if(folder.endsWith(pathBits.join(path.sep))) {\\n                          break;\\n                        }\\n                        pathBits = pathBits.slice(0,-1);\\n                      }\\n                      if(pathBits.length > 0) {\\n                        newTitle = pieces.slice(pathBits.length).join(path.sep);\\n                      }\\n                    }\\n                    // translate tiddler title into filepath\\n                    const theFilepath = path.join(folder, newTitle + fileExtension);\\n                    if(typeof tiddlerName === 'string' && tiddlerName !== tiddlerObject.tiddlers[0].title) {\\n                      $tw.Bob.logger.log('Rename Tiddler ', tiddlerName, ' to ', newTitle, {level:2});\\n                      // Remove the old tiddler\\n                      $tw.Bob.DeleteTiddler(folder, tiddlerName + fileExtension, prefix);\\n                    }\\n                    function arrayEqual(a1, a2) {\\n                      if (!Array.isArray(a1) || !Array.isArray(a2)) {\\n                        return false\\n                      }\\n                      if (a1 === a2) {\\n                        return true\\n                      }\\n                      if (a1.length !== a2.length) {\\n                        return false\\n                      }\\n                      for (let k = 0; k < a1.length; k++) {\\n                        if (a1[k] !== a2[k]) {\\n                          return false\\n                        }\\n                      }\\n                      return true\\n                    }\\n                    // This handles when a tiddler title doesn't match the path\\n                    // where the tiddler exists. It deletes the tiddler in the\\n                    // incorrect path\\n                    if(itemPath !== theFilepath || !(arrayEqual($tw.Bob.Shared.normalizeTiddler({fields: tiddlerObject.tiddlers[0]}).fields.tags, $tw.utils.parseStringArray(tiddlerObject.tiddlers[0].tags)))) {\\n                      // Delete the old file, the normal delete action takes\\n                      // care of the rest.\\n                      fs.unlink(itemPath, ()=>{\\n                        // Create the new tiddler\\n                        const newTiddler = $tw.Bob.Shared.normalizeTiddler({fields: tiddlerObject.tiddlers[0]});\\n                        // Save the new file\\n                        $tw.syncadaptor.saveTiddler(newTiddler, prefix);\\n                      });\\n                    } else {\\n                      // Create the new tiddler\\n                      const newTiddler = $tw.Bob.Shared.normalizeTiddler({fields: tiddlerObject.tiddlers[0]});\\n                      // Save the new file\\n                      $tw.syncadaptor.saveTiddler(newTiddler, prefix);\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        })\\n      }).on('error', error => {\\n        // Ignore EPERM errors in windows, which happen if you delete watched folders...\\n        if (error.code === 'EPERM' && require('os').platform() === 'win32') {\\n          $tw.Bob.logger.log('[Info] Failed to watch deleted folder.', {level:3});\\n          return;\\n        }\\n      });\\n    } catch (e) {\\n      $tw.Bob.logger.error('Failed to watch folder!', e, {level:1});\\n    }\\n  }\\n\\n  // TODO make this handle deleting .meta files\\n  $tw.Bob.DeleteTiddler = function (folder, filename, prefix) {\\n    const itemPath = path.join(folder, filename);\\n    // Get the file name because it isn't always the same as the tiddler\\n    // title.\\n\\n    // At this point the tiddlerName is the internal name so we need to switch\\n    // to the non-prefixed name for the message to the browsers\\n    Object.keys($tw.Bob.Files[prefix]).forEach(function(tiddlerName) {\\n      if($tw.Bob.Files[prefix][tiddlerName].filepath === itemPath) {\\n        // Remove the tiddler info from $tw.Bob.Files\\n        delete $tw.Bob.Files[prefix][tiddlerName];\\n        // Remove the tiddler on the server\\n        $tw.Bob.Wikis[prefix].wiki.deleteTiddler(tiddlerName);\\n        // Create a message saying to remove the tiddler from the browser\\n        const message = {\\n          type: 'deleteTiddler',\\n          tiddler: {\\n            fields:{\\n              title: tiddlerName\\n            }\\n          },\\n          wiki: prefix\\n        };\\n        // Send the message to each connected browser\\n        $tw.Bob.SendToBrowsers(message);\\n      }\\n    });\\n  }\\n\\n  /*\\n    This function walks through all the folders listed in the folder tree and\\n    creates a watcher for each one.\\n\\n    Each property in the $tw.Bob.FolderTree object has this structure:\\n\\n    {\\n      path: '/path/to/folder'\\n      folders: {\\n        folderName {\\n          // folder object for folderName\\n        },\\n        // Other folders with their folder objects\\n      }\\n    }\\n\\n    TODO: CReate what is necessary so that we can have wikis only sync to\\n    specific folders\\n    This is sort of implemented but I want more control.\\n  */\\n  $tw.Bob.WatchAllFolders = function (folderTree, prefix) {\\n    // Watch the current folder after making sure that the path exists\\n    if(typeof folderTree.path === 'string') {\\n      if(fs.existsSync(folderTree.path)) {\\n        $tw.Bob.WatchFolder(folderTree.path, prefix);\\n      }\\n    }\\n    // Use this same function on each sub-folder listed\\n    Object.keys(folderTree.folders).forEach(function(folder) {\\n      $tw.Bob.WatchAllFolders(folderTree.folders[folder], prefix);\\n    });\\n  }\\n}\\n\\n})();\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/MultiWikiAdaptor.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/MultiWikiAdaptor.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/MultiWikiAdaptor.js\\ntype: application/javascript\\nmodule-type: syncadaptor\\n\\nA sync adaptor module for synchronising multiple wikis\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.platforms = [\\\"node\\\"];\\n\\nif($tw.node) {\\n\\n  // Get a reference to the file system\\n  const fs = require(\\\"fs\\\"),\\n    path = require(\\\"path\\\");\\n\\n  $tw.Bob = $tw.Bob || {};\\n  $tw.Bob.Files = $tw.Bob.Files || {};\\n\\n  /*\\n    TODO Create a message that lets us set excluded tiddlers from inside the wikis\\n    A per-wiki exclude list would be best but that is going to have annoying\\n    logic so it will come later.\\n  */\\n  $tw.Bob.ExcludeFilter = $tw.Bob.ExcludeFilter || \\\"[[$:/StoryList]][[$:/HistoryList]][[$:/status/UserName]][[$:/Import]][prefix[$:/state/]][prefix[$:/temp/]][prefix[$:/WikiSettings]]\\\";\\n\\n  function MultiWikiAdaptor(options) {\\n    this.wiki = options.wiki;\\n  }\\n\\n  MultiWikiAdaptor.prototype.name = \\\"MultiWikiAdaptor\\\";\\n\\n  MultiWikiAdaptor.prototype.isReady = function() {\\n    // The file system adaptor is always ready\\n    return true;\\n  };\\n\\n  MultiWikiAdaptor.prototype.getTiddlerInfo = function(tiddler) {\\n    return {};\\n  };\\n\\n  /*\\n  Return a fileInfo object for a tiddler, creating it if necessary:\\n    filepath: the absolute path to the file containing the tiddler\\n    type: the type of the tiddler file (NOT the type of the tiddler -- see below)\\n    hasMetaFile: true if the file also has a companion .meta file\\n\\n  The boot process populates $tw.boot.files for each of the tiddler files that it loads. The type is found by looking up the extension in $tw.config.fileExtensionInfo (eg \\\"application/x-tiddler\\\" for \\\".tid\\\" files).\\n\\n  It is the responsibility of the filesystem adaptor to update $tw.boot.files for new files that are created.\\n  */\\n  MultiWikiAdaptor.prototype.getTiddlerFileInfo = function(tiddler, prefix, callback) {\\n    prefix = prefix || '';\\n    if(!callback) {\\n      callback = function (err, fileInfo) {\\n        if(err) {\\n          $tw.Bob.logger.error(err, {level:2});\\n        } else {\\n          return fileInfo;\\n        }\\n      }\\n    }\\n    // Generate the base filepath and ensure the directories exist\\n    $tw.Bob.Wikis = $tw.Bob.Wikis || {};\\n    $tw.Bob.Wikis[prefix] = $tw.Bob.Wikis[prefix] || {};\\n    // A cludge to make things work\\n    if(prefix === 'RootWiki') {\\n      $tw.Bob.Wikis[prefix].wikiTiddlersPath = $tw.Bob.Wikis[prefix].wikiTiddlersPath || $tw.boot.wikiTiddlersPath;\\n    }\\n    const tiddlersPath = $tw.Bob.Wikis[prefix].wikiTiddlersPath || path.join($tw.ServerSide.generateWikiPath(prefix), 'tiddlers');\\n    $tw.utils.createFileDirectories(tiddlersPath);\\n\\n    // See if we've already got information about this file\\n    const title = tiddler.fields.title;\\n    $tw.Bob.Files[prefix] = $tw.Bob.Files[prefix] || {};\\n    let fileInfo = $tw.Bob.Files[prefix][title];\\n    if(!fileInfo) {\\n      const systemPathsText = $tw.Bob.Wikis[prefix].wiki.getTiddlerText(\\\"$:/config/FileSystemPaths\\\")\\n      let systemPathsList = []\\n      if (systemPathsText) {\\n        systemPathsList = systemPathsText.split(\\\"\\\\n\\\")\\n      }\\n      // Otherwise, we'll need to generate it\\n      fileInfo = $tw.utils.generateTiddlerFileInfo(tiddler,{\\n        directory: tiddlersPath,\\n        pathFilters: systemPathsList,\\n        wiki: $tw.Bob.Wikis[prefix].wiki\\n      });\\n\\n      $tw.Bob.Files[prefix][title] = fileInfo;\\n      $tw.Bob.Wikis[prefix].tiddlers = $tw.Bob.Wikis[prefix].tiddlers || [];\\n      if($tw.Bob.Wikis[prefix].tiddlers.indexOf(title) === -1) {\\n        $tw.Bob.Wikis[prefix].tiddlers.push(title);\\n      }\\n    }\\n    callback(null,fileInfo);\\n  };\\n\\n  /*\\n  Given a list of filters, apply every one in turn to source, and return the first result of the first filter with non-empty result.\\n  */\\n  MultiWikiAdaptor.prototype.findFirstFilter = function(filters,source) {\\n    for(let i=0; i<filters.length; i++) {\\n      const result = this.wiki.filterTiddlers(filters[i],null,source);\\n      if(result.length > 0) {\\n        return result[0];\\n      }\\n    }\\n    return null;\\n  };\\n\\n  /*\\n  Given a tiddler title and an array of existing filenames, generate a new legal filename for the title, case insensitively avoiding the array of existing filenames\\n  */\\n  MultiWikiAdaptor.prototype.generateTiddlerBaseFilepath = function(title, wiki) {\\n    let baseFilename;\\n    let pathNameFilters;\\n    // Check whether the user has configured a tiddler -> pathname mapping\\n    if($tw.Bob.Wikis[wiki].wiki) {\\n      pathNameFilters = $tw.Bob.Wikis[wiki].wiki.getTiddlerText(\\\"$:/config/FileSystemPaths\\\");\\n    }\\n    if(pathNameFilters) {\\n      const source = $tw.Bob.Wikis[wiki].wiki.makeTiddlerIterator([title]);\\n      baseFilename = this.findFirstFilter(pathNameFilters.split(\\\"\\\\n\\\"),source);\\n      if(baseFilename) {\\n        // Interpret \\\"/\\\" and \\\"\\\\\\\" as path separator\\n        baseFilename = baseFilename.replace(/\\\\/|\\\\\\\\/g,path.sep);\\n      }\\n    }\\n    if(!baseFilename) {\\n      // No mappings provided, or failed to match this tiddler so we use title as filename\\n      baseFilename = title.replace(/\\\\/|\\\\\\\\/g,\\\"_\\\");\\n    }\\n    // Remove any of the characters that are illegal in Windows filenames\\n    baseFilename = $tw.utils.transliterate(baseFilename.replace(/<|>|\\\\:|\\\\\\\"|\\\\||\\\\?|\\\\*|\\\\^/g,\\\"_\\\"));\\n    // Truncate the filename if it is too long\\n    if(baseFilename.length > 200) {\\n      baseFilename = baseFilename.substr(0,200);\\n    }\\n    return baseFilename;\\n  };\\n\\n  /*\\n  Save a tiddler and invoke the callback with (err,adaptorInfo,revision)\\n  */\\n  MultiWikiAdaptor.prototype.saveTiddler = function(tiddler, prefix, callback) {\\n    const self = this;\\n    if(typeof prefix === 'function') {\\n      callback = prefix;\\n      prefix = null;\\n    }\\n    if(typeof callback !== 'function') {\\n      callback = function () {\\n\\n      }\\n    }\\n    prefix = prefix || 'RootWiki';\\n    if (!$tw.Bob.Wikis[prefix]) {\\n      $tw.ServerSide.loadWiki(prefix, finish);\\n    } else {\\n      finish();\\n    }\\n    function finish() {\\n      if (tiddler && $tw.Bob.Wikis[prefix].wiki.filterTiddlers($tw.Bob.ExcludeFilter).indexOf(tiddler.fields.title) === -1) {\\n        self.getTiddlerFileInfo(new $tw.Tiddler(tiddler.fields), prefix,\\n         function(err,fileInfo) {\\n          if(err) {\\n            return callback(err);\\n          }\\n          // Make sure that the tiddler has actually changed before saving it\\n          if ($tw.Bob.Shared.TiddlerHasChanged(tiddler, $tw.Bob.Wikis[prefix].wiki.getTiddler(tiddler.fields.title))) {\\n            // Save the tiddler in memory.\\n            internalSave(tiddler, prefix);\\n            $tw.Bob.logger.log('Save Tiddler ', tiddler.fields.title, {level:2});\\n            try {\\n              $tw.utils.saveTiddlerToFileSync(new $tw.Tiddler(tiddler.fields), fileInfo)\\n              $tw.hooks.invokeHook('wiki-modified', prefix);\\n            } catch (e) {\\n                $tw.Bob.logger.log('Error Saving Tiddler ', tiddler.fields.title, e, {level:1});\\n            }\\n          }\\n        });\\n      }\\n    }\\n  };\\n\\n  // Before the tiddler file is saved this takes care of the internal part\\n  function internalSave (tiddler, prefix) {\\n    $tw.Bob.Wikis[prefix].wiki.addTiddler(new $tw.Tiddler(tiddler.fields));\\n    const message = {\\n      type: 'saveTiddler',\\n      wiki: prefix,\\n      tiddler: {\\n        fields: tiddler.fields\\n      }\\n    };\\n    $tw.Bob.SendToBrowsers(message);\\n    // This may help\\n    $tw.Bob.Wikis = $tw.Bob.Wikis || {};\\n    $tw.Bob.Wikis[prefix] = $tw.Bob.Wikis[prefix] || {};\\n    $tw.Bob.Wikis[prefix].tiddlers = $tw.Bob.Wikis[prefix].tiddlers || [];\\n    if($tw.Bob.Wikis[prefix].tiddlers.indexOf(tiddler.fields.title) === -1) {\\n      $tw.Bob.Wikis[prefix].tiddlers.push(tiddler.fields.title);\\n    }\\n  }\\n\\n  /*\\n  Load a tiddler and invoke the callback with (err,tiddlerFields)\\n\\n  We don't need to implement loading for the file system adaptor, because all the tiddler files will have been loaded during the boot process.\\n  */\\n  MultiWikiAdaptor.prototype.loadTiddler = function(title,callback) {\\n    if(!callback) {\\n      callback = function () {\\n\\n      }\\n    }\\n    callback(null,null);\\n  };\\n\\n  /*\\n  Delete a tiddler and invoke the callback with (err)\\n  */\\n  MultiWikiAdaptor.prototype.deleteTiddler = function(title, callback, options) {\\n    if(typeof callback === 'object') {\\n      options = callback;\\n      callback = null;\\n    }\\n    if(!callback || typeof callback === 'object') {\\n      callback = function () {\\n        // Just a blank function to prevent errors\\n      }\\n    }\\n    if(typeof options !== 'object') {\\n      options = {}\\n    }\\n    const prefix = options.wiki;\\n    const fileInfo = $tw.Bob.Files[prefix][title];\\n    // Only delete the tiddler if we have writable information for the file\\n    if(fileInfo) {\\n      // Delete the file\\n      fs.unlink(fileInfo.filepath,function(err) {\\n        if(err) {\\n          $tw.Bob.logger.log('error deleting file ', fileInfo.filepath, 'with error', err, {level:2});\\n          return callback(err);\\n        }\\n        $tw.Bob.logger.log('deleted file ', fileInfo.filepath, {level:2});\\n        // Delete the tiddler from the internal tiddlywiki side of things\\n        delete $tw.Bob.Files[prefix][title];\\n        $tw.Bob.Wikis[prefix].wiki.deleteTiddler(title);\\n        // Create a message saying to remove the tiddler\\n        const message = {type: 'deleteTiddler', tiddler: {fields:{title: title}}, wiki: prefix};\\n        // Send the message to each connected browser\\n        $tw.Bob.SendToBrowsers(message);\\n        $tw.hooks.invokeHook('wiki-modified', prefix);\\n        // Delete the metafile if present\\n        if(fileInfo.hasMetaFile) {\\n          fs.unlink(fileInfo.filepath + \\\".meta\\\",function(err) {\\n            if(err) {\\n              $tw.Bob.logger.log('error deleting file ', fileInfo.filepath, 'with error', err, {level:2});\\n              return callback(err);\\n            }\\n            $tw.Bob.logger.log('deleting meta file ', fileInfo.filepath + '.meta', {level:3});\\n            return $tw.utils.deleteEmptyDirs(path.dirname(fileInfo.filepath),callback);\\n          });\\n        } else {\\n          return $tw.utils.deleteEmptyDirs(path.dirname(fileInfo.filepath),callback);\\n        }\\n      });\\n    } else {\\n      callback(null);\\n    }\\n  };\\n\\n  if ($tw.node) {\\n    exports.adaptorClass = MultiWikiAdaptor;\\n  }\\n}\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"syncadaptor\"\n        },\n        \"$:/plugins/OokTech/Bob/language-info.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/language-info.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/language-info.js\\ntype: application/javascript\\nmodule-type: utils-node\\n\\nInformation about the available languages\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst fs = require(\\\"fs\\\");\\nconst path = require(\\\"path\\\");\\n\\nlet languageInfo = undefined;\\n\\nexports.getLanguageInfo = function() {\\n  if(!languageInfo || true) {\\n    // Enumerate the language paths\\n    $tw.Bob.logger.error('Getting language paths', {level:4});\\n    const languagePaths = $tw.getLibraryItemSearchPaths($tw.config.languagesPath,$tw.config.languagesEnvVar);\\n    languageInfo = {};\\n    for(let languageIndex=0; languageIndex<languagePaths.length; languageIndex++) {\\n      const languagePath = path.resolve(languagePaths[languageIndex]);\\n      $tw.Bob.logger.error('Getting info for language from ', languagePaths[languageIndex], {level:4});\\n      // Enumerate the folders\\n      try {\\n        const languages = fs.readdirSync(languagePath);\\n        languages.forEach(function(language) {\\n          // Check if directories have a valid plugin.info\\n          if(!languageInfo[language] && $tw.utils.isDirectory(path.resolve(languagePath,language))) {\\n            let info = false;\\n            try {\\n              info = JSON.parse(fs.readFileSync(path.resolve(languagePath,language,\\\"plugin.info\\\"),\\\"utf8\\\"));\\n              $tw.Bob.logger.log('Got info for ', language, {level: 4});\\n            } catch(ex) {\\n              $tw.Bob.logger.error('Reading language info failed ', ex, {level: 3});\\n              $tw.Bob.logger.error('Failed to read language ', language, {level:4})\\n            }\\n            if(info) {\\n              languageInfo[language] = info;\\n            }\\n          }\\n        })\\n      } catch (e) {\\n        if(e.code === 'ENOENT') {\\n          $tw.Bob.logger.log('No Languages Folder ' + languagePaths[languageIndex], {level:3});\\n        } else {\\n          $tw.Bob.logger.error('Error getting language info', e, {level:2});\\n        }\\n      }\\n    }\\n  }\\n  return languageInfo;\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"utils-node\"\n        },\n        \"$:/plugins/OokTech/Bob/plugin-info.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/plugin-info.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/plugin-info.js\\ntype: application/javascript\\nmodule-type: utils-node\\n\\nInformation about the available plugins\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst fs = require(\\\"fs\\\");\\nconst path = require(\\\"path\\\");\\n\\nlet pluginInfo;\\n\\nexports.getPluginInfo = function() {\\n  if(!pluginInfo || true) {\\n    $tw.Bob.logger.error('Getting plugin paths', {level:4});\\n    // Enumerate the plugin paths\\n    const pluginPaths = $tw.getLibraryItemSearchPaths($tw.config.pluginsPath,$tw.config.pluginsEnvVar);\\n    pluginInfo = {};\\n    for(let pluginIndex=0; pluginIndex<pluginPaths.length; pluginIndex++) {\\n      const pluginPath = path.resolve(pluginPaths[pluginIndex]);\\n      $tw.Bob.logger.log('Reading theme from ', pluginPaths[pluginIndex], {level:4});\\n      // Enumerate the folders\\n      try {\\n        const authors = fs.readdirSync(pluginPath);\\n        for(let authorIndex=0; authorIndex<authors.length; authorIndex++) {\\n          const pluginAuthor = authors[authorIndex];\\n          if($tw.utils.isDirectory(path.resolve(pluginPath,pluginAuthor))) {\\n            const pluginNames = fs.readdirSync(path.join(pluginPath,pluginAuthor));\\n            pluginNames.forEach(function(pluginName) {\\n              // Check if directories have a valid plugin.info\\n              if(!pluginInfo[pluginAuthor + '/' + pluginName] && $tw.utils.isDirectory(path.resolve(pluginPath,pluginAuthor,pluginName))) {\\n                let info = false;\\n                try {\\n                  info = JSON.parse(fs.readFileSync(path.resolve(pluginPath,pluginAuthor, pluginName,\\\"plugin.info\\\"),\\\"utf8\\\"));\\n                } catch(ex) {\\n                  $tw.Bob.logger.error('Reading plugin info failed ', ex, {level: 3});\\n                  $tw.Bob.logger.error('Failed to read plugin ', pluginAuthor, '/', pluginName, {level:4});\\n                }\\n                if(info) {\\n                  pluginInfo[pluginAuthor + '/' + pluginName] = info;\\n                  $tw.Bob.logger.error('Read info for plugin ', pluginName, {level:4})\\n                }\\n              }\\n            })\\n          }\\n        }\\n      } catch (e) {\\n        if(e.code === 'ENOENT') {\\n          $tw.Bob.logger.log('No Plugins Folder ' + pluginPaths[pluginIndex], {level:2});\\n        } else {\\n          $tw.Bob.logger.error('Error getting plugin info', e, {level:2})\\n        }\\n      }\\n    }\\n  }\\n  return pluginInfo;\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"utils-node\"\n        },\n        \"$:/plugins/OokTech/Bob/theme-info.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/theme-info.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/theme-info.js\\ntype: application/javascript\\nmodule-type: utils-node\\n\\nInformation about the available themes\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst fs = require(\\\"fs\\\");\\nconst path = require(\\\"path\\\");\\n\\nlet themeInfo;\\n\\nexports.getThemeInfo = function() {\\n  if(!themeInfo || true) {\\n    // Enumerate the theme paths\\n    $tw.Bob.logger.log('Getting theme paths', {level:4});\\n    const themePaths = $tw.getLibraryItemSearchPaths($tw.config.themesPath,$tw.config.themesEnvVar);\\n    themeInfo = {};\\n    for(let themeIndex=0; themeIndex<themePaths.length; themeIndex++) {\\n      $tw.Bob.logger.log('Reading theme from ', themePaths[themeIndex], {level:4});\\n      const themePath = path.resolve(themePaths[themeIndex]);\\n      // Enumerate the folders\\n      try {\\n        const authors = fs.readdirSync(themePath);\\n        for(let authorIndex=0; authorIndex<authors.length; authorIndex++) {\\n          const themeAuthor = authors[authorIndex];\\n          if($tw.utils.isDirectory(path.resolve(themePath,themeAuthor))) {\\n            const themeNames = fs.readdirSync(path.join(themePath,themeAuthor));\\n            themeNames.forEach(function(themeName) {\\n              // Check if directories have a valid plugin.info\\n              if(!themeInfo[themeAuthor + '/' + themeName] && $tw.utils.isDirectory(path.resolve(themePath,themeAuthor,themeName))) {\\n                let info = false;\\n                try {\\n                  info = JSON.parse(fs.readFileSync(path.resolve(themePath,themeAuthor, themeName,\\\"plugin.info\\\"),\\\"utf8\\\"));\\n                } catch(ex) {\\n                  $tw.Bob.logger.error('Reading theme info failed ', ex, {level: 3});\\n                  $tw.Bob.logger.error('Failed to read theme ', themeAuthor, '/', themeName, {level:4})\\n                }\\n                if(info) {\\n                  themeInfo[themeAuthor + '/' + themeName] = info;\\n                  $tw.Bob.logger.error('Read info for theme ', themeName, {level:4});\\n                }\\n              }\\n            })\\n          }\\n        }\\n      } catch (e) {\\n        if(e.code === 'ENOENT') {\\n          $tw.Bob.logger.log('No Themes Folder ' + themePaths[themeIndex], {level:2});\\n        } else {\\n          $tw.Bob.logger.error('Error getting theme info', e, {level:2});\\n        }\\n      }\\n    }\\n  }\\n  return themeInfo;\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"utils-node\"\n        },\n        \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/ISSUE_TEMPLATE.md\": {\n            \"title\": \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/ISSUE_TEMPLATE.md\",\n            \"text\": \"Make sure you read contributing.md and check the correct boxes below and then\\nadd your issue text here.\\nIf you don't than the issue will be tagged as spam and closed or deleted.\\n\\n\\n---\\n\\nI am running (check any that apply, put an x inside the [ ] to check a box, like this: [x]):\\n\\n- [ ] Windows\\n- [ ] OSX\\n- [ ] Linux\\n- [ ] Other\\n\\nand using\\n\\n- [ ] The nodejs version\\n- [ ] The single file executable\\n\\nBefore posting I read [issue guidelines](./IssueGuidelines.md) and:\\n\\n- [ ] I am using the newest version\\n- [ ] The answer to my question isn't listed in the documentation or this isn't\\n  a question\\n- [ ] This is not a duplicate issue\\n- [ ] I have not done anything that required me to set acceptance to\\n  `I Will Not Get Tech Support For This`\\n\",\n            \"type\": \"text/x-markdown\"\n        },\n        \"$:/plugins/Bob/ImportList\": {\n            \"title\": \"$:/plugins/Bob/ImportList\",\n            \"caption\": \"Import List\",\n            \"text\": \"These are the tiddlers from the most recent import:\\n\\n<$list\\n  filter='[list[$:/status/Bob/importlist]]'\\n>\\n\\n</$list>\\n\\nThese are tiddlers that currently are waiting to be imported:\\n\\n<$list\\n  filter='[prefix[$:/state/Bob/Import/]limit[1]]'\\n  variable='dummy'\\n  emptyMessage=\\\"''There are no tiddlers waiting for import, you can close this tiddler''\\\"\\n>\\n  <$button>\\n    Accept all\\n    <$list\\n      filter='[prefix[$:/state/Bob/Import/]]'\\n    >\\n      <$list\\n        filter='[is[current]removeprefix[$:/state/Bob/Import/]]'\\n        variable=NewTitle\\n      >\\n        <$action-setfield\\n          $tiddler=<<currentTiddler>>\\n          $field='title'\\n          $value=<<NewTitle>>\\n          $timestamp='no'\\n        />\\n        <$action-deletetiddler\\n          $tiddler=<<currentTiddler>>\\n        />\\n      </$list>\\n    </$list>\\n  </$button>\\n  <$button>\\n    Discard import\\n    <$action-deletetiddler\\n      $filter='[prefix[$:/state/Bob/Import/]]'\\n    />\\n  </$button>\\n  <table\\n    style='width:100%'\\n  >\\n    <$list\\n      filter='[prefix[$:/state/Bob/Import/]]'\\n    >\\n      <tr>\\n        <td>\\n          <$list\\n            filter='[is[current]removeprefix[$:/state/Bob/Import/]]'\\n          >\\n            <$view\\n              field='title'\\n            />\\n          </$list>\\n        </td>\\n        <td>\\n        <$list\\n          filter='[is[current]removeprefix[$:/state/Bob/Import/]has[title]]'\\n          emptyMessage='No Local Version'\\n        >\\n          <$link>\\n            <$link\\n              to=<<currentTiddler>>\\n            >\\n              Local Version\\n            </$link>\\n          </$link>\\n        </$list>\\n        </td>\\n        <td>\\n          <$link\\n            to=<<currentTiddler>>\\n          >\\n            Import Version\\n          </$link>\\n        </td>\\n        <td>\\n          <$button>\\n            <$list\\n              filter='[is[current]removeprefix[$:/state/Bob/Import/]has[title]]'\\n              emptyMessage='Discard'\\n            >\\n              Keep original\\n            </$list>\\n            <$action-deletetiddler\\n              $tiddler=<<currentTiddler>>\\n            />\\n          </$button>\\n          <$button>\\n            Use imported\\n            <$list\\n              filter='[is[current]removeprefix[$:/state/Bob/Import/]]'\\n              variable=NewTitle\\n            >\\n              <$action-setfield\\n                $tiddler=<<currentTiddler>>\\n                $field='title'\\n                $value=<<NewTitle>>\\n                $timestamp='no'\\n              />\\n              <$action-deletetiddler\\n                $tiddler=<<currentTiddler>>\\n              />\\n            </$list>\\n          </$button>\\n        </td>\\n      </tr>\\n    </$list>\\n  </table>\\n</$list>\\n\"\n        },\n        \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/IssueGuidelines.md\": {\n            \"title\": \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/IssueGuidelines.md\",\n            \"text\": \"# If you are thinking about posting an issue\\n\\nThank you! More people being involved means we can make free software better\\nfor everyone.\\n\\nThere are some guidelines to help create and support a functioning and\\nrespectful environment.\\n\\n## To help with tech support type issues here are a few things to check before you post an issue:\\n\\n- Are you using the newest version? If not update to the newest version and see\\n  if the issue persists. If not than don't worry about creating a new issue for\\n  a resolved problem.\\n- Is your question already answered in the documentation? Check the\\n  [readme](https://github.com/OokTech/TW5-Bob),\\n  [configuration documentation](https://github.com/OokTech/TW5-Bob/blob/master/Configuration.md)\\n  and [general documentation](https://github.com/OokTech/TW5-Bob/tree/master/Documentation)\\n- Are you asking a question that is already part of another issue? If so add to\\n  the conversation in that issue instead of creating a new one to make it\\n  easier for people in the future to see progress being made.\\n- Is the question you are asking about this plugin or would it be better to ask\\n  it on the [TiddyWiki issues board?](https://github.com/Jermolene/TiddlyWiki5)\\n  This may not always be obvious so don't worry too much about this one, but\\n  take a moment to consider it before posting an issue.\\n\\n## Some other guidelines\\n\\n- Are you asking for free engineering work? The people who work on this project\\n  do so for their own reasons, please show them enough respect to not consider\\n  them your unpaid engineering department.\\n  - If you are part of a company with a team and are requesting some\\n    enterprise grade additions to help than we suggest you consider emailing\\n    info@ooktech.com and request a quote if you want a custom implementation.\\n  - One possible exception to this is education. We have a soft spot for\\n    education and often help where we can.\\n- @inmysocks, the lead on the project, is dyslexic. Please do not include text\\n  styling in your issues aside from code blocks if necessary. While using bold,\\n  italics, underlined or colored text may make certain parts of the text stand\\n  out more for you they are very difficult for some people, including the\\n  project lead, to read.\\n\",\n            \"type\": \"text/x-markdown\"\n        },\n        \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/LICENSE\": {\n            \"title\": \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/LICENSE\",\n            \"text\": \"BSD 3-Clause License\\n\\nCopyright (c) 2017, OokTech LLC\\nAll rights reserved.\\n\\nRedistribution and use in source and binary forms, with or without\\nmodification, are permitted provided that the following conditions are met:\\n\\n* Redistributions of source code must retain the above copyright notice, this\\n  list of conditions and the following disclaimer.\\n\\n* Redistributions in binary form must reproduce the above copyright notice,\\n  this list of conditions and the following disclaimer in the documentation\\n  and/or other materials provided with the distribution.\\n\\n* Neither the name of the copyright holder nor the names of its\\n  contributors may be used to endorse or promote products derived from\\n  this software without specific prior written permission.\\n\\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\",\n            \"type\": \"text/plain\"\n        },\n        \"$:/plugins/OokTech/Bob/HelpButtonMacro\": {\n            \"title\": \"$:/plugins/OokTech/Bob/HelpButtonMacro\",\n            \"tags\": \"$:/tags/Macro\",\n            \"text\": \"\\\\define helpButton(tid)\\n<$button\\n  popup=\\\"\\\"\\\"$:/temp/popup/$tid$\\\"\\\"\\\"\\n  class='tc-btn-invisible'\\n>^^(?)^^</$button>\\n<$reveal\\n  type='popup'\\n  state=\\\"\\\"\\\"$:/temp/popup/$tid$\\\"\\\"\\\"\\n>\\n    <div\\n      style='padding: 10px;border: 1px solid grey;\\n    \\tbackground-color: white;\\n    \\tpadding: 7px 0 7px 0;\\n    \\tmargin: 4px 0 0 0;\\n    \\ttext-shadow: none;\\n    \\tline-height: 1.4;\\n      min-width:50vw;\\n      padding:10px;\\n      max-width:90vw;'\\n    >\\n      {{$tid$}}\\n    </div>\\n</$reveal>\\n\\\\end\\n\\n!! The helpButton macro\\n\\nThis is used in Bob to provide context help.\\nIt makes the little buttons that look like this:<<helpButton>>\\n\\n!! Inputs\\n\\n|!Input |!Description |!Default |\\n|!tid |The tiddler to transclude as the help message. |No Default |\\n\\n!! Usage\\n\\n```\\nDocumentation Exists<<helpButton \\\"$:/plugins/OokTech/Bob/Documentation/Bob Documentation\\\">>\\n```\\n\\nrenders as\\n\\nDocumentation Exists<<helpButton \\\"$:/plugins/OokTech/Bob/Documentation/Bob Documentation\\\">>\"\n        },\n        \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/MultiUserWiki/example-start-script.sh\": {\n            \"title\": \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/MultiUserWiki/example-start-script.sh\",\n            \"text\": \"#!/usr/bin/env bash\\n\\n# INSTRUCTIONS\\n#\\n# First you need to change the part after TIDDLYWIKI_PLUGIN_PATH= to match the\\n# location of the folder with your plugins\\n# If you have any themes or editions that you want to make available you can\\n# uncomment the lines below and add the path to them too.\\n#\\n# Then in the last line change ~/path/to/wiki/ to the path to your wiki folder.\\n#\\n# You can rename this file to whatever you want, and you can run this file from\\n# wherever you want.\\n# You will probably have to make this file executable on your system by typing:\\n#\\n# sudo chmod +x ./example-start-script.sh\\n#\\n# in the same folder as the script. On many systems you can also do this from\\n# the file manager but how to do it is different in different file managers.\\n# So if you know how to make a file executable form the file manager that\\n# should work too.\\n\\n# You need to use the full path here, ~/TiddlyWiki/Plugins doesn't work\\nexport TIDDLYWIKI_PLUGIN_PATH=\\\"/path/to/TiddlyWiki/Plugins\\\"\\n#export TIDDLYWIKI_THEME_PATH=\\\"/path/to/TiddlyWiki/Themes\\\"\\n#export TIDDLYWIKI_EDITION_PATH=\\\"/path/to/TiddlyWiki/Editions\\\"\\n\\n# The first argument is the path to the folder that contains the\\n# tiddlywiki.info file. The second is the server command for the Bob\\n# wiki.\\ntiddlywiki ~/path/to/wiki/ --wsserver\\n\",\n            \"type\": \".sh\"\n        },\n        \"$:/DefaultTiddlers\": {\n            \"title\": \"$:/DefaultTiddlers\",\n            \"created\": \"20171108214559509\",\n            \"modified\": \"20171108214652703\",\n            \"text\": \"[[What is this?]]\"\n        },\n        \"$:/Bob/EditingTiddlers\": {\n            \"title\": \"$:/Bob/EditingTiddlers\",\n            \"list\": \"\"\n        },\n        \"What is this?\": {\n            \"title\": \"What is this?\",\n            \"creator\": \"inmysocks\",\n            \"text\": \"!Welcome to the Bob ~TiddlyWiki.\\n\\n!! Connecting other computers to the wiki\\n\\n''BIG NOTE OF DOOM or what is the local network?:'' The local network is anyone\\nusing the same router as you. This means anyone on the same wifi network or\\nusing a wired connection on the same router. So when you are at starbucks or a\\nlibrary on the wifi anyone else who is on that wifi is on the local network.\\n\\nBy default the wiki is only available on `localhost` on the computer you are\\nrunning the node process on.\\n\\nIf you want to make it available to other computers on the local network you\\nhave to change the settings in the $:/ControlPanel under the `Bob Settings`\\ntab.\\n\\nThere are a few tabs available in the `Bob Settings`:\\n\\n* The `Manage Wikis` tab lets you create new wikis and manage existing wikis.\\n* The `This Wiki` tab lets you change the plugins and themes that are available and active in the current wiki.\\n* The `Server` tab lets you do things that affect the wiki server, like making the wikis available on the local network and setting up a static file server to access local media files.\\n* The `Federation` tab has some very experimental things, they probably won't work well.\\n* The `Bob Documentation` tab has further documentation about Bob.\\n* The `About OokTech/Support Documentation` tab has information about OokTech and how to to support the further development of Bob and the related plugins.\\n\\nMore Bob documentation [[$:/plugins/OokTech/Bob/readme]]\\n\\nThings you may want to do:\\n\\n* Enable the [[media file server|$:/plugins/OokTech/Bob/FileServerSetup]]\\n* Make the served wikis [[available on the local network|$:/plugins/OokTech/Bob/ServerTab]]\\n\"\n        },\n        \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/MultiUserWiki/tiddlywiki.info\": {\n            \"title\": \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/MultiUserWiki/tiddlywiki.info\",\n            \"text\": \"{\\n\\t\\\"description\\\": \\\"This is the demo edition for the Bob plugin created by OokTech\\\",\\n\\t\\\"plugins\\\": [\\n    \\\"OokTech/Bob\\\"\\n\\t],\\n\\t\\\"themes\\\": [\\n\\t\\t\\\"tiddlywiki/vanilla\\\",\\n\\t\\t\\\"tiddlywiki/snowwhite\\\"\\n\\t],\\n\\t\\\"build\\\": {\\n\\t\\t\\\"index\\\": [\\n\\t\\t\\t\\\"--rendertiddler\\\",\\\"$:/core/save/all\\\",\\\"index.html\\\",\\\"text/plain\\\"]\\n\\t}\\n}\\n\",\n            \"type\": \".info\"\n        },\n        \"$:/plugins/OokTech/Bob/Acknowledgements\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Acknowledgements\",\n            \"text\": \"This plugin was created and is maintained by [[OokTech|$:/plugins/OokTech/OokTechInfo]].\\n\\nYou can support the development of this plugin and others by supporting OokTech on\\n\\n* [[our patreon page|https://www.patreon.com/OokTech]]\\n* [[OokTech LiberaPay Page|https://liberapay.com/OokTech]]\\n\\n[[Tiddlywiki|http://TiddlyWiki.com]] was originally created by [[Jeremy Ruston|https://github.com/Jermolene/TiddlyWiki5]]. For general ~TiddlyWiki help see [[tiddlywiki.com|http://tiddlywiki.com]] or the [[google group|https://groups.google.com/forum/#!forum/tiddlywiki]].\\n\\nThank you to the general TiddlyWiki community for developing and maintaining the tiddlywiki core.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/License\": {\n            \"title\": \"$:/plugins/OokTech/Bob/License\",\n            \"text\": \"BSD 3-Clause License\\n\\nCopyright (c) 2017, OokTech LLC\\nAll rights reserved.\\n\\nRedistribution and use in source and binary forms, with or without\\nmodification, are permitted provided that the following conditions are met:\\n\\n* Redistributions of source code must retain the above copyright notice, this\\n  list of conditions and the following disclaimer.\\n\\n* Redistributions in binary form must reproduce the above copyright notice,\\n  this list of conditions and the following disclaimer in the documentation\\n  and/or other materials provided with the distribution.\\n\\n* Neither the name of the copyright holder nor the names of its\\n  contributors may be used to endorse or promote products derived from\\n  this software without specific prior written permission.\\n\\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/OokTechInfo\": {\n            \"title\": \"$:/plugins/OokTech/Bob/OokTechInfo\",\n            \"caption\": \"About OokTech/Support Development\",\n            \"text\": \"~OokTech is a small engineering company based in the USA with an international presence. We work on open software and hardware projects.\\n\\n* Contact Email: info@ooktech.com\\n* Website: http://Ooktech.com\\n* ~GitHub: [[OokTech GitHub|https://github.com/OokTech]]\\n\\nYou can support the development of this and other plugins using:\\n\\n* Patreon: [[Support on Patreon|https://www.patreon.com/OokTech]]\\n* ~PayPal: [[Support using PayPal|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=ZG94CTLHTKYRE]]\\n<!--* LiberaPay: [[Support on LiberaPay|https://liberapay.com/OokTech]]-->\\n\"\n        },\n        \"$:/pluginlibrary/OokTech/OokTechPlugins\": {\n            \"title\": \"$:/pluginlibrary/OokTech/OokTechPlugins\",\n            \"tags\": \"$:/tags/PluginLibrary\",\n            \"url\": \"https://ooktech.com/TiddlyWiki/PluginLibrary\",\n            \"text\": \"The plugin library for plugins developed and maintained by OokTech. See http://OokTech.com/TiddlyWiki for more information.\\n\"\n        },\n        \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/README.md\": {\n            \"title\": \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/README.md\",\n            \"text\": \"# TW5-Bob\\n\\nBIG DISCLAMER OF DOOM - Back up your data. Do it. This has been tested but\\nthere may be bugs that I don't know about. Also see notes below.\\n\\n## What does it do?\\n\\n- Multi-User support for using/editing the same wiki(s) simultaneously\\n- Multi-Wiki support - run it once and serve multiple wikis\\n- Create and configure new wikis from inside the root wiki\\n- Export single file wikis in a variety of ways\\n- Two-way real-time syncing between the browser and file system\\n- All configuration can be done from inside the wiki\\n- Serve external files (like images) so you can include them in your wikis\\n- Allows you to run shell scripts and commands from inside the wiki\\n- Can be used as a plugin library to make plugins available to other wikis (requires the TWederBob plugin on the other wikis to connect)\\n- Inter-server federation. Different Bob servers can communicate to share tiddlers and as chat servers/relays\\n\\nA lot of the documentation is in the tiddler files in the Documentation folder\\nof the plugin, or in the wiki in the plugin information on the control panel.\\n\\n## How do I set it up?\\n\\n### Easiest Version (Bundled Application)\\n\\nTo make this more accessible to people I made it so you can download a single\\nfile and then run it and everything should work. When you run it it should even\\nopen the wiki in your default browser.\\n\\nTo do use this go here\\n(https://github.com/OokTech/TW5-BobEXE) and download the\\nfile for your system (BobLinux for linux, BobWin.exe for windows and\\nBobOSX for mac). Then run the file.\\n\\n- On windows it may ask if you want to allow node through your firewall. Say\\n  yes. If you have anti-virus software it will probably say that it is from an\\n  untrusted developer and suggest that you don't use it.\\n\\nIt will create an index wiki in the same folder where you run the file, so if\\nyou want you can copy the file somewhere else. If you want to move it after you\\nhave run it the first time just be sure to copy the `IndexWiki` folder to the\\nsame location or it will create a new one without any changes you have made.\\n\\n### Manual Version\\n\\nIf you are familiar with using tiddlywiki on node than you just need to put\\nthe plugin into your plugins folder and include it in your `tiddlywiki.info`\\nfile. For the moment this plugin must be located in the `OokTech/Bob`\\nsubfolder of your plugins folder and listed as `OokTech/Bob` in the\\n`tiddlywiki.info` file. You start the server using the `wsserver` command\\ninstead of the `server` command.\\n\\nAlso see <a href='./Configuration.md'>Configuration.md</a>.\\n\\n#### Step by step instructions (using Node)\\n\\nIf you want to use a fresh local install of tiddlywiki here are command line\\ninstructions:\\n\\nClone the tiddlywiki repo and get the plugin (Only do this the first time to\\ninstall everything):\\n```\\ngit clone --depth=1 --branch v5.1.21 https://github.com/Jermolene/TiddlyWiki5.git\\ngit clone --depth=1 https://github.com/OokTech/TW5-Bob.git TiddlyWiki5/plugins/OokTech/Bob\\nmkdir TiddlyWiki5/Wikis\\ncp -r TiddlyWiki5/plugins/OokTech/Bob/MultiUserWiki TiddlyWiki5/Wikis/BobWiki/\\n```\\n\\nAfter that is finished, and to start up tiddlywiki later type:\\n\\n```\\ncd TiddlyWiki5\\nnode ./tiddlywiki.js Wikis/BobWiki  --wsserver\\n```\\n\\nIn a browser go to `127.0.0.1:8080` and the wiki should load. From here any\\ntiddlers you create should have .tid files created in the\\n`Wikis/BobWiki/tiddlers` folder, any edits you do to those files\\nshould be immediately reflected in the browser. Open the tiddler called\\n`$:/ServerIP`, if you go to the ip address listed there on port `8080` (on mine\\nright now the tiddler says `192.168.0.15`, so I put `192.168.0.15:8080` in the\\nbrowser of another computer on the same network to access the wiki). Now any\\nchanges you make to tiddlers on one computer will be reflected almost\\nimmediately on the other, and any changes you make to tiddlers or the file\\nsystem will be almost immediately reflected in all connected wikis.\\n\\nIf you want to use the global tiddlywiki install you have to set the\\nenvironment variable `TIDDLYWIKI_PLUGIN_PATH` and `TIDDLYWIKI_EDITION_PATH` to\\nthe folder where you have your plugins. On OSX or Linux you open a terminal and\\ntype these commands:\\n\\n```\\nexport TIDDLYWIKI_PLUGIN_PATH=\\\"/path/to/your/plugins\\\"\\nexport TIDDLYWIKI_EDITION_PATH=\\\"/path/to/your/editions\\\"\\ntiddlywiki editions/BobWiki  --wsserver\\n```\\n\\nIf you want to change settings see\\n<a href='./Configuration.md'>Configuration.md</a> for information.\\n\\n#### Updating Bob on a manual install\\n\\nWhen a new version of Bob is released you can update your plugin like this.\\nIf you followed the instructions above exactly than you use this. If you\\ncloned the repo elsewhere than you need to cd into the folder where you\\ncloned the plugin.\\n\\nYou can do this to make sure you have the most recent version, running this\\ncommand when you already have the newest version does nothing and won't break\\nanything so you can try it if you are not sure without worrying.\\n\\nIn a terminal type these commands:\\n\\n```\\ncd TiddlyWiki5\\ncd plugins/OokTech/Bob\\ngit pull\\n```\\n\\n#### Updating TiddlyWiki on a manual install\\n\\nThis is to update your version of tiddlywiki, not Bob.\\n\\nWhen TiddlyWiki release a new version you need to update your TiddlyWiki\\nversion also. This assumes that you followed the above instructions exactly.\\nIf you cloned the TiddlyWiki repo somewhere else than you have to cd into that\\nfolder instead.\\n\\nIn a terminal type these commands:\\n\\n```\\ncd TiddlyWiki5\\ngit fetch --all --tags --prune\\ngit checkout tags/v5.1.21\\n```\\n\\nTo use future or previous versions you would change the `5.1.21` in the last\\ncommand to match the version number you want to use.\\n\\n### Notes\\n\\n*NOTE 1 - .meta files:* there isn't full support for .meta files. The only\\ncurrently known limitation is that when you rename either the .meta file or the\\nfile it describes the changes aren't correctly reflected in the browsers.\\nRenaming in the browser works as expected. Also empty .tid files are created\\nfor any tiddler with a `_canonical_uri` field in addition to the .meta file.\\nThis has no effect on the wiki.\\n\\n*NOTE 2 - command line arguments and configuration:*\\nI am terrible with command line arguments.\\nTo prevent the need to have 10 or 15 command line arguments in order to fully\\nconfigure a wiki I instead added a `settings` folder in the same folder that\\nholds the `tiddlers` folder and the `tiddlywiki.info` file. Inside this folder\\nthere is a `settings.json` file that you can use the configure the wiki.\\nThis also lets you change the wiki's settings from within the wiki. Most of the\\nsettings wouldn't take effect until the wiki server is reset, so I made a way\\nto reset the wiki server from inside the wiki. You can also shutdown the wiki\\nserver from inside the wiki.\\n\\n---\\n\\n## More Details\\n\\nHere is a more detailed list of things added or changed by this plugin\\n\\n- Create new wikis from an interface inside the wiki\\n  - Create wikis using editions\\n  - Create wikis from existing single html file wikis\\n  - Create wikis using tiddlers drawn from other existing wikis\\n  - Add existing node wikis so that they are served by Bob\\n- Serve normal node wikis with all the features of Bob\\n- Two-way real-time syncing between the browser and file system\\n  - Updates the wiki in the browser immediately when any changes are made to the file system\\n  - Immediately save changes to tiddlers made in the browser to the file system\\n  - Syncing can ignore tiddlers based on an editable exclude filter\\n  - If the browser is disconnected from the server it can reconnect when the server is accessible again and sync the changes that happened. The syncing is two-way so the browser gets any changes from the server and the server gets changes from the browser.\\n    - Conflicts are displayed for you to handle.\\n- Multi-User support\\n  - Allows any number of people/computers/browser tabs to connect to the wiki\\n    server and use or edit the same wiki(s) simultaneously.\\n  - Prevents multiple people from editing the same tiddler at the same time by\\n    disabling the edit button for tiddlers currently being edited\\n- Multi-Wiki support, the plugin can serve multiple wikis at once, each served\\n  wiki has all the features listed here.\\n- Websockets!! (used on the back-end, can be used by other plugins in the\\n  future)\\n  - Adds a websocket interface to tiddlywiki (currently only used by this\\n    plugin, a git plugin is currently being developed)\\n  - Adds an action widget that allows you to send arbitrary websocket messages\\n    to the server. This can be used to do things like trigger shell scripts\\n    from inside the wiki.\\n- Adds a new command `wsserver` that starts up a minimal http and websocket\\n  server used for the real-time communication between the browser and server.\\n- Adds a new command `externalserver` which starts up the wiki without a server\\n  so that you can use an external server, like an expressjs server.\\n- Allows you to shutdown the tiddlywiki server from the browser using a websocket message.\\n- Lets you run shell scripts from inside the wiki\\n- Everything is configurable from inside the wiki\\n- Your connection to the server is monitored and you are warned if there is a problem\\n  - If the browser disconnects from the server you can reconnect.\\n  - If the server was shutdown/restarted than you need to reload the page to reconnect.\\n- Serve files from the local file system (like images) so that they can be\\n  used in the wiki.\\n- Build a single file version of any served wikis from within the wiki.\\n- Share tiddlers between the wikis using the internalFetch mechanism\\n- Build single file wikis that take tiddlers from different wikis\\n- Inter-server federation\\n  - Chat (see below)\\n  - Wiki syncing\\n    - optionally using a filter to limit which tiddlers are synced\\n  - fetch/push tiddlers from/to other servers\\n- Chat\\n  - Local chat works between different wikis/connections to the same Bob server\\n  - Federated chat works between different Bob servers.\\n- Plugin library\\n  - The server can act as a plugin library for other wikis\\n  - The library can be updated by plugin authors without having to have access to the server\\n  - The library can be updated directly from github/gitlab/other git server\\n- *coming soon* Exclude lists on a per-wiki and per-user basis\\n- *under consideration* Security and authentication to limit access and editing\\n\",\n            \"type\": \"text/x-markdown\"\n        },\n        \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/RoadMap.md\": {\n            \"title\": \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/RoadMap.md\",\n            \"text\": \"# Roadmap\\n\\n- When create Bob wikis from existing single file wikis:\\n  - (maybe) determine if the plugins used in the single file are available\\n    locally as node plugins and preferentially use the node plugins\\n  - (maybe) determine if the plugins in the single file are available locally\\n    and if not create the plugin locally to make it available in the future\\n- Serve single file wikis as multi-user wikis (by cheating!)\\n  - The single file wiki will be split into a (possibly temporary) multi-user\\n    wiki and any editing can be done as a normal multi-user wiki.\\n  - Saving exports the changed wiki to overwrite the single file wiki (or save\\n    under a new name if that is what you want)\\n- If a connection isn't authenticated than serve the wiki without the Bob\\n  plugin to make it smaller.\\n- See if we can store the tiddlywiki core and Bob plugin in localstorage and\\n  then serve an html page that just has the wiki content. That could greatly\\n  reduce loading times and network traffic.\\n- Make a new function that lets you pick and choose tiddlers and plugins from\\n  any that are available.\\n- Add wiki syncing!\\n  - Sync local to remote state: make a list of all wiki tiddlers and send that\\n    to another wiki which checks that list against its own list and sends back\\n    any differences.\\n  - (Be careful with this) Sync remote to local state: make a list of all wiki\\n    tiddlers, send it to remote, remote checks it against its list and sends\\n    back a list of differences, the local then sends the differences to the\\n    remote.\\n  - Wiki diffs: same process as above, but export a json file that has all of\\n    the changes in it. This could use the same thing as the history of changed\\n    tiddlers thing.\\n  - Syncing between servers: Each server has its compact list of changes, they\\n    are exchanged and examined for conflicts, non-conflicting tiddlers are sent\\n    and any conflicts are handled like browser-server conflicts.\\n    - If there is security than the initiating server needs to get an access\\n      token from the other server.\\n      - Syncing should be pretty much the same as when a browser reconnects otherwise. The local server logs into the remote server to get a token, then sends over the changes in the syncChanges message and the remote server then sends any new things to the local server. The conflicts are handled the same way as browser-server conflicts.\\n- Add `@iarna/toml` as an external library and use toml instead of json for\\n  configuration. (this doesn't work with the sandbox)\\n\",\n            \"type\": \"text/x-markdown\"\n        },\n        \"$:/plugins/Bob/ServerRoutes/get-files.js\": {\n            \"title\": \"$:/plugins/Bob/ServerRoutes/get-files.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/Bob/ServerRoutes/get-files.js\\ntype: application/javascript\\nmodule-type: serverroute\\n\\nGET /^\\\\/files\\\\/<<filename>>/\\n\\nGET /^\\\\/<<wikiname>>\\\\/files\\\\/<<filename>>/\\n\\nReturns a media file\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.method = \\\"GET\\\";\\n\\n// Start with the same base path as the --listen command\\nlet pathRegExp = new RegExp('\\\\/files\\\\/.+');\\nif(typeof $tw.settings.fileURLPrefix === 'string' && ($tw.settings.fileURLPrefix !== '' || $tw.settings.accptance === \\\"I Will Not Get Tech Support For This\\\")) {\\n  if($tw.settings.fileURLPrefix === '') {\\n    pathRegExp = new RegExp('^/.+$');\\n  } else {\\n    pathRegExp = new RegExp('\\\\/' + $tw.settings.fileURLPrefix + '\\\\/.+$');\\n  }\\n}\\n\\nexports.path = pathRegExp;\\n\\nexports.handler = function(request,response,state) {\\n  if($tw.settings.enableFileServer === 'yes') {\\n    const filePathRoot = $tw.ServerSide.getFilePathRoot();\\n    $tw.settings.servingFiles = $tw.settings.servingFiles || {};\\n    const path = require('path');\\n    const fs = require('fs');\\n    const URL = require('url');\\n    const strippedURL = request.url.replace($tw.settings['ws-server'].pathprefix,'').replace(/^\\\\/*/, '');\\n    const wikiName = $tw.ServerSide.findName(strippedURL);\\n    // Check to see if the wiki matches the referer url, if not respond with a 403 if the setting is set\\n    let referer = {path: \\\"\\\"}\\n    try {\\n      referer = URL.parse(request.headers.referer);\\n    } catch(e) {\\n\\n    }\\n    const filePrefix = $tw.settings.fileURLPrefix?$tw.settings.fileURLPrefix:'files';\\n    if($tw.settings.perWikiFiles === 'yes'\\n      && !(request.url.startsWith(path.join(referer.path,filePrefix)) || ((wikiName === 'RootWiki' || wikiName === '') && request.url.startsWith(path.join(referer.path, 'RootWiki', filePrefix))))\\n      && !(strippedURL.startsWith(filePrefix) && (wikiName === filePrefix || wikiName === ''))) {\\n      // return 403\\n      response.writeHead(403);\\n      response.end();\\n      return;\\n    }\\n    let urlPieces = request.url.split('/');\\n    // Check to make sure that the wiki name actually matches the URL\\n    // Without this you could put in foo/bar/baz and get files from\\n    // foo/bar if there was a wiki tehre and not on foo/bar/baz and then\\n    // it would break when someone made a wiki on foo/bar/baz\\n    // If there isn't a wiki name before the file prefix the files are\\n    // available to all wikis.\\n    let ok = (strippedURL.split('/')[0] === filePrefix);\\n    if(!ok && wikiName === '') {\\n      ok = request.url.startsWith(path.join(referer.path, 'RootWiki', filePrefix));\\n    } else if(!ok && wikiName !== '') {\\n      ok = (strippedURL.split('/')[wikiName.split('/').length] === filePrefix);\\n    }\\n    let offset = 1;\\n    let secondPathPart = '';\\n    if ($tw.settings.servingFiles[urlPieces[urlPieces.indexOf(filePrefix)+1]]) {\\n      secondPathPart = $tw.settings.servingFiles[urlPieces[urlPieces.indexOf(filePrefix)+1]];\\n      offset += 1;\\n    }\\n    const filePath = decodeURIComponent(urlPieces.slice(urlPieces.indexOf(filePrefix)+offset).join('/'));\\n    const token = $tw.Bob.getCookie(request.headers.cookie, 'token');\\n    const authorised = $tw.Bob.AccessCheck(wikiName, token, 'view');\\n    if(authorised && ok) {\\n      const basePath = $tw.ServerSide.getBasePath();\\n      let pathRoot = path.resolve(basePath,filePathRoot);\\n      if(typeof wikiName === 'string' && wikiName !== '') {\\n        pathRoot = path.resolve($tw.ServerSide.getWikiPath(wikiName), 'files');\\n      }\\n      const pathname = path.resolve(pathRoot, secondPathPart, filePath);\\n      // Make sure that someone doesn't try to do something like ../../ to get to things they shouldn't get.\\n      if(pathname.startsWith(pathRoot) || pathname.startsWith(secondPathPart)) {\\n        fs.exists(pathname, function(exists) {\\n          if(!exists || fs.statSync(pathname).isDirectory()) {\\n            response.statusCode = 404;\\n            response.end();\\n          }\\n          const ext = path.parse(pathname).ext.toLowerCase();\\n          const mimeMap = $tw.settings.mimeMap || {\\n            '.aac': 'audio/aac',\\n            '.avi': 'video/x-msvideo',\\n            '.csv': 'text/csv',\\n            '.doc': 'application/msword',\\n            '.epub': 'application/epub+zip',\\n            '.gif': 'image/gif',\\n            '.html': 'text/html',\\n            '.htm': 'text/html',\\n            '.ico': 'image/x-icon',\\n            '.jpg': 'image/jpeg',\\n            '.jpeg': 'image/jpeg',\\n            '.mp3': 'audio/mpeg',\\n            '.mpeg': 'video/mpeg',\\n            '.oga': 'audio/ogg',\\n            '.ogv': 'video/ogg',\\n            '.ogx': 'application/ogg',\\n            '.pdf': 'application/pdf',\\n            '.png': 'image/png',\\n            '.svg': 'image/svg+xml',\\n            '.weba': 'audio/weba',\\n            '.webm': 'video/webm',\\n            '.wav': 'audio/wav'\\n          };\\n          // Special handling for streaming video types\\n          // ref: https://gist.github.com/paolorossi/1993068\\n          if(mimeMap[ext] || ($tw.settings.allowUnsafeMimeTypes && $tw.settings.accptance === \\\"I Will Not Get Tech Support For This\\\")) {\\n            fs.stat(pathname, function(err, stat) {\\n              if(err) {\\n                $tw.Bob.logger.error(err, {level:1})\\n                response.statusCode = 500;\\n                response.end();\\n              } else {\\n                const total = stat.size;\\n                if (request.headers['range']) {\\n                  const range = request.headers.range;\\n                  const parts = range.replace(/bytes=/, \\\"\\\").split(\\\"-\\\");\\n                  const partialstart = parts[0];\\n                  const partialend = parts[1];\\n                  const start = parseInt(partialstart, 10);\\n                  const end = partialend ? parseInt(partialend, 10) : total-1;\\n                  const chunksize = (end-start)+1;\\n                  const file = fs.createReadStream(pathname, {start: start, end: end});\\n                  response.writeHead(206, { 'Content-Range': 'bytes ' + start + '-' + end + '/' + total, 'Accept-Ranges': 'bytes', 'Content-Length': chunksize, 'Content-Type': mimeMap[ext] });\\n                  file.pipe(response);\\n                } else {\\n                  response.writeHead(200, { 'Content-Length': total, 'Content-Type': mimeMap[ext] });\\n                  fs.createReadStream(pathname).pipe(response);\\n                }\\n              }\\n            })\\n          } else {\\n            response.writeHead(403);\\n            response.end();\\n          }\\n          /*\\n          fs.readFile(pathname, function(err, data) {\\n            if(err) {\\n              $tw.Bob.logger.error(err, {level:1})\\n              response.statusCode = 500;\\n              response.end();\\n            } else {\\n              const ext = path.parse(pathname).ext.toLowerCase();\\n              const mimeMap = $tw.settings.mimeMap || {\\n                '.aac': 'audio/aac',\\n                '.avi': 'video/x-msvideo',\\n                '.csv': 'text/csv',\\n                '.doc': 'application/msword',\\n                '.epub': 'application/epub+zip',\\n                '.gif': 'image/gif',\\n                '.html': 'text/html',\\n                '.htm': 'text/html',\\n                '.ico': 'image/x-icon',\\n                '.jpg': 'image/jpeg',\\n                '.jpeg': 'image/jpeg',\\n                '.mp3': 'audio/mpeg',\\n                '.mpeg': 'video/mpeg',\\n                '.oga': 'audio/ogg',\\n                '.ogv': 'video/ogg',\\n                '.ogx': 'application/ogg',\\n                '.pdf': 'application/pdf',\\n                '.png': 'image/png',\\n                '.svg': 'image/svg+xml',\\n                '.weba': 'audio/weba',\\n                '.webm': 'video/webm',\\n                '.wav': 'audio/wav'\\n              };\\n              if(mimeMap[ext] || ($tw.settings.allowUnsafeMimeTypes && $tw.settings.accptance === \\\"I Will Not Get Tech Support For This\\\")) {\\n                response.writeHead(200, {\\\"Content-type\\\": mimeMap[ext] || \\\"text/plain\\\"});\\n                response.end(data);\\n              } else {\\n                response.writeHead(403);\\n                response.end();\\n              }\\n            }\\n          })\\n          */\\n        })\\n      }\\n    }\\n  }\\n}\\n}());\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"serverroute\"\n        },\n        \"$:/plugins/Bob/ServerRoutes/get-wiki-favicon.js\": {\n            \"title\": \"$:/plugins/Bob/ServerRoutes/get-wiki-favicon.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/Bob/ServerRoutes/get-wiki-favicon.js\\ntype: application/javascript\\nmodule-type: wikiroute\\n\\nGET /^\\\\/favicon.ico/\\n\\nReturns the favicon of the root wiki\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nmodule.exports = function(fullName) {\\n  const thePath = (!fullName || fullName === 'RootWiki' || fullName === '')?new RegExp('^\\\\/favicon.ico'):new RegExp('^\\\\/' + fullName + '\\\\/favicon.ico');\\n  return {\\n    method: \\\"GET\\\",\\n    path: thePath,\\n    handler: function(request,response,state) {\\n      const token = $tw.Bob.getCookie(request.headers.cookie, 'token');\\n      const authorised = $tw.Bob.AccessCheck('RootWiki', token, 'view');\\n      if(authorised) {\\n        // Load the wiki\\n        const exists = $tw.ServerSide.loadWiki('RootWiki');\\n        let buffer = ''\\n        if(exists) {\\n          response.writeHead(200, {\\\"Content-Type\\\": \\\"image/x-icon\\\"});\\n          if($tw.Bob.Wikis['RootWiki']) {\\n            buffer = $tw.Bob.Wikis['RootWiki'].wiki.getTiddlerText('$:/favicon.ico')\\n          }\\n        } else {\\n          buffer = \\\"\\\";\\n        }\\n        response.end(buffer,\\\"base64\\\");\\n      } else {\\n        response.writeHead(404);\\n        response.end();\\n      }\\n    }\\n  }\\n}\\n\\n}());\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"wikiroute\"\n        },\n        \"$:/plugins/Bob/ServerRoutes/get-wiki.js\": {\n            \"title\": \"$:/plugins/Bob/ServerRoutes/get-wiki.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/Bob/ServerRoutes/get-wiki.js\\ntype: application/javascript\\nmodule-type: wikiroute\\n\\nGET /^\\\\/$/\\nGET /^\\\\/<<fullname>>\\\\/?$/\\n\\nReturns a wiki\\n\\nreturn a function that takes the fullname as the input and returns the route info\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nmodule.exports = function (fullName) {\\n  const thePath = (!fullName || fullName === 'RootWiki' || fullName === '')?new RegExp('^\\\\/$'):new RegExp('^\\\\/' + fullName + '\\\\/?$');\\n  return {\\n    method: \\\"GET\\\",\\n    path: thePath,\\n    handler: function(request,response,state) {\\n      const token = $tw.Bob.getCookie(request.headers.cookie, 'token');\\n      const authorised = $tw.Bob.AccessCheck(fullName, token, 'view');\\n      let text;\\n      if(authorised) {\\n        // Make sure we have loaded the wiki tiddlers.\\n        // This does nothing if the wiki is already loaded.\\n        const exists = $tw.ServerSide.loadWiki(fullName);\\n        if(exists) {\\n          // If servePlugin is not false than we strip out the filesystem\\n          // and tiddlyweb plugins if they are there and add in the\\n          // Bob plugin.\\n          const servePlugin = ($tw.settings['ws-server'].servePlugin !== 'no') ? 'yes' : 'no';\\n          // Get the full text of the html wiki to send as the response.\\n          text = $tw.ServerSide.prepareWiki(fullName, servePlugin);\\n        } else {\\n          text = \\\"<html><p>No wiki found! Either there is no usable tiddlywiki.info file in the listed location or it isn't listed.</p></html>\\\"\\n        }\\n\\n        response.writeHead(200, {\\\"Content-Type\\\": state.server.get(\\\"serveType\\\")});\\n        response.end(text,\\\"utf8\\\");\\n      }\\n    }\\n  }\\n}\\n\\n}());\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"wikiroute\"\n        },\n        \"$:/plugins/Bob/ServerRoutes/post-fetch-list.js\": {\n            \"title\": \"$:/plugins/Bob/ServerRoutes/post-fetch-list.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/Bob/ServerRoutes/post-fetch-list.js\\ntype: application/javascript\\nmodule-type: serverroute\\n\\nPOST /^\\\\/api\\\\/fetch\\\\/list/\\n\\nfetch a list of tiddlers returned by a filter\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.method = \\\"POST\\\";\\n\\nexports.path = new RegExp('^\\\\/api\\\\/fetch\\\\/list');\\n\\nexports.handler = function(request,response,state) {\\n  if($tw.settings.API.enableFetch === 'yes') {\\n    let body = '';\\n    let list;\\n    let data = {\\\"list\\\":[],\\\"info\\\":{}};\\n    //response.setHeader('Access-Control-Allow-Origin', '*')\\n    response.writeHead(200, {\\\"Content-Type\\\": \\\"application/json\\\", \\\"Access-Control-Allow-Origin\\\": \\\"*\\\"});\\n    request.on('data', function(chunk){\\n      body += chunk;\\n      // We limit this to 1mb, it should never be anywhere near that\\n      // big\\n      if(body.length > 1e6) {\\n        response.writeHead(413, {'Content-Type': 'text/plain'}).end();\\n        request.connection.destroy();\\n      }\\n    });\\n    request.on('end', function() {\\n      body = body.replace(/^message=/, '');\\n      try {\\n        const bodyData = JSON.parse(body);\\n        if(bodyData.filter && bodyData.fromWiki) {\\n          // Make sure that the person has access to the wiki\\n          const token = $tw.Bob.getCookie(request.headers.cookie, 'token');\\n          const authorised = $tw.Bob.AccessCheck(bodyData.fromWiki, token, 'view');\\n          if(authorised) {\\n            // Make sure that the wiki is listed\\n            if($tw.settings.wikis[bodyData.fromWiki] || bodyData.fromWiki === 'RootWiki') {\\n              // Make a temp wiki to run the filter on\\n              let tempWiki = new $tw.Wiki();\\n              // If the wiki isn't loaded than load it\\n              if(!$tw.Bob.Wikis[bodyData.fromWiki]) {\\n                $tw.ServerSide.loadWiki(bodyData.fromWiki);\\n              } else if($tw.Bob.Wikis[bodyData.fromWiki].State !== 'loaded') {\\n                $tw.ServerSide.loadWiki(bodyData.fromWiki);\\n              }\\n              // Make sure that the wiki exists and is loaded\\n              if($tw.Bob.Wikis[bodyData.fromWiki]) {\\n                if($tw.Bob.Wikis[bodyData.fromWiki].State === 'loaded') {\\n                  // Use the filter\\n                  list = $tw.Bob.Wikis[bodyData.fromWiki].filterTiddlers(bodyData.filter);\\n                }\\n              }\\n              let tiddlers = {};\\n              let info = {};\\n              list.forEach(function(title) {\\n                const tempTid = $tw.Bob.Wikis[bodyData.fromWiki].getTiddler(title);\\n                info[title] = {};\\n                if(bodyData.fieldList) {\\n                  bodyData.fieldList.split(' ').forEach(function(field) {\\n                    info[title][field] = tempTid.fields[field];\\n                  })\\n                } else {\\n                  info[title]['modified'] = tempTid.fields.modified;\\n                }\\n              })\\n              data = {list: list, info: info};\\n            }\\n          }\\n          // Send the info\\n          data = JSON.stringify(data) || '{\\\"list\\\":[],\\\"info\\\":{}}';\\n          response.end(data);\\n        }\\n      } catch (e) {\\n        data = JSON.stringify(data) || '{\\\"list\\\":[],\\\"info\\\":{}}';\\n        response.end(data);\\n      }\\n    })\\n  }\\n}\\n}());\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"serverroute\"\n        },\n        \"$:/plugins/Bob/ServerRoutes/post-fetch-plugin.js\": {\n            \"title\": \"$:/plugins/Bob/ServerRoutes/post-fetch-plugin.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/Bob/ServerRoutes/post-fetch-plugin.js\\ntype: application/javascript\\nmodule-type: serverroute\\n\\nGET /^\\\\/api\\\\/plugins\\\\/fetch\\\\/.+$/\\n\\nFetch a plugin\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.method = \\\"POST\\\";\\n\\nexports.path = new RegExp('^\\\\/api\\\\/plugins\\\\/fetch\\\\/.+&');\\n\\nexports.handler = function(request,response,state) {\\n  $tw.settings.API = $tw.settings.API || {};\\n  if($tw.settings.API.pluginLibrary === 'yes') {\\n    const getPlugin = function (request) {\\n      const urlParts = request.url.split('/')\\n      if(typeof $tw.settings.pluginsPath === 'string') {\\n        const basePath = $tw.ServerSide.getBasePath();\\n        const pluginsPath = path.resolve(basePath, $tw.settings.pluginsPath)\\n        const pluginPath = path.resolve(pluginsPath, urlParts[urlParts.length-2], urlParts[urlParts.length-1])\\n        if(fs.statSync(pluginPath).isDirectory()) {\\n          const pluginFields = $tw.loadPluginFolder(pluginPath)\\n          return pluginFields\\n        }\\n      }\\n      return false\\n    }\\n    const token = $tw.Bob.getCookie(request.headers.cookie, 'token');\\n    const authorised = $tw.Bob.AccessCheck(\\\"RootWiki\\\", token, 'fetchPlugin');\\n    if(authorised) {\\n      const plugin = getPlugin(request)\\n      if(plugin) {\\n        response.writeHead(200, {\\\"Access-Control-Allow-Origin\\\":\\\"*\\\"})\\n        response.end(JSON.stringify(plugin))\\n      } else {\\n        response.writeHead(403)\\n        response.end()\\n      }\\n    } else {\\n      response.writeHead(403)\\n      response.end()\\n    }\\n  }\\n};\\n\\n}());\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"serverroute\"\n        },\n        \"$:/plugins/Bob/ServerRoutes/post-fetch.js\": {\n            \"title\": \"$:/plugins/Bob/ServerRoutes/post-fetch.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/Bob/ServerRoutes/post-fetch.js\\ntype: application/javascript\\nmodule-type: serverroute\\n\\nPOST /^\\\\/api\\\\/fetch/\\n\\nfetch tiddlers\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.method = \\\"POST\\\";\\n\\nexports.path = new RegExp('^\\\\/api\\\\/fetch');\\n\\nexports.handler = function(request,response,state) {\\n  if($tw.settings.API.enableFetch === 'yes') {\\n    let body = ''\\n    let list = []\\n    let data = {}\\n    //response.setHeader('Access-Control-Allow-Origin', '*')\\n    response.writeHead(200, {\\\"Content-Type\\\": \\\"application/json\\\", \\\"Access-Control-Allow-Origin\\\": \\\"*\\\"})\\n    request.on('data', function(chunk){\\n      body += chunk;\\n      // We limit this to 1mb, it should never be anywhere near that\\n      // big\\n      if(body.length > 1e6) {\\n        response.writeHead(413, {'Content-Type': 'text/plain'}).end();\\n        request.connection.destroy();\\n      }\\n    });\\n    request.on('end', function() {\\n      body = body.replace(/^message=/, '')\\n      try {\\n        const bodyData = JSON.parse(body)\\n        if(bodyData.filter && bodyData.fromWiki) {\\n          // Make sure that the person has access to the wiki\\n          const token = $tw.Bob.getCookie(request.headers.cookie, 'token');\\n          const authorised = $tw.Bob.AccessCheck(bodyData.fromWiki, token, 'view');\\n          if(authorised) {\\n            // Make sure that the wiki is listed\\n            if($tw.settings.wikis[bodyData.fromWiki] || bodyData.fromWiki === 'RootWiki') {\\n              // If the wiki isn't loaded than load it\\n              if(!$tw.Bob.Wikis[bodyData.fromWiki]) {\\n                $tw.ServerSide.loadWiki(bodyData.fromWiki);\\n              } else if($tw.Bob.Wikis[bodyData.fromWiki].State !== 'loaded') {\\n                $tw.ServerSide.loadWiki(bodyData.fromWiki);\\n              }\\n              // Make sure that the wiki exists and is loaded\\n              if($tw.Bob.Wikis[bodyData.fromWiki]) {\\n                if($tw.Bob.Wikis[bodyData.fromWiki].State === 'loaded') {\\n                  list = $tw.Bob.Wikis[bodyData.fromWiki].wiki.filterTiddlers(bodyData.filter);\\n                }\\n              }\\n            }\\n          }\\n          let tiddlers = {};\\n          let info = {};\\n          list.forEach(function(title) {\\n            const tempTid = $tw.Bob.Wikis[bodyData.fromWiki].wiki.getTiddler(title);\\n            tiddlers[title] = tempTid;\\n            info[title] = {};\\n            if(bodyData.fieldList) {\\n              bodyData.fieldList.split(' ').forEach(function(field) {\\n                info[title][field] = tempTid.fields[field];\\n              })\\n            } else {\\n              info[title]['modified'] = tempTid.fields.modified;\\n            }\\n          })\\n          // Send the tiddlers\\n          data = {list: list, tiddlers: tiddlers, info: info};\\n          data = JSON.stringify(data) || \\\"\\\";\\n          response.end(data);\\n        }\\n      } catch (e) {\\n        data = JSON.stringify(data) || \\\"\\\";\\n        response.end(data);\\n      }\\n    })\\n  }\\n}\\n}());\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"serverroute\"\n        },\n        \"$:/plugins/Bob/ServerRoutes/post-plugin-list.js\": {\n            \"title\": \"$:/plugins/Bob/ServerRoutes/post-plugin-list.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/Bob/ServerRoutes/post-plugin-list.js\\ntype: application/javascript\\nmodule-type: serverroute\\n\\nGET /^\\\\/api\\\\/plugins\\\\/list/\\n\\nfetch a list of available plugins\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.method = \\\"POST\\\";\\n\\nexports.path = new RegExp('^\\\\/api\\\\/plugins\\\\/list');\\n\\nexports.handler = function(request,response,state) {\\n  $tw.settings.API = $tw.settings.API || {};\\n  if($tw.settings.API.pluginLibrary === 'yes') {\\n    const getPluginList = function () {\\n      let pluginList = []\\n      if(typeof $tw.settings.pluginsPath === 'string') {\\n        const basePath = $tw.ServerSide.getBasePath();\\n        const pluginsPath = path.resolve(basePath, $tw.settings.pluginsPath)\\n        if(fs.existsSync(pluginsPath)) {\\n          try {\\n            const pluginAuthors = fs.readdirSync(pluginsPath)\\n            pluginAuthors.forEach(function (author) {\\n              const pluginAuthorPath = path.join(pluginsPath, './', author)\\n              if(fs.statSync(pluginAuthorPath).isDirectory()) {\\n                const pluginAuthorFolders = fs.readdirSync(pluginAuthorPath)\\n                for(let t=0; t<pluginAuthorFolders.length; t++) {\\n                  const fullPluginFolder = path.join(pluginAuthorPath,pluginAuthorFolders[t])\\n                  const pluginFields = $tw.loadPluginFolder(fullPluginFolder)\\n                  if(pluginFields) {\\n                    let readme = \\\"\\\"\\n                    let readmeText = ''\\n                    try {\\n                      // Try pulling out the plugin readme\\n                      const pluginJSON = JSON.parse(pluginFields.text).tiddlers\\n                      readme = pluginJSON[Object.keys(pluginJSON).filter(function(title) {\\n                        return title.toLowerCase().endsWith('/readme')\\n                      })[0]]\\n                    } catch (e) {\\n                      $tw.Bob.logger.error('Error parsing plugin', e, {level:1})\\n                    }\\n                    if(readme) {\\n                      readmeText = readme.text\\n                    }\\n                    const nameParts = pluginFields.title.split('/')\\n                    const name = nameParts[nameParts.length-2] + '/' + nameParts[nameParts.length-1]\\n                    const listInfo = {\\n                      name: name,\\n                      description: pluginFields.description,\\n                      tiddlerName: pluginFields.title,\\n                      version: pluginFields.version,\\n                      author: pluginFields.author,\\n                      readme: readmeText\\n                    }\\n                    pluginList.push(listInfo)\\n                  }\\n                }\\n              }\\n            })\\n          } catch (e) {\\n            $tw.Bob.logger.error('Problem loading plugin', e, {level:1})\\n          }\\n        }\\n      }\\n      return pluginList\\n    }\\n    const token = $tw.Bob.getCookie(request.headers.cookie, 'token');\\n    const authorised = $tw.Bob.AccessCheck(\\\"RootWiki\\\", token, 'list');\\n    if(authorised) {\\n      const pluginList = getPluginList()\\n      //response.setHeader('Access-Control-Allow-Origin', '*')\\n      response.writeHead(200, {\\\"Access-Control-Allow-Origin\\\": \\\"*\\\"})\\n      response.end(JSON.stringify(pluginList))\\n    } else {\\n      response.writeHead(403)\\n      response.end()\\n    }\\n  }\\n};\\n\\n}());\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"serverroute\"\n        },\n        \"$:/plugins/Bob/ServerRoutes/post-push.js\": {\n            \"title\": \"$:/plugins/Bob/ServerRoutes/post-push.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/Bob/ServerRoutes/post-push.js\\ntype: application/javascript\\nmodule-type: serverroute\\n\\nPOST /^\\\\/api\\\\/push/\\n\\nPush tiddlers to the server\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.method = \\\"POST\\\";\\n\\nexports.path = new RegExp('^\\\\/api\\\\/push');\\n\\nexports.handler = function(request,response,state) {\\n  $tw.settings.API = $tw.settings.API || {};\\n  if ($tw.settings.API.enablePush === 'yes') {\\n    let body = ''\\n    request.on('data', function(chunk){\\n      body += chunk;\\n      // We limit the size of a push to 5mb for now.\\n      if(body.length > 5e6) {\\n        response.writeHead(413, {'Content-Type': 'text/plain'}).end();\\n        request.connection.destroy();\\n      }\\n    });\\n    request.on('end', function() {\\n      try {\\n        let bodyData = JSON.parse(body)\\n        // Make sure that the token sent here matches the https header\\n        // and that the token has push access to the toWiki\\n        const token = $tw.Bob.getCookie(request.headers.cookie, 'token');\\n        const authorised = $tw.Bob.AccessCheck(bodyData.toWiki, token, 'push');\\n        if(authorised) {\\n          if($tw.settings.wikis[bodyData.toWiki] || bodyData.toWiki === 'RootWiki') {\\n            $tw.ServerSide.loadWiki(bodyData.toWiki);\\n            // Make sure that the wiki exists and is loaded\\n            if($tw.Bob.Wikis[bodyData.toWiki]) {\\n              if($tw.Bob.Wikis[bodyData.toWiki].State === 'loaded') {\\n                if(bodyData.tiddlers && bodyData.toWiki) {\\n                  Object.keys(bodyData.tiddlers).forEach(function(title) {\\n                    bodyData.tiddlers[title].fields.modified = $tw.utils.stringifyDate(new Date(bodyData.tiddlers[title].fields.modified));\\n                    bodyData.tiddlers[title].fields.created = $tw.utils.stringifyDate(new Date(bodyData.tiddlers[title].fields.created));\\n                    $tw.syncadaptor.saveTiddler(bodyData.tiddlers[title], bodyData.toWiki);\\n                  });\\n                  response.writeHead(200)\\n                  response.end()\\n                }\\n              }\\n            }\\n          }\\n        } else {\\n          response.writeHead(400)\\n          response.end()\\n        }\\n      } catch (e) {\\n        response.writeHead(400)\\n        response.end()\\n      }\\n    })\\n  }\\n};\\n\\n}());\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"serverroute\"\n        },\n        \"$:/plugins/Bob/ServerRoutes/post-upload.js\": {\n            \"title\": \"$:/plugins/Bob/ServerRoutes/post-upload.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/Bob/ServerRoutes/post-upload.js\\ntype: application/javascript\\nmodule-type: serverroute\\n\\nPOST /^\\\\/api\\\\/upload/\\n\\nUpload media\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.method = \\\"POST\\\";\\n\\nexports.path = new RegExp('^\\\\/api\\\\/upload');\\n\\nexports.handler = function(request,response,state) {\\n  const fs = require('fs')\\n  const path = require('path')\\n  const buffer = require('buffer')\\n  $tw.settings.API = $tw.settings.API || {};\\n  let body = ''\\n  request.on('data', function(chunk){\\n    body += chunk;\\n    // We limit the size of an upload to 10mb for now.\\n    if(body.length > 10e6) {\\n      response.writeHead(413, {'Content-Type': 'text/plain'}).end();\\n      request.connection.destroy();\\n    }\\n  });\\n  request.on('end', function() {\\n    try {\\n      let bodyData = JSON.parse(body)\\n      // Make sure that the token sent here matches the https header\\n      // and that the token has upload access to the toWiki\\n      const token = $tw.Bob.getCookie(request.headers.cookie, 'token');\\n      const authorised = $tw.Bob.AccessCheck(bodyData.wiki, token, 'upload');\\n      if(authorised) {\\n        const filesPath = path.resolve($tw.ServerSide.getWikiPath(bodyData.wiki), 'files');\\n        $tw.utils.createDirectory(filesPath);\\n        const buf = Buffer.from(bodyData.tiddler.fields.text,'base64');\\n        fs.writeFile(path.join(filesPath, bodyData.tiddler.fields.title), buf, function(error) {\\n          if (error) {\\n            $tw.Bob.logger.error(error, {level: 2});\\n          } else {\\n            $tw.Bob.logger.log(\\\"File saved on server: \\\", bodyData.tiddler.fields.title, {level: 3});\\n            // Send browser message letting the person know that the file has been uploaded.\\n            return true;\\n          }\\n        });\\n      } else {\\n        response.writeHead(400);\\n        response.end();\\n      }\\n    } catch (e) {\\n      $tw.Bob.logger.error('Error parsing uploaded file', e, {'level': 2});\\n      response.writeHead(400);\\n      response.end();\\n    }\\n  })\\n};\\n\\n}());\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"serverroute\"\n        },\n        \"$:/plugins/OokTech/Bob/ServerSide.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/ServerSide.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/ServerSide.js\\ntype: application/javascript\\nmodule-type: library\\n\\nThis is server functions that can be shared between different server types\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\n\\nlet ServerSide = {};\\n\\nconst path = require('path');\\nconst fs = require('fs');\\nconst os = require('os');\\n\\n// A polyfilL to make this work with older node installs\\n\\n\\n// START POLYFILL\\nconst reduce = Function.bind.call(Function.call, Array.prototype.reduce);\\nconst isEnumerable = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable);\\nconst concat = Function.bind.call(Function.call, Array.prototype.concat);\\nconst keys = Reflect.ownKeys;\\n\\nif(!Object.values) {\\n  Object.values = function values(O) {\\n    return reduce(keys(O), (v, k) => concat(v, typeof k === 'string' && isEnumerable(O, k) ? [O[k]] : []), []);\\n  };\\n}\\n\\nif(!Object.entries) {\\n  Object.entries = function entries(O) {\\n    return reduce(keys(O), (e, k) => concat(e, typeof k === 'string' && isEnumerable(O, k) ? [[k, O[k]]] : []), []);\\n  };\\n}\\n// END POLYFILL\\n\\n// Make sure that $tw.settings is available.\\nconst settings = require('$:/plugins/OokTech/NodeSettings/NodeSettings.js')\\n\\n$tw.Bob = $tw.Bob || {};\\n$tw.Bob.Files = $tw.Bob.Files || {};\\n\\n/*\\n  Return the resolved filePathRoot\\n*/\\nServerSide.getFilePathRoot= function() {\\n  let basePath = '';\\n  $tw.settings.filePathRoot = $tw.settings.filePathRoot || './files';\\n  if($tw.settings.filePathRoot === 'cwd') {\\n    basePath = path.parse(process.argv[0]).name === 'node' ? path.dirname(process.argv[0]) : process.cwd();\\n  } else if($tw.settings.filePathRoot === 'homedir') {\\n    basePath = os.homedir();\\n  } else {\\n    basePath = path.resolve($tw.settings.filePathRoot);\\n  }\\n  return basePath;\\n}\\n\\n/*\\n  Return the resolved basePath\\n*/\\nServerSide.getBasePath = function() {\\n  let basePath = '';\\n  $tw.settings.wikiPathBase = $tw.settings.wikiPathBase || 'cwd';\\n  if($tw.settings.wikiPathBase === 'homedir') {\\n    basePath = os.homedir();\\n  } else if($tw.settings.wikiPathBase === 'cwd' || !$tw.settings.wikiPathBase) {\\n    //basePath = path.parse(process.argv[0]).name === 'node' ? path.dirname(process.argv[0]) : process.cwd();\\n    basePath = process.cwd();\\n  } else {\\n    basePath = path.resolve($tw.settings.wikiPathBase);\\n  }\\n  return basePath;\\n}\\n\\n/*\\n  Given a wiki name this generates the path for the wiki.\\n*/\\nServerSide.generateWikiPath = function(wikiName) {\\n  const basePath = $tw.ServerSide.getBasePath();\\n  $tw.settings.wikisPath = $tw.settings.wikisPath || './Wikis';\\n  return path.resolve(basePath, $tw.settings.wikisPath, wikiName);\\n}\\n\\n/*\\n  Given a wiki name this gets the wiki path if one is listed, if the wiki isn't\\n  listed this returns undefined.\\n  This can be used to determine if a wiki is listed or not.\\n*/\\nServerSide.getWikiPath = function(wikiName) {\\n  let wikiPath = undefined;\\n  if(wikiName === 'RootWiki') {\\n    wikiPath = path.resolve($tw.boot.wikiPath);\\n  } else if(wikiName.indexOf('/') === -1 && $tw.settings.wikis[wikiName]) {\\n    if(typeof $tw.settings.wikis[wikiName] === 'string') {\\n      wikiPath = $tw.settings.wikis[wikiName];\\n    } else if(typeof $tw.settings.wikis[wikiName].__path === 'string') {\\n      wikiPath = $tw.settings.wikis[wikiName].__path;\\n    }\\n  } else {\\n    const parts = wikiName.split('/');\\n    let obj = $tw.settings.wikis;\\n    for (let i = 0; i < parts.length; i++) {\\n      if(obj[parts[i]]) {\\n        if(i === parts.length - 1) {\\n          if(typeof obj[parts[i]] === 'string') {\\n            wikiPath = obj[parts[i]];\\n          } else if(typeof obj[parts[i]] === 'object') {\\n            if(typeof obj[parts[i]].__path === 'string') {\\n              wikiPath = obj[parts[i]].__path;\\n            }\\n          }\\n        } else {\\n          obj = obj[parts[i]];\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  // If the wikiPath exists convert it to an absolute path\\n  if(typeof wikiPath !== 'undefined') {\\n    $tw.settings.wikisPath = $tw.settings.wikisPath || './Wikis';\\n    const basePath = $tw.ServerSide.getBasePath()\\n    wikiPath = path.resolve(basePath, $tw.settings.wikisPath, wikiPath);\\n  }\\n  return wikiPath;\\n}\\n\\n/*\\n  This checks to make sure there is a tiddlwiki.info file in a wiki folder\\n*/\\nServerSide.wikiExists = function (wikiFolder) {\\n  let exists = false;\\n  // Make sure that the wiki actually exists\\n  if(wikiFolder) {\\n    $tw.settings.wikisPath = $tw.settings.wikisPath || './Wikis'\\n    const basePath = $tw.ServerSide.getBasePath()\\n    // This is a bit hacky to get around problems with loading the root wiki\\n    // This tests if the wiki is the root wiki and ignores the other pathing\\n    // bits\\n    if(wikiFolder === $tw.boot.wikiPath) {\\n      wikiFolder = path.resolve($tw.boot.wikiPath)\\n    } else {\\n      // Get the correct path to the tiddlywiki.info file\\n      wikiFolder = path.resolve(basePath, $tw.settings.wikisPath, wikiFolder);\\n      // Make sure it exists\\n    }\\n    exists = fs.existsSync(path.resolve(wikiFolder, 'tiddlywiki.info'));\\n  }\\n  return exists;\\n}\\n\\n/*\\n  This checks to make sure that a wiki exists\\n*/\\nServerSide.existsListed = function (wikiName) {\\n  if(typeof wikiName !== 'string') {\\n    return false;\\n  }\\n  let exists = false;\\n  // First make sure that the wiki is listed\\n  const wikiPath = ServerSide.getWikiPath(wikiName);\\n  // Make sure that the wiki actually exists\\n  exists = ServerSide.wikiExists(wikiPath);\\n  if(exists) {\\n    return wikiPath;\\n  } else {\\n    return exists;\\n  }\\n}\\n\\n/*\\n  This function loads a wiki that has a route listed.\\n*/\\nServerSide.loadWiki = function (wikiName, cb) {\\n  const wikiFolder = ServerSide.existsListed(wikiName);\\n  // Add tiddlers to the node process\\n  if(wikiFolder) {\\n    $tw.settings['ws-server'] = $tw.settings['ws-server'] || {}\\n    $tw.Bob = $tw.Bob || {};\\n    $tw.Bob.Wikis = $tw.Bob.Wikis || {};\\n    $tw.Bob.Wikis[wikiName] = $tw.Bob.Wikis[wikiName] || {};\\n    $tw.Bob.Files[wikiName] = $tw.Bob.Files[wikiName] || {};\\n    $tw.Bob.EditingTiddlers[wikiName] = $tw.Bob.EditingTiddlers[wikiName] || {};\\n    // Make sure it isn't loaded already\\n    if($tw.Bob.Wikis[wikiName].State !== 'loaded') {\\n      // If the wiki isn't loaded yet set the wiki as loaded\\n      $tw.Bob.Wikis[wikiName].State = 'loaded';\\n      // Save the wiki path and tiddlers path\\n      $tw.Bob.Wikis[wikiName].wikiPath = wikiFolder;\\n      $tw.Bob.Wikis[wikiName].wikiTiddlersPath = path.resolve(wikiFolder, 'tiddlers');\\n      // Make sure that the tiddlers folder exists\\n      const error = $tw.utils.createDirectory($tw.Bob.Wikis[wikiName].wikiTiddlersPath);\\n      // Recursively build the folder tree structure\\n      $tw.Bob.Wikis[wikiName].FolderTree = buildTree('.', $tw.Bob.Wikis[wikiName].wikiTiddlersPath, {});\\n\\n      if ($tw.settings.disableFileWatchers !== 'yes') {\\n        // Watch the root tiddlers folder for chanegs\\n        $tw.Bob.WatchAllFolders($tw.Bob.Wikis[wikiName].FolderTree, wikiName);\\n      }\\n\\n      // Add tiddlers to the node process\\n      // Create a wiki object for this wiki\\n      $tw.Bob.Wikis[wikiName].wiki = new $tw.Wiki();\\n      // Load the boot tiddlers\\n      $tw.utils.each($tw.loadTiddlersFromPath($tw.boot.bootPath),function(tiddlerFile) {\\n        $tw.Bob.Wikis[wikiName].wiki.addTiddlers(tiddlerFile.tiddlers);\\n      });\\n      // Load the core tiddlers\\n      if(!$tw.Bob.Wikis[wikiName].wiki.getTiddler('$:/core')) {\\n        $tw.Bob.Wikis[wikiName].wiki.addTiddler($tw.loadPluginFolder($tw.boot.corePath));\\n      }\\n      // Add tiddlers to the wiki\\n      const wikiInfo = loadWikiTiddlers($tw.Bob.Wikis[wikiName].wikiPath, {prefix: wikiName});\\n      $tw.Bob.Wikis[wikiName].wiki.registerPluginTiddlers(\\\"plugin\\\",$tw.safeMode ? [\\\"$:/core\\\"] : undefined);\\n      // Unpack plugin tiddlers\\n      $tw.Bob.Wikis[wikiName].wiki.readPluginInfo();\\n      $tw.Bob.Wikis[wikiName].wiki.unpackPluginTiddlers();\\n\\n\\n      // Add plugins, themes and languages\\n      loadPlugins(wikiInfo.plugins,$tw.config.pluginsPath,$tw.config.pluginsEnvVar, wikiName);\\n      loadPlugins(wikiInfo.themes,$tw.config.themesPath,$tw.config.themesEnvVar, wikiName);\\n      loadPlugins(wikiInfo.languages,$tw.config.languagesPath,$tw.config.languagesEnvVar, wikiName);\\n      // Get the list of tiddlers for this wiki\\n      $tw.Bob.Wikis[wikiName].tiddlers = $tw.Bob.Wikis[wikiName].wiki.allTitles();\\n      $tw.Bob.Wikis[wikiName].plugins = wikiInfo.plugins.map(function(name) {\\n        return '$:/plugins/' + name;\\n      });\\n      $tw.Bob.Wikis[wikiName].themes = wikiInfo.themes.map(function(name) {\\n        return '$:/themes/' + name;\\n      });\\n      $tw.hooks.invokeHook('wiki-loaded', wikiName);\\n    }\\n    const fields = {\\n      title: '$:/WikiName',\\n      text: wikiName\\n    };\\n    $tw.Bob.Wikis[wikiName].wiki.addTiddler(new $tw.Tiddler(fields));\\n    if(typeof cb === 'function') {\\n      setTimeout(cb, 1000)\\n    }\\n  }\\n  return wikiFolder;\\n}\\n\\n/*\\npath: path of wiki directory\\noptions:\\n  parentPaths: array of parent paths that we mustn't recurse into\\n  readOnly: true if the tiddler file paths should not be retained\\n*/\\nfunction loadWikiTiddlers(wikiPath,options) {\\n  options = options || {};\\n  options.prefix = options.prefix || '';\\n  const parentPaths = options.parentPaths || [];\\n  const wikiInfoPath = path.resolve(wikiPath,$tw.config.wikiInfo);\\n  let wikiInfo;\\n  let pluginFields;\\n  // Bail if we don't have a wiki info file\\n  if(fs.existsSync(wikiInfoPath)) {\\n    try {\\n      wikiInfo = JSON.parse(fs.readFileSync(wikiInfoPath,\\\"utf8\\\"));\\n    } catch (e) {\\n      $tw.Bob.logger.error('Error reading wiki info', e, {level:1});\\n    }\\n  } else {\\n    return null;\\n  }\\n  // Load any parent wikis\\n  if(wikiInfo.includeWikis) {\\n    $tw.Bob.logger.error('Bob error: includeWikis is not supported yet!', {level:1});\\n    /*\\n    parentPaths = parentPaths.slice(0);\\n    parentPaths.push(wikiPath);\\n    $tw.utils.each(wikiInfo.includeWikis,function(info) {\\n      if(typeof info === \\\"string\\\") {\\n        info = {path: info};\\n      }\\n      var resolvedIncludedWikiPath = path.resolve(wikiPath,info.path);\\n      if(parentPaths.indexOf(resolvedIncludedWikiPath) === -1) {\\n        var subWikiInfo = loadWikiTiddlers(resolvedIncludedWikiPath,{\\n          parentPaths: parentPaths,\\n          readOnly: info[\\\"read-only\\\"]\\n        });\\n        // Merge the build targets\\n        wikiInfo.build = $tw.utils.extend([],subWikiInfo.build,wikiInfo.build);\\n      } else {\\n        $tw.utils.error(\\\"Cannot recursively include wiki \\\" + resolvedIncludedWikiPath);\\n      }\\n    });\\n    */\\n  }\\n  // Load any plugins, themes and languages listed in the wiki info file\\n  loadPlugins(wikiInfo.plugins,$tw.config.pluginsPath,$tw.config.pluginsEnvVar, options.prefix);\\n  loadPlugins(wikiInfo.themes,$tw.config.themesPath,$tw.config.themesEnvVar, options.prefix);\\n  loadPlugins(wikiInfo.languages,$tw.config.languagesPath,$tw.config.languagesEnvVar, options.prefix);\\n  // Load the wiki files, registering them as writable\\n  const resolvedWikiPath = path.resolve(wikiPath,$tw.config.wikiTiddlersSubDir);\\n  function getTheseTiddlers() {\\n    let out = [];\\n    try {\\n      out = $tw.loadTiddlersFromPath(resolvedWikiPath);\\n    } catch(e) {\\n      $tw.Bob.logger.error(e, {level:1});\\n    }\\n    return out;\\n  }\\n  $tw.utils.each(\\n    getTheseTiddlers(), function(tiddlerFile) {\\n      let use = true;\\n      if(!options.readOnly && tiddlerFile.filepath) {\\n        $tw.utils.each(tiddlerFile.tiddlers,function(tiddler) {\\n          $tw.Bob.Files[options.prefix][tiddler.title] = {\\n            filepath: tiddlerFile.filepath,\\n            type: tiddlerFile.type,\\n            hasMetaFile: tiddlerFile.hasMetaFile\\n          };\\n          if(['$:/plugins/tiddlywiki/tiddlyweb', '$:/plugins/tiddlywiki/filesystem'].indexOf(tiddler.title) !== -1) {\\n            use = false;\\n          }\\n        });\\n      }\\n      if(use) {\\n        $tw.Bob.Wikis[options.prefix].wiki.addTiddlers(tiddlerFile.tiddlers);\\n      }\\n    }\\n  );\\n  // Save the original tiddler file locations if requested\\n  const config = wikiInfo.config || {};\\n  if(config[\\\"retain-original-tiddler-path\\\"]) {\\n    let output = {};\\n    for(let title in $tw.Bob.Files[options.prefix]) {\\n      output[title] = path.relative(resolvedWikiPath,$tw.Bob.Files[options.prefix][title].filepath);\\n    }\\n    $tw.Bob.Wikis[options.prefix].wiki.addTiddlers(new $tw.Tiddler({title: \\\"$:/config/OriginalTiddlerPaths\\\", type: \\\"application/json\\\", text: JSON.stringify(output)}));\\n  }\\n  // Save the path to the tiddlers folder for the filesystemadaptor\\n  $tw.Bob.Wikis = $tw.Bob.Wikis || {};\\n  $tw.Bob.Wikis[options.prefix] = $tw.Bob.Wikis[options.prefix] || {};\\n  $tw.Bob.Wikis[options.prefix].wikiTiddlersPath = path.resolve(wikiPath, config[\\\"default-tiddler-location\\\"] || $tw.config.wikiTiddlersSubDir);\\n  // Load any plugins within the wiki folder\\n  const wikiPluginsPath = path.resolve(wikiPath,$tw.config.wikiPluginsSubDir);\\n  if(fs.existsSync(wikiPluginsPath)) {\\n    try {\\n      const pluginFolders = fs.readdirSync(wikiPluginsPath);\\n      for(let t=0; t<pluginFolders.length; t++) {\\n        pluginFields = $tw.loadPluginFolder(path.resolve(wikiPluginsPath,\\\"./\\\" + pluginFolders[t]));\\n        if(pluginFields) {\\n          $tw.Bob.Wikis[options.prefix].wiki.addTiddler(pluginFields);\\n        }\\n      }\\n    } catch (e) {\\n      $tw.Bob.logger.error('error loading plugin folder', e, {level:2});\\n    }\\n  }\\n  // Load any themes within the wiki folder\\n  const wikiThemesPath = path.resolve(wikiPath,$tw.config.wikiThemesSubDir);\\n  if(fs.existsSync(wikiThemesPath)) {\\n    try {\\n      const themeFolders = fs.readdirSync(wikiThemesPath);\\n      for(let t=0; t<themeFolders.length; t++) {\\n        pluginFields = $tw.loadPluginFolder(path.resolve(wikiThemesPath,\\\"./\\\" + themeFolders[t]));\\n        if(pluginFields) {\\n          $tw.Bob.Wikis[options.prefix].wiki.addTiddler(pluginFields);\\n        }\\n      }\\n    } catch (e) {\\n      $tw.Bob.logger.error('error loading theme folder', e, {level:2});\\n    }\\n  }\\n  // Load any languages within the wiki folder\\n  const wikiLanguagesPath = path.resolve(wikiPath,$tw.config.wikiLanguagesSubDir);\\n  if(fs.existsSync(wikiLanguagesPath)) {\\n    try {\\n      const languageFolders = fs.readdirSync(wikiLanguagesPath);\\n      for(let t=0; t<languageFolders.length; t++) {\\n        pluginFields = $tw.loadPluginFolder(path.resolve(wikiLanguagesPath,\\\"./\\\" + languageFolders[t]));\\n        if(pluginFields) {\\n          $tw.Bob.Wikis[options.prefix].wiki.addTiddler(pluginFields);\\n        }\\n      }\\n    } catch (e) {\\n      $tw.Bob.logger.error('Error loading language folder', e, {level:2});\\n    }\\n  }\\n  return wikiInfo;\\n};\\n\\nServerSide.prepareWiki = function (fullName, servePlugin, cache='yes') {\\n  // Only rebuild the wiki if there have been changes since the last time it\\n  // was built, otherwise use the cached version.\\n  if(typeof $tw.Bob.Wikis[fullName].modified === 'undefined' || $tw.Bob.Wikis[fullName].modified === true || typeof $tw.Bob.Wikis[fullName].cached !== 'string') {\\n    $tw.Bob.Wikis[fullName].plugins = $tw.Bob.Wikis[fullName].plugins || [];\\n    $tw.Bob.Wikis[fullName].themes = $tw.Bob.Wikis[fullName].themes || [];\\n    $tw.Bob.Wikis[fullName].tiddlers = $tw.Bob.Wikis[fullName].tiddlers || [];\\n    if(servePlugin !== 'no') {\\n      // By default the normal file system plugins removed and the\\n      // multi-user plugin added instead so that they all work the same.\\n      // The wikis aren't actually modified, this is just hov they are\\n      // served.\\n      $tw.Bob.Wikis[fullName].plugins = $tw.Bob.Wikis[fullName].plugins.filter(function(plugin) {\\n        return plugin !== 'tiddlywiki/filesystem' && plugin !== 'tiddlywiki/tiddlyweb';\\n      });\\n      if($tw.Bob.Wikis[fullName].plugins.indexOf('$:/plugins/OokTech/Bob') === -1) {\\n        $tw.Bob.Wikis[fullName].plugins.push('$:/plugins/OokTech/Bob');\\n      }\\n    }\\n    $tw.settings.includePluginList = $tw.settings.includePluginList || [];\\n    $tw.settings.excludePluginList = $tw.settings.excludePluginList || [];\\n    // Add any plugins that should be included in every wiki\\n    const includeList = Object.values($tw.settings.includePluginList).filter(function(plugin) {\\n      return $tw.Bob.Wikis[fullName].plugins.indexOf(plugin) === -1;\\n    }).map(function(pluginName) {return '$:/plugins/'+pluginName;})\\n    $tw.Bob.Wikis[fullName].plugins = $tw.Bob.Wikis[fullName].plugins.concat(includeList);\\n    // Remove any plugins in the excluded list\\n    // The exclude list takes precidence over the include list\\n    $tw.Bob.Wikis[fullName].plugins = $tw.Bob.Wikis[fullName].plugins.filter(function(plugin) {\\n      return Object.values($tw.settings.excludePluginList).indexOf(plugin) === -1;\\n    })\\n    // Make sure that all the plugins are actually loaded.\\n    const missingPlugins = $tw.Bob.Wikis[fullName].plugins.filter(function(plugin) {\\n      return !$tw.Bob.Wikis[fullName].wiki.tiddlerExists(plugin);\\n    }).map(function(pluginTiddler) {\\n      return pluginTiddler.replace(/^\\\\$:\\\\/plugins\\\\//, '')\\n    });\\n    if(missingPlugins.length > 0) {\\n      loadPlugins(missingPlugins,$tw.config.pluginsPath,$tw.config.pluginsEnvVar, fullName);\\n    }\\n    // This makes the wikiTiddlers variable a filter that lists all the\\n    // tiddlers for this wiki.\\n    const wikiName = fullName;\\n    const options = {\\n      variables: {\\n        wikiTiddlers:\\n          $tw.Bob.Wikis[fullName].wiki.allTitles().concat($tw.Bob.Wikis[fullName].plugins.concat($tw.Bob.Wikis[fullName].themes)).map(function(tidInfo) {\\n            if(servePlugin === 'no' && tidInfo === '$:/plugins/OokTech/Bob') {\\n              return '';\\n            } else {\\n              return '[[' + tidInfo + ']]';\\n            }\\n          }).join(' '),\\n        wikiName: wikiName\\n      }\\n    };\\n    $tw.Bob.Wikis[fullName].wiki.addTiddler(new $tw.Tiddler({title: '$:/WikiName', text: fullName}))\\n    const text = $tw.Bob.Wikis[fullName].wiki.renderTiddler(\\\"text/plain\\\", $tw.settings['ws-server'].rootTiddler || \\\"$:/core/save/all\\\", options);\\n    // Only cache the wiki if it isn't too big.\\n    if(text.length < 10*1024*1024 && cache !== 'no') {\\n      $tw.Bob.Wikis[fullName].cached = text;\\n      $tw.Bob.Wikis[fullName].modified = false;\\n    } else {\\n      return text;\\n    }\\n  }\\n  return $tw.Bob.Wikis[fullName].cached;\\n}\\n\\n/*\\nplugins: Array of names of plugins (eg, \\\"tiddlywiki/filesystemadaptor\\\")\\nlibraryPath: Path of library folder for these plugins (relative to core path)\\nenvVar: Environment variable name for these plugins\\n*/\\nfunction loadPlugins(plugins,libraryPath,envVar, wikiName) {\\n  if(plugins) {\\n    const pluginPaths = $tw.getLibraryItemSearchPaths(libraryPath,envVar);\\n    for(let t=0; t<plugins.length; t++) {\\n      if(plugins[t] !== 'tiddlywiki/filesystem' && plugins[t] !== 'tiddlywiki/tiddlyweb') {\\n        loadPlugin(plugins[t],pluginPaths, wikiName);\\n      }\\n    }\\n  }\\n};\\n\\n/*\\nname: Name of the plugin to load\\npaths: array of file paths to search for it\\n*/\\nfunction loadPlugin(name,paths, wikiName) {\\n  const pluginPath = $tw.findLibraryItem(name,paths);\\n  if(pluginPath) {\\n    const pluginFields = $tw.loadPluginFolder(pluginPath);\\n    if(pluginFields) {\\n      $tw.Bob.Wikis[wikiName].wiki.addTiddler(pluginFields);\\n    }\\n  }\\n};\\n\\n/*\\n  This copies a folder from source to destination\\n  both source and destination are paths\\n  This uses absolute paths, so make sure you get them before passing them to\\n  this function.\\n\\n  source - the folder to copy\\n  destination - the folder to create containing a copy of the source folder\\n  copyChildren - if set to true than any child wikis inside the source folder will be copied as well, otherwise no child wikis will be copied.\\n  cb - an optional callback function, it is passed source, destination and copyChildren as arguments\\n\\n  note: The callback is called only once for the original function call, it\\n  isn't called for any of the recursive calls used for sub-directories.\\n*/\\nServerSide.specialCopy = function(source, destination, copyChildren, cb) {\\n  let err = undefined;\\n  // Check to make sure inputs are what we expect\\n  if(typeof source !== 'string' || typeof destination !== 'string') {\\n    cb('The source or destination given is not a string.')\\n    return;\\n  }\\n  if(typeof copyChildren === 'function') {\\n    cb = copyChildren;\\n    copyChildren = false;\\n  } else if(typeof copyChildren === 'string') {\\n    copyChildren = (copyChildren==='true' || copyChildren === 'yes')?true:false;\\n  } else if(copyChildren !== true) {\\n    copyChildren = false;\\n  }\\n  try {\\n    fs.mkdirSync(destination, {recursive: true});\\n    const currentDir = fs.readdirSync(source)\\n    currentDir.forEach(function (item) {\\n      if(fs.statSync(path.join(source, item)).isFile()) {\\n        const fd = fs.readFileSync(path.join(source, item), {encoding: 'utf8'});\\n        fs.writeFileSync(path.join(destination, item), fd, {encoding: 'utf8'});\\n      } else {\\n        //Recurse!! Because it is a folder.\\n        // But make sure it is a directory first.\\n        if(fs.statSync(path.join(source, item)).isDirectory() && (!fs.existsSync(path.join(source, item, 'tiddlywiki.info')) || copyChildren)) {\\n          ServerSide.specialCopy(path.join(source, item), path.join(destination, item), copyChildren);\\n        }\\n      }\\n    });\\n  } catch (e) {\\n    err = e;\\n  }\\n  if(typeof cb === 'function') {\\n    cb(err, source, destination, copyChildren)\\n  } else {\\n    return err;\\n  }\\n}\\n\\n/*\\n  Determine which sub-folders are in the current folder\\n*/\\nconst getDirectories = function(source) {\\n  try {\\n    return fs.readdirSync(source).map(function(name) {\\n      return path.join(source,name)\\n    }).filter(function (source) {\\n      return fs.lstatSync(source).isDirectory();\\n    });\\n  } catch (e) {\\n    $tw.Bob.logger.error('Error getting directories', e, {level:2});\\n    return [];\\n  }\\n}\\n/*\\n  This recursively builds a tree of all of the subfolders in the tiddlers\\n  folder.\\n  This can be used to selectively watch folders of tiddlers.\\n*/\\nconst buildTree = function(location, parent) {\\n  const folders = getDirectories(path.join(parent,location));\\n  let parentTree = {'path': path.join(parent,location), folders: {}};\\n  if(folders.length > 0) {\\n    folders.forEach(function(folder) {\\n      const apex = folder.split(path.sep).pop();\\n      parentTree.folders[apex] = {};\\n      parentTree.folders[apex] = buildTree(apex, path.join(parent,location));\\n    })\\n  }\\n  return parentTree;\\n}\\n\\n/*\\n  This sends an alert to the connected browser(s)\\n\\n  Who alerts are sent to can be filtered by:\\n  - wiki: only browsers that are viewing the listed wiki(s) receive the alert.\\n  - authentication level: only people who are logged in with one of the listed\\n      authentication levels gets the alerm.\\n  - specific connections: only the browser(s) using the listed connection(s)\\n      get the alert.\\n\\n  or the alert can be sent to all connected browsers.\\n\\n  {\\n    authentications: [authenticationLevel],\\n    wikis: [wikiName],\\n    connections: [connectionIndex],\\n    alert: alertMessage\\n  }\\n\\n  wikis - an array of wiki names to send the alert to\\n  connections - an array of connection indicies to send the alert to\\n  alert - the text of the alert to send\\n\\n  The authentications, wikis and connections can be combined so only people\\n  who meet all the listed criteria get the alert.\\n\\n  NOTE: we don't have a good way to do these next ones for now, but we need to\\n  in the future.\\n  authentications - an array of authentication levels to receive the alert\\n  access - an array of wikis and access levels (like can view the wiki in\\n  question, or edit it)\\n\\n  We can turn off browser messages\\n*/\\nServerSide.sendBrowserAlert = function(input) {\\n  if ($tw.settings.disableBrowserAlerts !== 'true') {\\n    const message = {\\n      type:'browserAlert',\\n      alert: input.alert\\n    }\\n    input.wikis = input.wikis || [];\\n    input.connections = input.connections || [];\\n    input.authentications = input.authentications || [];\\n    input.alert = input.alert || '';\\n    if(input.alert.length > 0) {\\n      let wikisList = false;\\n      let connectionsList = false;\\n      let authenticationsList = false;\\n      if(input.connections.length > 0) {\\n        connectionsList = [];\\n        $tw.connections.forEach(function(connection) {\\n          if(input.connections.indexOf(connection.index) !== -1) {\\n            connectionsList.push(connection.index);\\n          }\\n        });\\n      }\\n      if(input.wikis.length > 0) {\\n        wikisList = [];\\n        $tw.connections.forEach(function(connection) {\\n          if(input.wikis.indexOf(connection.wiki) !== -1) {\\n            wikisList.push(connection.index);\\n          }\\n        })\\n      }\\n      if(input.authentications.length > 0) {\\n        // Nothing here yet\\n      }\\n      // Get the intersection of all of the things listed above to get the\\n      // connections to send this to.\\n      wikisListThing = wikisList || []\\n      connectionsListThing = connectionsList || []\\n      authenticationsListThing = authenticationsList || []\\n      if(wikisListThing.length > 0 || connectionsListThing.length > 0 || authenticationsListThing.length > 0) {\\n        let intersection = new Set([...connectionsListThing, ...wikisListThing, ...authenticationsListThing]);\\n        if(wikisList) {\\n          const wikiSet = new Set(wikisList);\\n          intersection = new Set([...intersection].filter(x => wikiSet.has(x)));\\n        }\\n        if(connectionsList) {\\n          const connectionsSet = new Set(connectionsList);\\n          intersection = new Set([...intersection].filter(x => connectionsSet.has(x)));\\n        }\\n        if(authenticationsList) {\\n          const authenticationsSet = new Set(authenticationsList);\\n          intersection = new Set([...intersection].filter(x => authenticationsSet.has(x)));\\n        }\\n        intersection.forEach(function(index) {\\n          message.wiki = $tw.connections.wiki\\n          $tw.Bob.SendToBrowser($tw.connections[index], message);\\n        });\\n      } else {\\n        $tw.Bob.logger.log('send message to all browsers', {level: 4})\\n        $tw.Bob.SendToBrowsers(message);\\n      }\\n    }\\n  }\\n}\\n\\nServerSide.getViewableWikiList = function (data) {\\n  data = data || {};\\n  function getList(obj, prefix) {\\n    let output = [];\\n    Object.keys(obj).forEach(function(item) {\\n      if(typeof obj[item] === 'string') {\\n        if($tw.ServerSide.existsListed(prefix+item)) {\\n          if(item == '__path') {\\n            if(prefix.endsWith('/')) {\\n              output.push(prefix.slice(0,-1));\\n            } else {\\n              output.push(prefix);\\n            }\\n          } else {\\n            output.push(prefix+item);\\n          }\\n        }\\n      } else if(typeof obj[item] === 'object') {\\n        output = output.concat(getList(obj[item], prefix + item + '/'));\\n      }\\n    })\\n    return output;\\n  }\\n  // Get the wiki list of wiki names from the settings object\\n  const wikiList = getList($tw.settings.wikis, '');\\n  const viewableWikis = [];\\n  wikiList.forEach(function(wikiName) {\\n    if($tw.Bob.AccessCheck(wikiName, {\\\"decoded\\\": data.decoded}, 'view')) {\\n      viewableWikis.push(wikiName);\\n    }\\n  });\\n  return viewableWikis;\\n}\\n\\nServerSide.findName = function(url) {\\n  url = url.startsWith('/') ? url.slice(1,url.length-1) : url;\\n  const pieces = url.split('/')\\n  let name = ''\\n  let settingsObj = $tw.settings.wikis[pieces[0]]\\n  if(settingsObj) {\\n    name = pieces[0]\\n  }\\n  for (let i = 1; i < pieces.length; i++) {\\n    if(settingsObj) {\\n      if(typeof settingsObj[pieces[i]] === 'object') {\\n        name = name + '/' + pieces[i]\\n        settingsObj = settingsObj[pieces[i]]\\n      } else if(typeof settingsObj[pieces[i]] === 'string') {\\n        name = name + '/' + pieces[i]\\n        break\\n      } else {\\n        break\\n      }\\n    }\\n  }\\n  if (name === '' && pieces[0] === 'RootWiki') {\\n    name = 'RootWiki'\\n  }\\n  return name\\n}\\n\\nmodule.exports = ServerSide\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/SetName\": {\n            \"title\": \"$:/plugins/OokTech/Bob/SetName\",\n            \"tags\": \"$:/tags/SideBarSegment\",\n            \"list-after\": \"$:/core/ui/SideBarSegments/site-subtitle\",\n            \"text\": \"<$list\\n  filter='[[$:/WikiSettings/split]getindex[persistentUsernames]match[yes]]'\\n  variable=unused\\n>\\n  <$list\\n    filter='[[$:/status/UserName]!has[text]][[$:/state/AddUserName]field:text[yes]] +[limit[1]]'\\n    emptyMessage=\\\"\\\"\\\"Current User: {{$:/status/UserName}} <$button class='tc-btn-invisible'>{{$:/core/images/edit-button}}<$action-setfield $tiddler='$:/state/AddUserName' text='yes'/></$button>\\\"\\\"\\\"\\n  >\\n    <$edit-text\\n      tiddler='$:/status/UserName'\\n      tag='input'\\n      placeholder='username'\\n      class='tc-edit-texteditor'\\n      default=''\\n    />\\n    <$button\\n      class='tc-btn-invisible'\\n    >\\n      {{$:/core/images/save-button}}\\n      <$action-setfield\\n        $tiddler='$:/state/AddUserName'\\n        text='no'\\n      />\\n      <$action-setcookie\\n        name=\\\"userName\\\"\\n        value={{$:/status/UserName}}\\n      />\\n    </$button>\\n  </$list>\\n</$list>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/DefaultSettings\": {\n            \"title\": \"$:/plugins/OokTech/Bob/DefaultSettings\",\n            \"text\": \"{\\n  \\\"editionsPath\\\": \\\"./Editions\\\",\\n  \\\"pluginsPath\\\": \\\"./Plugins\\\",\\n  \\\"themesPath\\\": \\\"./Themes\\\",\\n  \\\"wikisPath\\\": \\\"./Wikis\\\",\\n  \\\"wikiPathBase\\\": \\\"cwd\\\",\\n  \\\"includePluginList\\\": [],\\n  \\\"excludePluginList\\\": [],\\n  \\\"autoUnloadWikis\\\": \\\"false\\\",\\n  \\\"disableBrowserAlerts\\\": \\\"false\\\",\\n  \\\"disableFileWatchers\\\": \\\"no\\\",\\n  \\\"fileURLPrefix\\\": \\\"files\\\",\\n  \\\"namespacedWikis\\\": \\\"false\\\",\\n  \\\"saveMediaOnServer\\\": \\\"yes\\\",\\n  \\\"suppressBrowser\\\": \\\"false\\\",\\n  \\\"enableFederation\\\": \\\"no\\\",\\n  \\\"enableFileServer\\\": \\\"no\\\",\\n  \\\"filePathRoot\\\": \\\"./files\\\",\\n  \\\"perWikiFiles\\\": \\\"no\\\",\\n  \\\"enableBobSaver\\\": \\\"yes\\\",\\n  \\\"persistentUsernames\\\": \\\"no\\\",\\n  \\\"scripts\\\": {\\n    \\\"NewWiki\\\": \\\"tiddlywiki #wikiName --init #editionName\\\"\\n  },\\n  \\\"wikis\\\": {\\n  },\\n  \\\"ws-server\\\": {\\n    \\\"port\\\": 8080,\\n    \\\"host\\\": \\\"127.0.0.1\\\",\\n    \\\"autoIncrementPort\\\": \\\"false\\\",\\n    \\\"servePlugin\\\": \\\"yes\\\",\\n    \\\"pathprefix\\\": \\\"\\\"\\n  },\\n  \\\"heartbeat\\\": {\\n    \\\"interval\\\": 1000,\\n    \\\"timeout\\\": 5000\\n  },\\n  \\\"mimeMap\\\": {\\n    \\\".aac\\\": \\\"audio/aac\\\",\\n    \\\".avi\\\": \\\"video/x-msvideo\\\",\\n    \\\".bmp\\\": \\\"image/bmp\\\",\\n    \\\".css\\\": \\\"text/css\\\",\\n    \\\".csv\\\": \\\"text/csv\\\",\\n    \\\".doc\\\": \\\"application/msword\\\",\\n    \\\".epub\\\": \\\"application/epub+zip\\\",\\n    \\\".gif\\\": \\\"image/gif\\\",\\n    \\\".html\\\": \\\"text/html\\\",\\n    \\\".htm\\\": \\\"text/html\\\",\\n    \\\".ico\\\": \\\"image/x-icon\\\",\\n    \\\".jpg\\\": \\\"image/jpeg\\\",\\n    \\\".jpeg\\\": \\\"image/jpeg\\\",\\n    \\\".mp3\\\": \\\"audio/mpeg\\\",\\n    \\\".mp4\\\": \\\"video/mp4\\\",\\n    \\\".mpeg\\\": \\\"video/mpeg\\\",\\n    \\\".odp\\\": \\\"application/vnd.oasis.opendocument.presentation\\\",\\n    \\\".ods\\\": \\\"application/vnd.oasis.opendocument.spreadsheet\\\",\\n    \\\".odt\\\": \\\"application/vnd.oasis.opendocument.text\\\",\\n    \\\".oga\\\": \\\"audio/ogg\\\",\\n    \\\".ogv\\\": \\\"video/ogg\\\",\\n    \\\".ogx\\\": \\\"application/ogg\\\",\\n    \\\".otf\\\": \\\"font/otf\\\",\\n    \\\".pdf\\\": \\\"application/pdf\\\",\\n    \\\".ppt\\\": \\\"application/vnd.ms-powerpoint\\\",\\n    \\\".png\\\": \\\"image/png\\\",\\n    \\\".svg\\\": \\\"image/svg+xml\\\",\\n    \\\".tif\\\": \\\"image/tiff\\\",\\n    \\\".tiff\\\": \\\"image/tiff\\\",\\n    \\\".ttf\\\": \\\"font/ttf\\\",\\n    \\\".txt\\\": \\\"text/plain\\\",\\n    \\\".wav\\\": \\\"audio/wav\\\",\\n    \\\".weba\\\": \\\"audio/weba\\\",\\n    \\\".webm\\\": \\\"video/webm\\\",\\n    \\\".webp\\\": \\\"image/webp\\\",\\n    \\\".woff\\\": \\\"font/woff\\\",\\n    \\\".woff2\\\": \\\"font/woff2\\\",\\n    \\\".xml\\\": \\\"text/xml\\\"\\n  },\\n  \\\"API\\\": {\\n    \\\"enableFetch\\\": \\\"no\\\",\\n    \\\"enablePush\\\": \\\"no\\\",\\n    \\\"pluginLibrary\\\": \\\"no\\\"\\n  },\\n  \\\"logger\\\": {\\n    \\\"useFileLogging\\\":\\\"no\\\",\\n    \\\"fileLogLevel\\\": \\\"2\\\",\\n    \\\"outputFolder\\\": \\\"./logs\\\",\\n    \\\"outputBaseFileName\\\": \\\"Log\\\",\\n    \\\"useSeparateErrorFile\\\": \\\"no\\\",\\n    \\\"outputErrorFileName\\\": \\\"Error\\\",\\n    \\\"ignoreErrors\\\": \\\"yes\\\",\\n    \\\"useBrowserLogging\\\": \\\"no\\\",\\n    \\\"browserLogLevel\\\": \\\"2\\\",\\n    \\\"useConsoleLogging\\\": \\\"yes\\\",\\n    \\\"consoleLogLevel\\\": \\\"2\\\"\\n  },\\n  \\\"federation\\\": {\\n    \\\"serverName\\\": \\\"Noh Neigh-m\\\",\\n    \\\"mobile\\\": \\\"no\\\",\\n    \\\"enableChat\\\": \\\"no\\\",\\n    \\\"udpPort\\\": \\\"3232\\\",\\n    \\\"enableMulticast\\\": \\\"yes\\\",\\n    \\\"multicastAddress\\\": \\\"224.0.0.114\\\",\\n    \\\"broadcast\\\": \\\"yes\\\",\\n    \\\"rebroadcastInterval\\\": \\\"30000\\\",\\n    \\\"checkConnections\\\": \\\"yes\\\"\\n  },\\n  \\\"advanced\\\": {\\n    \\\"localMessageQueueTimeout\\\": 500,\\n    \\\"federatedMessageQueueTimeout\\\": 1500,\\n    \\\"saveTiddlerDelay\\\": 200\\n  },\\n  \\\"servingFiles\\\": {\\n  },\\n  \\\"saver\\\": {\\n    \\\"host\\\": \\\"localhost\\\",\\n    \\\"port\\\": \\\"61192\\\",\\n    \\\"key\\\": \\\"\\\",\\n    \\\"disable\\\": \\\"no\\\"\\n  },\\n  \\\"backups\\\": {\\n    \\\"enable\\\": \\\"no\\\",\\n    \\\"backupFolder\\\": \\\"./backups\\\",\\n    \\\"backupInterval\\\": 600000,\\n    \\\"saveOnLoad\\\": \\\"yes\\\",\\n    \\\"saveOnModified\\\": \\\"yes\\\",\\n    \\\"maxBackups\\\": 10\\n  }\\n}\\n\"\n        },\n        \"$:/plugins/OokTech/NodeSettings/NodeSettings.js\": {\n            \"title\": \"$:/plugins/OokTech/NodeSettings/NodeSettings.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/NodeSettings/NodeSettings.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nLoad settings settings from a JSON file or tiddlers\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n// Export name and synchronous status\\nexports.name = \\\"node-settings\\\";\\nexports.platforms = [\\\"node\\\"];\\nexports.after = [\\\"load-modules\\\"];\\nexports.synchronous = true;\\n\\n// Initialise the $tw.settings object\\n$tw.settings = $tw.settings || {};\\n$tw.settings.wikis = $tw.settings.wikis || {};\\n\\nif($tw.node) {\\n  const fs = require(\\\"fs\\\");\\n  const path = require(\\\"path\\\");\\n  /*\\n    Only load the settings if you are running node\\n  */\\n  const startup = function () {\\n    // The user settings path\\n    const userSettingsPath = path.join($tw.boot.wikiPath, 'settings', 'settings.json');\\n    $tw.settings = JSON.parse($tw.wiki.getTiddler('$:/plugins/OokTech/Bob/DefaultSettings').fields.text);\\n    $tw.loadSettings($tw.settings, userSettingsPath);\\n    updateSettingsWikiPaths($tw.settings.wikis);\\n  }\\n\\n  /*\\n    This allows people to add wikis using name: path in the settings.json and\\n    still have them work correctly with the name: {__path: path} setup.\\n\\n    It takes the wikis section of the settings and changes any entries that are\\n    in the form name: path and puts them in the form name: {__path: path}, and\\n    recursively walks through all the wiki entries.\\n  */\\n  function updateSettingsWikiPaths(inputObj) {\\n    Object.keys(inputObj).forEach(function(entry) {\\n      if(typeof inputObj[entry] === 'string' && entry !== '__path') {\\n        inputObj[entry] = {'__path': inputObj[entry]}\\n      } else if(typeof inputObj[entry] === 'object') {\\n        updateSettingsWikiPaths(inputObj[entry])\\n      }\\n    })\\n  }\\n\\n  /*\\n    Parse the default settings file and the normal user settings file\\n\\n    This function modifies the input settings object with the properties in the\\n    json file at newSettingsPath\\n  */\\n  $tw.loadSettings = function(settings, newSettingsPath) {\\n    if($tw.node && !fs) {\\n      const fs = require('fs')\\n    }\\n    let rawSettings;\\n    let newSettings;\\n\\n    // try/catch in case defined path is invalid.\\n    try {\\n      rawSettings = fs.readFileSync(newSettingsPath);\\n    } catch (err) {\\n      console.log('NodeSettings - No settings file, creating one with default values.');\\n      rawSettings = '{}';\\n    }\\n\\n    // Try to parse the JSON after loading the file.\\n    try {\\n      newSettings = JSON.parse(rawSettings);\\n      console.log('NodeSettings - Parsed raw settings.');\\n    } catch (err) {\\n      console.log('NodeSettings - Malformed settings. Using empty default.');\\n      console.log('NodeSettings - Check settings. Maybe comma error?');\\n      // Create an empty default settings.\\n      newSettings = {};\\n    }\\n\\n    $tw.updateSettings(settings,newSettings);\\n  }\\n\\n  // Modify according to settings tiddlers\\n  /*\\n    We have to be sure that the values are valid somehow\\n  */\\n\\n  /*\\n    Add the update settings function to the $tw object.\\n    TODO figure out if there is a more appropriate place for it. I don't think so\\n    it doesn't fit with the rest of what is in $tw.utils and I can't think of\\n    another place to put it.\\n\\n    Given a local and a global settings, this returns the global settings but with\\n    any properties that are also in the local settings changed to the values given\\n    in the local settings.\\n    Changes to the settings are later saved to the local settings.\\n  */\\n  $tw.updateSettings = function (globalSettings, localSettings) {\\n    //Walk though the properties in the localSettings, for each property set the global settings equal to it, but only for singleton properties. Don't set something like GlobalSettings.Accelerometer = localSettings.Accelerometer, set globalSettings.Accelerometer.Controller = localSettings.Accelerometer.Contorller\\n    Object.keys(localSettings).forEach(function(key,index){\\n      if(typeof localSettings[key] === 'object') {\\n        if(!globalSettings[key]) {\\n          globalSettings[key] = {};\\n        }\\n        //do this again!\\n        $tw.updateSettings(globalSettings[key], localSettings[key]);\\n      } else {\\n        globalSettings[key] = localSettings[key];\\n      }\\n    });\\n  }\\n\\n  $tw.CreateSettingsTiddlers = function (data) {\\n    data = data || {}\\n    data.wiki = data.wiki || 'RootWiki'\\n    // Set the environment variable for the editions path from the settings.\\n    // Because we cheat and don't use command line arguments.\\n    if(typeof $tw.settings.editionsPath === 'string') {\\n      const basePath = $tw.ServerSide.getBasePath();\\n      // We need to make sure this doesn't overwrite existing thing\\n      const fullEditionsPath = path.resolve(basePath, $tw.settings.editionsPath);\\n      if(process.env[\\\"TIDDLYWIKI_EDITION_PATH\\\"] !== undefined && process.env[\\\"TIDDLYWIKI_EDITION_PATH\\\"] !== '') {\\n        process.env[\\\"TIDDLYWIKI_EDITION_PATH\\\"] = process.env[\\\"TIDDLYWIKI_EDITION_PATH\\\"] + path.delimiter + fullEditionsPath;\\n      } else {\\n        process.env[\\\"TIDDLYWIKI_EDITION_PATH\\\"] = fullEditionsPath;\\n      }\\n    }\\n    /*\\n      TODO this needs to be set up so that it only shows things that you have\\n      permissions to see\\n    */\\n    // Create the list of plugins on the server\\n    const pluginList = $tw.utils.getPluginInfo();\\n    $tw.pluginsInfo = {};\\n    Object.keys(pluginList).forEach(function(index) {\\n      $tw.pluginsInfo[index] = pluginList[index].description;\\n    });\\n    let message = {\\n      type: 'saveTiddler',\\n      tiddler: {fields:{title: \\\"$:/Bob/AvailablePluginList\\\", text: JSON.stringify($tw.pluginsInfo, \\\"\\\", 2), type: \\\"application/json\\\"}},\\n      wiki: data.wiki\\n    };\\n    $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n\\n    // Create the list of themes on the server\\n    const themeList = $tw.utils.getThemeInfo();\\n    $tw.themesInfo = {};\\n    Object.keys(themeList).forEach(function(index) {\\n      $tw.themesInfo[index] = themeList[index].description;\\n    });\\n    message = {\\n      type: 'saveTiddler',\\n      tiddler: {fields:{title: \\\"$:/Bob/AvailableThemeList\\\", text: JSON.stringify($tw.themesInfo, \\\"\\\", 2), type: \\\"application/json\\\"}},\\n      wiki: data.wiki\\n    };\\n    $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n\\n    // Create the list of languages on the server\\n    const languageList = $tw.utils.getLanguageInfo();\\n    $tw.languagesInfo = {};\\n    Object.keys(languageList).forEach(function(index) {\\n      $tw.languagesInfo[index] = languageList[index].description;\\n    });\\n    message = {\\n      type: 'saveTiddler',\\n      tiddler: {fields:{title: \\\"$:/Bob/AvailableLanguageList\\\", text: JSON.stringify($tw.languagesInfo, \\\"\\\", 2), type: \\\"application/json\\\"}},\\n      wiki: data.wiki\\n    };\\n    $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n\\n    // Create the $:/Bob/AvailableEditionList tiddler\\n    const editionsList = $tw.utils.getEditionInfo();\\n    $tw.editionsInfo = {};\\n    Object.keys(editionsList).forEach(function(index) {\\n      $tw.editionsInfo[index] = editionsList[index].description;\\n    });\\n    message = {\\n      type: 'saveTiddler',\\n      tiddler: {fields:{title: \\\"$:/Bob/AvailableEditionList\\\", text: JSON.stringify($tw.editionsInfo, \\\"\\\", 2), type: \\\"application/json\\\"}},\\n      wiki: data.wiki\\n    };\\n    $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n\\n    // Create the $:/ServerIP tiddler\\n    message.tiddler = {fields: {title: \\\"$:/ServerIP\\\", text: $tw.settings.serverInfo.ipAddress, port: $tw.httpServerPort, host: $tw.settings.serverInfo.host}};\\n    $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n    // Save the settings to a tiddler.\\n    const settingsString = JSON.stringify($tw.settings, null, 2);\\n    const tiddlerFields = {\\n      title: '$:/WikiSettings',\\n      text: settingsString,\\n      type: 'application/json'\\n    };\\n    message.tiddler = {fields: tiddlerFields};\\n    $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n    // Split it into different things for each thingy\\n    doThisLevel($tw.settings, \\\"$:/WikiSettings/split\\\", data);\\n    let wikiInfo = undefined\\n    try {\\n      // Save the lists of plugins, languages and themes in tiddlywiki.info\\n      const wikiInfoPath = path.join($tw.Bob.Wikis[data.wiki].wikiPath, 'tiddlywiki.info');\\n      wikiInfo = JSON.parse(fs.readFileSync(wikiInfoPath,\\\"utf8\\\"));\\n    } catch(e) {\\n      console.log(e)\\n    }\\n    if(typeof wikiInfo === 'object') {\\n      // Get plugin list\\n      const fieldsPluginList = {\\n        title: '$:/Bob/ActivePluginList',\\n        list: $tw.utils.stringifyList(wikiInfo.plugins)\\n      }\\n      message.tiddler = {fields: fieldsPluginList};\\n      $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n      const fieldsThemesList = {\\n        title: '$:/Bob/ActiveThemesList',\\n        list: $tw.utils.stringifyList(wikiInfo.themes)\\n      }\\n      message.tiddler = {fields: fieldsThemesList};\\n      $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n      const fieldsLanguagesList = {\\n        title: '$:/Bob/ActiveLanguagesList',\\n        list: $tw.utils.stringifyList(wikiInfo.languages)\\n      }\\n      message.tiddler = {fields: fieldsLanguagesList};\\n      $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n    }\\n  }\\n\\n  function doThisLevel (inputObject, currentName, data) {\\n    let currentLevel = {};\\n    Object.keys(inputObject).forEach( function (property) {\\n      if(typeof inputObject[property] === 'object') {\\n        // Call recursive function to walk through properties, but only if\\n        // there are properties\\n        if(Object.keys(inputObject[property])) {\\n          doThisLevel(inputObject[property], currentName + '/' + property, data);\\n          currentLevel[property] = currentName + '/' + property;\\n        }\\n      } else {\\n        // Add it to this one.\\n        currentLevel[property] = inputObject[property];\\n      }\\n    });\\n    const tiddlerFields = {\\n      title: currentName,\\n      text: JSON.stringify(currentLevel, \\\"\\\", 2),\\n      type: 'application/json'\\n    };\\n    let message = {\\n      type: 'saveTiddler',\\n      wiki: data.wiki\\n    };\\n    message.tiddler = {fields: tiddlerFields};\\n    $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n  }\\n\\n  startup();\\n}\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/SharedFunctions.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/SharedFunctions.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/SharedFunctions.js\\ntype: application/javascript\\nmodule-type: library\\n\\nThis has some functions that are needed by Bob in different places.\\n\\n\\\\*/\\n(function () {\\n\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  // Export name and synchronous status\\n  exports.name = \\\"web-sockets-setup\\\";\\n  exports.platforms = [\\\"browser\\\", \\\"node\\\"];\\n  exports.after = [\\\"render\\\"];\\n  exports.synchronous = true;\\n\\n  let Shared = {};\\n  let idNumber = 0;\\n\\n  $tw.Bob = $tw.Bob || {};\\n  $tw.Bob.MessageQueue = $tw.Bob.MessageQueue || [];\\n  $tw.connections = $tw.connections || [];\\n  $tw.settings.advanced = $tw.settings.advanced || {};\\n  let messageQueueTimer = false;\\n\\n  /*\\n    This is used to parse cookie strings, both on the server and in the browser.\\n  */\\n  $tw.Bob.getCookie = function(cookie, cname) {\\n    cookie = cookie || \\\"\\\"\\n    const name = cname + \\\"=\\\";\\n    const ca = cookie.split(';');\\n    for(let i = 0; i <ca.length; i++) {\\n      let c = ca[i];\\n      while (c.charAt(0) == ' ') {\\n        c = c.substring(1);\\n      }\\n      if(c.indexOf(name) == 0) {\\n        return c.substring(name.length, c.length);\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /*\\n    This function takes two tiddler objects and returns a boolean value\\n    indicating if they are the same or not.\\n  */\\n  Shared.TiddlerHasChanged = function (tiddler, otherTiddler) {\\n    if(!otherTiddler) {\\n      return true;\\n    }\\n    if(!tiddler) {\\n      return true;\\n    }\\n    if(!otherTiddler.fields && tiddler.fields) {\\n      return true;\\n    }\\n    if(!tiddler.fields && otherTiddler.fields) {\\n      return true;\\n    }\\n    const hash1 = tiddler.hash || $tw.Bob.Shared.getTiddlerHash(tiddler);\\n    const hash2 = otherTiddler.hash || $tw.Bob.Shared.getTiddlerHash(otherTiddler);\\n    return hash1 !== hash2;\\n  };\\n\\n  /*\\n    messageQueue [messageData]\\n    messageData {\\n      message: message,\\n      time: original sending timestamp,\\n      ctime: the time when all active connections have given an ack (for pruning old messages)\\n      id: messageId,\\n      ack: ackObject,\\n      title: tidTitle,\\n      type: messageType\\n    }\\n    ackObject {\\n      index: ackReceived,\\n      index2: ackReceived2\\n    }\\n\\n    message - the json object that is actually sent as the message.\\n    time - the time the messageData is created\\n    id - the message id (should be unique per-session)\\n    ack - an object that holds each connection that the message is sent to and\\n      if an ack has been received or not yet\\n    title - for messages that refer to a tiddler this is the tiddler title,\\n      otherwise it is undefined.\\n    type - the message type\\n\\n    for the ackObject the index is the connection index and ackReceived is a\\n    boolean indicating if the ack has been received yet or not.\\n  */\\n  Shared.createMessageData = function (message) {\\n    //const id = message.id || makeId();\\n    const id = makeId()\\n    message.id = id;\\n    let title = undefined;\\n    if(['saveTiddler', 'deleteTiddler', 'editingTiddler', 'cancelEditingTiddler'].indexOf(message.type) !== -1) {\\n      message.tiddler = JSON.parse(JSON.stringify(message.tiddler));\\n      title = message.tiddler.fields.title;\\n      message.tiddler.hash = $tw.Bob.Shared.getTiddlerHash(message.tiddler);\\n    }\\n    let messageData = {\\n      message: message,\\n      id: id,\\n      time: Date.now(),\\n      type: message.type,\\n      title: title,\\n      ack: {},\\n      wiki: message.wiki\\n    };\\n    return messageData;\\n  }\\n\\n  /*\\n    This function checks the message queue to see if anything should be done.\\n\\n    It first checks to see if there are any messages in the message queue, if\\n    not than it does nothing other than removing the timer to recheck the\\n    queue. The timer is restarted elsewhere if a message is sent.\\n\\n    It then prunes the message queue, removing any messages that have been\\n    send and acknoweldeged so there is nothing more to do with them.\\n\\n    It then checks any remaining messages to check if there are any that are\\n    older than 500ms.\\n    These messages are assumed to have been missed by the other end and are\\n    resent.\\n\\n    If the queue isn't empty the timeout is reset for this function to run\\n    again in 500ms\\n  */\\n  function checkMessageQueue() {\\n    // If the queue isn't empty\\n    if($tw.Bob.MessageQueue.length > 0) {\\n      // Remove messages that have already been sent and have received all\\n      // their acks and have waited the required amonut of time.\\n      $tw.Bob.MessageQueue = pruneMessageQueue($tw.Bob.MessageQueue);\\n      // Check if there are any messages that are more than 500ms old and have\\n      // not received the acks expected.\\n      // These are assumed to have been lost and need to be resent\\n      const oldMessages = $tw.Bob.MessageQueue.filter(function(messageData) {\\n        if(Date.now() - messageData.time > $tw.settings.advanced.localMessageQueueTimeout || 500) {\\n          return true;\\n        } else {\\n          return false;\\n        }\\n      });\\n      oldMessages.forEach(function (messageData) {\\n        // If we are in the browser there is only one connection, but\\n        // everything here is the same.\\n        const targetConnections = $tw.node?(messageData.wiki?$tw.connections.filter(function(item) {\\n          return item.wiki === messageData.wiki\\n        }):[]):[$tw.connections[0]];\\n        targetConnections.forEach(function(connection) {\\n          _sendMessage(connection, messageData)\\n        });\\n      });\\n      if(messageQueueTimer) {\\n        clearTimeout(messageQueueTimer);\\n      }\\n      messageQueueTimer = setTimeout(checkMessageQueue, $tw.settings.advanced.localMessageQueueTimeout || 500);\\n    } else {\\n      clearTimeout(messageQueueTimer);\\n      messageQueueTimer = false;\\n    }\\n  }\\n\\n  function _sendMessage(connection, messageData) {\\n    const index = connection.index;\\n    // Here make sure that the connection is live and hasn't already\\n    // sent an ack for the current message.\\n    if(connection.socket !== undefined) {\\n      if(!messageData.ack[index] && connection.socket.readyState === 1) {\\n        // We have a slight delay before sending saveTiddler messages,\\n        // this is because if you send them right away than you have\\n        // trouble with fields that are edited outside the tiddler edit\\n        // view (like setting the site title or subtitle) because a\\n        // message is sent on each key press and it creates race\\n        // conditions with the server and which was the last message can\\n        // get confused and it can even get stuck in infinite update\\n        // loops.\\n        if(messageData.type === 'saveTiddler' && $tw.browser) {\\n          // Each tiddler gets a timer invalidate the timer and reset it\\n          // each time we get a saveTiddler message for a tiddler\\n          clearTimeout($tw.Bob.Timers[messageData.title]);\\n          // then reset the timer\\n          $tw.Bob.Timers[messageData.title] = setTimeout(function() {\\n            connection.socket.send(JSON.stringify(messageData.message));\\n          }, $tw.settings.advanced.saveTiddlerDelay || 200);\\n        } else {\\n          connection.socket.send(JSON.stringify(messageData.message));\\n        }\\n      }\\n    }\\n  }\\n\\n  /*\\n    This returns a new id for a message.\\n    Messages from the browser have ids that start with b, messages from the\\n    server have an idea that starts with s.\\n  */\\n  function makeId() {\\n    idNumber = idNumber + 1;\\n    const newId = ($tw.browser?'b':'s') + idNumber;\\n    return newId;\\n  }\\n\\n  /*\\n    This takes a new message and a message queue.\\n\\n    It returns an updated queue that has any messages made irrelevant by the\\n    new message removed.\\n\\n    Irrelevant messages are defined as:\\n\\n    - Any saveTiddler or deleteTiddler message make any previous saveTiddler,\\n      deleteTiddler, editingTiddler or cancelEditingTiddler messages for the\\n      same tiddler irrelevant.\\n    - Any editingTiddler or cancelEditingTiddler messages make any previous\\n      editingTiddler or cancelEditingTiddler messages for the same tiddler\\n      irrelevant.\\n    - Finally a message that is an exact duplicate of a previous message\\n      overrides the previous message.\\n\\n    For example if there are two save tiddler messages for the same tiddler one\\n    right after the other the first message is not important because the second\\n    one will overwirte whatever the first one does. Therefore the first message\\n    can safely be dropped.\\n    Alternately, any number of 'saveTiddler' messages can be ignored if the\\n    tiddler in question is deleted by a later enqueued message.\\n  */\\n  Shared.removeRedundantMessages = function (messageData, queue) {\\n    // Get a list of any duplicate messages or any that are now redundant\\n    // because of the new message.\\n    const duplicateIndicies = queue.map(function(item, index) {\\n      // Messages with the same id are the same message and not considered\\n      // redudant here. There are other checks to make sure that the same\\n      // message isn't enqueued twice.\\n      // This is needed here or we lose the ack state of our connections if we\\n      // send the same message to multiple connections.\\n      if(messageData.id === item.id) {\\n        return -1;\\n      }\\n      // A delete or save tiddler message overrules any delete, save, editing\\n      // or cancel editing messages for the same tiddler.\\n      if(['deleteTiddler', 'saveTiddler'].includes(messageData.type) && ['deleteTiddler', 'editingTiddler', 'cancelEditingTiddler', 'saveTiddler'].includes(item.type)) {\\n        if(messageData.title === item.title) {\\n          return index;\\n        }\\n      }\\n      // An editingTiddler or cancelEditingTiddler message overrides any\\n      // previous editingTiddler or cancelEditingTiddler messages.\\n      if(['editingTiddler', 'cancelEditingTiddler'].includes(messageData.type) && ['editingTiddler', 'cancelEditingTiddler'].includes(item.type)) {\\n        if(messageData.title === item.title) {\\n          return index;\\n        }\\n      }\\n      // Finally if it isn't any of the basic messages check to see if the\\n      // message is a direct duplicate of an existing message.\\n      // match lists all the keys in message that don't have the same value in\\n      // item.message and all the keys in item.message that don't have the same\\n      // value in message.\\n      // If match has any elements in it than they are different messages.\\n      const match = Object.keys(messageData.message).filter(function(key) {\\n        return (messageData.message[key] !== item.message[key])\\n      }).concat(Object.keys(item.message).filter(function(key) {\\n        return (messageData.message[key] !== item.message[key])\\n      }));\\n      if(match.length === 0) {\\n        return index;\\n      }\\n      // If none of the above returned than there is no match.\\n      return -1;\\n    }).filter(function(item) {return item > -1;});\\n    // Remove the messages that are overruled by the new message.\\n    const outQueue = queue.filter(function(item, index) {\\n      if (duplicateIndicies.indexOf(index) !== -1) {\\n        if ($tw.browser) {\\n          const receivedAck = new CustomEvent('handle-ack', {bubbles: true, detail: item.id})\\n          $tw.rootWidget.dispatchEvent(receivedAck)\\n        }\\n        return false\\n      } else {\\n        return true\\n      }\\n      return duplicateIndicies.indexOf(index) < 0;\\n    });\\n    // return the new queue\\n    return outQueue;\\n  }\\n\\n  /*\\n    This checks if a message is eligable to be sent and returns a boolean value\\n    true means the message should be sent or stored and false means it\\n    shouldn't.\\n\\n    This checks:\\n\\n    - If the wiki listed on the connection is the same as the wiki the message\\n      is for, or if it is in the browser, or if there is no wiki listed\\n    - If the tiddler the message is about is in the exclude list\\n    - If the message is either saveTiddler, deleteTiddler, editingTiddler or\\n      cancelEditingTiddler and there is a newer saverTiddler or deleteTiddler\\n      message for the same tiddler in the queue than ignore the message\\n    - If the message is either editingTiddler or cancelEditingTiddler and there\\n      is a newer saveTiddler, deleteTiddler, editingTiddler or\\n      cancelEditingTiddler message for the same tiddler in the queue than\\n      ignore the message\\n    - If the message is a saveTiddler message and there is another saveTiddler\\n      message for the same tiddler and the tiddler hasn't changed ignore the\\n      message\\n  */\\n  Shared.messageIsEligible = function (messageData, connectionIndex, queue) {\\n    let send = false;\\n    if($tw.node && messageData.message.wiki) {\\n      $tw.ServerSide.loadWiki(messageData.message.wiki, nextBit());\\n    } else {\\n      nextBit();\\n    }\\n    function nextBit() {\\n      // Make sure that the connectionIndex and queue exist. This may be over\\n      // paranoid\\n      connectionIndex = connectionIndex || 0;\\n      queue = queue || [];\\n      // Start out saying that a message shouldn't be sent\\n      // Make sure that the tags field is an array so it fits what is expected\\n      if(messageData.type === 'saveTiddler') {\\n        messageData.message.tiddler = $tw.Bob.Shared.normalizeTiddler(messageData.message.tiddler)\\n      }\\n      // Only send things if the message is meant for the wiki or if the browser\\n      // is sending a message to the server. No wiki listed in the message means\\n      // it is a general message from the browser to all wikis.\\n      if(messageData.message.wiki === $tw.connections[connectionIndex].wiki || $tw.browser || !messageData.message.wiki) {\\n        let ignore = false;\\n        // Ignore saveTiddler, deleteTiddler and editingTiddler messages for\\n        // tiddlers that are listed by the sync exclude filter.\\n        // We do not ignore cancelEditingTiddler messages because they are sent\\n        // with draft tiddler titles which would be ignored, but that prevents\\n        // the lock from being removed from the non-draft tiddler.\\n        let list = [];\\n        if(['deleteTiddler', 'saveTiddler', 'editingTiddler'].indexOf(messageData.type) !== -1) {\\n          if($tw.node) {\\n            if(!messageData.message.wiki) {\\n              // TODO fix this terrible workaround\\n              list = []\\n            } else {\\n              list = $tw.Bob.Wikis[messageData.message.wiki].wiki.filterTiddlers($tw.Bob.ExcludeFilter);\\n            }\\n          } else {\\n            list = $tw.wiki.filterTiddlers($tw.Bob.ExcludeFilter);\\n          }\\n          if(list.indexOf(messageData.title) !== -1) {\\n            ignore = true;\\n          }\\n        }\\n        if(!ignore) {\\n          // If the new message is one of these types for a tiddler and the\\n          // timestamp of the queued message is newer than the current message\\n          // ignore the new message\\n          const nonMultipleMessageTypes = ['deleteTiddler', 'saveTiddler', 'editingTiddler', 'cancelEditingTiddler', 'setViewableWikis', 'listTiddlers', 'setLoggedIn', 'updateEditingTiddlers'];\\n          if(nonMultipleMessageTypes.indexOf(messageData.type) !== -1) {\\n            // Look at each queued message\\n            queue.forEach(function(queuedMessageData){\\n              // If the queued message has one of these types\\n              if(nonMultipleMessageTypes.indexOf(queuedMessageData.type) !== -1) {\\n                // if the queued message is newer than the current message ignore\\n                // the current message\\n                if(queuedMessageData.title === messageData.title && queuedMessageData.timestamp > messageData.timestamp) {\\n                  ignore = true;\\n                }\\n              }\\n            })\\n          }\\n        }\\n        if(!ignore) {\\n          // If the new message is one of these types for a tiddler and the\\n          // timestamp of the queued message is newer than the current message\\n          // ignore the new message\\n          if(['editingTiddler', 'cancelEditingTiddler'].indexOf(messageData.type) !== -1) {\\n            // Look at each queued message\\n            queue.forEach(function(queuedMessageData){\\n              // If the queued message has one of these types\\n              if(['editingTiddler', 'cancelEditingTiddler'].indexOf(queuedMessageData.type) !== -1) {\\n                // if the queued message is newer than the current message ignore\\n                // the current message\\n                if(queuedMessageData.title === messageData.title && queuedMessageData.timestamp > messageData.timestamp) {\\n                  ignore = true;\\n                }\\n              }\\n            })\\n          }\\n        }\\n        if(!ignore) {\\n          // Ignore saveTiddler messages if there is already a saveTiddler\\n          // message in the queue for that tiddler and the tiddler is the same in\\n          // both messages.\\n          if(messageData.type === 'saveTiddler') {\\n            queue.forEach(function(message, messageIndex) {\\n              if(message.type === 'saveTiddler' && message.title === messageData.title) {\\n                if(!$tw.Bob.Shared.TiddlerHasChanged(messageData.message.tiddler, queue[messageIndex].message.tiddler)) {\\n                  ignore = true;\\n                }\\n              }\\n            })\\n          }\\n        }\\n        if(!ignore) {\\n          send = true;\\n        }\\n      }\\n      return send;\\n    }\\n    return send;\\n  }\\n\\n  /*\\n    This sends the message described by messageData to the connection indicated by connectionIndex, if appropriate.\\n\\n    First the message is checked to make sure it is eligible to be send using\\n    Shared.messageIsEligible, if it isn't than nothing is sent but the messageQueue timer is still reset.\\n\\n    If the message is eligible to be sent than the message queue is checked any\\n    any existing messages that the current message makes redundant are removed\\n    from the queue. Note that the same message (that is the direct duplicate\\n    with the same messageId) is not removed here, if it were than the same\\n    message being sent from the server to multiple browsers would overwrite the\\n    ack state of each browser as the message was sent to the next one.\\n\\n    Then the queue is checked to see if the same message is already enqueued,\\n    if so than only the ack state is updated so it is waiting for an ack from\\n    the current connectionIndex. If the message is not already enqueued than\\n    the ack state is updated in the messageData and it is added to the queue.\\n\\n    For same tiddler messages there is a short timer between the saveTiddler\\n    message being queued up and being sent so that any new saveTiddler message\\n    for the same tiddler overrides it. This is to prevent race conditions\\n    caused by a sequence of saveTiddler messages being sent in very quick\\n    succession and possibly being handled out of order by the reciving end or\\n    leading to an infinite update loop.\\n\\n    For every other message type it is just sent.\\n\\n    This modifies $tw.Bob.MessageQueue as a side effect\\n  */\\n  Shared.sendMessage = function(message, connectionIndex, messageData) {\\n    messageData = messageData || Shared.createMessageData(message)\\n    if(Shared.messageIsEligible(messageData, connectionIndex, $tw.Bob.MessageQueue)) {\\n      $tw.Bob.Timers = $tw.Bob.Timers || {};\\n      connectionIndex = connectionIndex || 0;\\n      if (messageData.message.tiddler) {\\n        messageData.message.tiddler = $tw.Bob.Shared.normalizeTiddler(messageData.message.tiddler);\\n      }\\n\\n      // Remove any messages made redundant by this message\\n      $tw.Bob.MessageQueue = Shared.removeRedundantMessages(messageData, $tw.Bob.MessageQueue);\\n      if($tw.browser) {\\n        // Check to see if the token has changed\\n        $tw.Bob.MessageQueue = removeOldTokenMessages($tw.Bob.MessageQueue);\\n      }\\n      // If the message is already in the queue (as determined by the message\\n      // id), than just add the new target to the ackObject\\n      const enqueuedIndex = Object.keys($tw.Bob.MessageQueue).findIndex(function(enqueuedMessageData) {\\n        return enqueuedMessageData.id === messageData.id;\\n      });\\n      if(enqueuedIndex !== -1) {\\n        $tw.Bob.MessageQueue[enqueuedIndex].ack[connectionIndex] = false;\\n      } else {\\n        // If the message isn't in the queue set the ack status for the current\\n        // connectionIndex and enqueue the message\\n        messageData.ack[connectionIndex] = false;\\n        $tw.Bob.MessageQueue.push(messageData);\\n      }\\n      _sendMessage($tw.connections[connectionIndex], messageData)\\n    } else if ($tw.browser) {\\n      // If we are not sending the message then we have to emit the 'received-ack' event so that the syncer thinks it is finished.\\n      const receivedAck = new CustomEvent('handle-ack', {bubbles: true, detail: messageData.id})\\n      $tw.rootWidget.dispatchEvent(receivedAck)\\n    }\\n    clearTimeout(messageQueueTimer);\\n    messageQueueTimer = setTimeout(checkMessageQueue, $tw.settings.advanced.localMessageQueueTimeout || 500);\\n    return messageData;\\n  }\\n\\n  /*\\n    If the token in the queued messages changes than remove messages that use\\n    the old token\\n  */\\n  function removeOldTokenMessages(messageQueue) {\\n    let outQueue = [];\\n    if(localStorage) {\\n      if(typeof localStorage.getItem === 'function') {\\n        const token = localStorage.getItem('ws-token');\\n        outQueue = messageQueue.filter(function(messageData) {\\n          return messageData.message.token === token\\n        })\\n      }\\n    } else {\\n      outQueue = messageQueue;\\n    }\\n    return outQueue\\n  }\\n\\n  /*\\n    This is the function for handling ack messages on both the server and\\n    browser. It is the same on both sides so it is here to prevent duplicate\\n    code.\\n\\n    It takes a messadeData object as input and checks it against the message\\n    queue. If the queue contains a message with the same id as node input\\n    messageData than the ack state for the connection the ack came from is set\\n    to true.\\n\\n    If all acks for the messageData in the queue are set to true than the ctime\\n    for that messageData is set to the current time so it can be properly\\n    removed later.\\n  */\\n  Shared.handleAck = function (data) {\\n    if ($tw.browser) {\\n      // Events to let the syncadaptor work in the browser\\n      const receivedAck = new CustomEvent('handle-ack', {bubbles: true, detail: data.id})\\n      $tw.rootWidget.dispatchEvent(receivedAck)\\n    }\\n    if(data.id) {\\n      // a quick hack to make this work\\n      if($tw.browser) {\\n        // The source connection is always 0 in the browser\\n        data.source_connection = 0;\\n      }\\n      const index = $tw.Bob.MessageQueue.findIndex(function(messageData) {\\n        return messageData.id === data.id;\\n      })\\n      if($tw.Bob.MessageQueue[index]) {\\n        // Set the message as acknowledged.\\n        $tw.Bob.MessageQueue[index].ack[data.source_connection] = true;\\n        // Check if all the expected acks have been received\\n        const complete = Object.keys($tw.Bob.MessageQueue[index].ack).findIndex(function(value){\\n          return $tw.Bob.MessageQueue[index].ack[value] !== true;\\n        }) === -1;\\n        // If acks have been received from all connections than set the ctime.\\n        if(complete && !$tw.Bob.MessageQueue[index].ctime) {\\n          $tw.Bob.MessageQueue[index].ctime = Date.now();\\n        }\\n      }\\n    }\\n  }\\n\\n  /*\\n    This takes a messageQueue as input and returns a queue with old messages\\n    removed.\\n\\n    As part of the ack handling, once a message receives an ack from every\\n    connection it is sent to the ctime is set.\\n    This checks each message in the queue and if the ctime exists and is more\\n    than 10000ms old than it removes the message from the returned queue.\\n\\n    A message is kept past the final ack because some messages can be sent\\n    multiple times and things get stuck in an infinite loop if we don't detect\\n    that they are duplicates.\\n  */\\n  function pruneMessageQueue(inQueue) {\\n    inQueue = inQueue || [];\\n    let token = false\\n    if($tw.browser && localStorage) {\\n      token = localStorage.getItem('ws-token');\\n    }\\n    // We can not remove messages immediately or else they won't be around to\\n    // prevent duplicates when the message from the file system monitor comes\\n    // in.\\n    // But we don't want a huge history of messages taking up all the ram, so\\n    // we set some long time to live on the message queue and remove any\\n    // messages older than this TTL when we receive a new ack.\\n    // remove the message with the id from the message queue\\n    // try removing messages that received an ack more than 10 seconds ago.\\n\\n    // messageData.ack.ctime is the time that a message received all the acks\\n    // it was waiting for. If it doesn't exist than it is still waiting.\\n    const outQueue = inQueue.filter(function(messageData) {\\n      if((token && messageData.message.token && messageData.message.token !== token) || (token && !messageData.message.token) ) {\\n        // If we have a token, the message has a token and they are not the\\n        // same than drop the message. (possible imposter)\\n        // If we have a token and the message doesn't have a token than drop it\\n        // (someone unathenticated trying to make changes)\\n        // If we don't have a token and the message does than what?\\n        return false\\n      } else if(messageData.ctime) {\\n        // if there is a ctime than check if it is more than 10000ms ago, if so\\n        // remove the message.\\n        if(Date.now() - messageData.ctime > 10000) {\\n          return false;\\n        } else {\\n          return true;\\n        }\\n      } else {\\n        return true;\\n      }\\n    })\\n    return outQueue;\\n  }\\n\\n  /*\\n    This normalizes a tiddler so that it can be compared to another tiddler to\\n    determine if they are the same.\\n\\n    Any two tiddlers that have the same fields and content (including title)\\n    will return exactly the same thing using this function.\\n\\n    Fields are included in alphabetical order, as defined by the javascript\\n    array sort method.\\n\\n    The tag field gets sorted and the list field is interpreted as a string\\n    array. If either field exists but it is an empty string it is replaced with\\n    an empty array.\\n\\n    Date fields (modified and created) are stringified.\\n  */\\n  Shared.normalizeTiddler = function(tiddler) {\\n    let newTid = {};\\n    if(tiddler) {\\n      if(tiddler.fields) {\\n        let fields = Object.keys(tiddler.fields) || []\\n        fields.sort()\\n        fields.forEach(function(field) {\\n          if(field === 'list' || field === 'tags') {\\n            if(Array.isArray(tiddler.fields[field])) {\\n              newTid[field] = tiddler.fields[field].slice()\\n              if (field === 'tags') {\\n                newTid[field] = newTid[field].sort()\\n              }\\n            } else if(tiddler.fields[field] === '') {\\n              newTid[field] = []\\n            } else {\\n              newTid[field] = $tw.utils.parseStringArray(tiddler.fields[field]).slice()\\n              if (field === 'tags') {\\n                newTid[field] = newTid[field].sort()\\n              }\\n            }\\n          } else if(field === 'modified' || field === 'created') {\\n            if(typeof tiddler.fields[field] === 'object' && tiddler.fields[field] !== null) {\\n              newTid[field] = $tw.utils.stringifyDate(tiddler.fields[field]);\\n            } else {\\n              newTid[field] = tiddler.fields[field]\\n            }\\n          } else {\\n            newTid[field] = tiddler.fields[field]\\n          }\\n        })\\n        if(typeof newTid.text === 'undefined' || !newTid.text) {\\n          newTid.text = '';\\n        }\\n      }\\n    }\\n    return {fields: newTid}\\n  }\\n\\n  /*\\n    This is a simple and fast hashing function that we can use to test if a\\n    tiddler has changed or not.\\n    This doesn't need to be at all secure, and doesn't even need to be that\\n    robust against collisions, it just needs to make collisions rare for a very\\n    easy value of rare, like 0.1% would be more than enough to make this very\\n    useful, and this should be much better than that.\\n\\n    Remember that this just cares about collisions between one tiddler and its\\n    previous state after an edit, not between all tiddlers in the wiki or\\n    anything like that.\\n  */\\n  // This is a stable json stringify function from https://github.com/epoberezkin/fast-json-stable-stringify\\n  function stableStringify (data, opts) {\\n    if(!opts) opts = {};\\n    if(typeof opts === 'function') opts = { cmp: opts };\\n    let cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\\n\\n    let cmp = opts.cmp && (function (f) {\\n        return function (node) {\\n            return function (a, b) {\\n                const aobj = { key: a, value: node[a] };\\n                const bobj = { key: b, value: node[b] };\\n                return f(aobj, bobj);\\n            };\\n        };\\n    })(opts.cmp);\\n\\n    let seen = [];\\n    return (function stringify (node) {\\n        if(node && node.toJSON && typeof node.toJSON === 'function') {\\n            node = node.toJSON();\\n        }\\n\\n        if(node === undefined) return;\\n        if(typeof node == 'number') return isFinite(node) ? '' + node : 'null';\\n        if(typeof node !== 'object') return JSON.stringify(node);\\n\\n        let i, out;\\n        if(Array.isArray(node)) {\\n            out = '[';\\n            for (i = 0; i < node.length; i++) {\\n                if(i) out += ',';\\n                out += stringify(node[i]) || 'null';\\n            }\\n            return out + ']';\\n        }\\n\\n        if(node === null) return 'null';\\n\\n        if(seen.indexOf(node) !== -1) {\\n            if(cycles) return JSON.stringify('__cycle__');\\n            throw new TypeError('Converting circular structure to JSON');\\n        }\\n\\n        let seenIndex = seen.push(node) - 1;\\n        let keys = Object.keys(node).sort(cmp && cmp(node));\\n        out = '';\\n        for (i = 0; i < keys.length; i++) {\\n            let key = keys[i];\\n            let value = stringify(node[key]);\\n\\n            if(!value) continue;\\n            if(out) out += ',';\\n            out += JSON.stringify(key) + ':' + value;\\n        }\\n        seen.splice(seenIndex, 1);\\n        return '{' + out + '}';\\n    })(data);\\n  };\\n  Shared.getTiddlerHash = function(tiddler) {\\n    const tiddlerString = stableStringify(Shared.normalizeTiddler(tiddler))\\n    let hash = 0;\\n    if(tiddlerString.length === 0) {\\n        return hash;\\n    }\\n    for (let i = 0; i < tiddlerString.length; i++) {\\n        const char = tiddlerString.charCodeAt(i);\\n        hash = ((hash<<5)-hash)+char;\\n        hash = hash & hash; // Convert to 32bit integer\\n    }\\n    return hash;\\n  }\\n\\n  /*\\n    This acknowledges that a message has been received.\\n  */\\n  Shared.sendAck = function (data) {\\n    data = data || {};\\n    if($tw.browser) {\\n      const token = localStorage.getItem('ws-token')\\n      $tw.connections[0].socket.send(JSON.stringify({\\n        type: 'ack',\\n        id: data.id,\\n        token: token,\\n        wiki: $tw.wikiName\\n      }));\\n    } else {\\n      if(data.id) {\\n        if(data.source_connection !== undefined && data.source_connection !== -1) {\\n          $tw.connections[data.source_connection].socket.send(JSON.stringify({\\n            type: 'ack',\\n            id: data.id\\n          }));\\n        }\\n      }\\n    }\\n  }\\n\\n  module.exports = Shared;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/OokTech/Bob/Styles\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Styles\",\n            \"tags\": \"$:/tags/Stylesheet\",\n            \"text\": \".folding-list {\\n  list-style: none;\\n}\\n\\n.folding-list ul {\\n  list-style: none;\\n}\\n\\n.folding-list li {\\n  list-style: none;\\n}\\n\"\n        },\n        \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/TestCases.md\": {\n            \"title\": \"/home/runner/work/wiki/wiki/Meme-of-LinOnetwo/plugins/OokTech/Bob/TestCases.md\",\n            \"text\": \"# Test Cases\\n\\nUntil we get some automated testing set up this is a list of tests that should\\nshow at least the most common places where something may be broken.\\n\\nIf you create something make sure that all of the following work after your\\nchanges:\\n\\n## Creating, deleting and editing tiddlers\\n\\n1. The wiki actually boots\\n2. Loading the wiki in one browser doesn't crash the node process\\n3. Loading the wiki in multiple browser tabs/on multiple computers doesn't\\n  crash the node process.\\n4. Creating a tiddler in one browser tab results in:\\n  - The tiddler appearing in another already-open browser tab with the same\\n    wiki open\\n  - The corresponding .tid file appears on the file system\\n  - Opening up the wiki in a new browser tab/browser/computer shows the new tiddler\\n  - After re-loading an already open wiki the tiddler is still shown in that\\n    wiki\\n  - The tiddler still exists after stopping and restarting the node process and\\n    then re-loading the wiki.\\n5. Creating a new .tid file with the proper fields present results in:\\n  - The tiddler appears in any open wikis\\n  - The tiddler appears in any new wikis opened\\n  - The tiddler persists after reloading an already loaded wiki\\n  - The tiddler persists after stopping and restarting the node process\\n6. Deleting a tiddler in one browser tab results in:\\n  - The tiddler also being deleted in any other open wikis\\n  - The corresponding .tid file being removed from the file system\\n  - The tiddler not being present when opening a new wiki\\n  - The tiddler not being present after stopping the node process and\\n    restarting it\\n7. Deleting a tiddler from the file system results in:\\n  - The tiddler also being deleted in any other open wikis\\n  - The corresponding .tid file being removed from the file system\\n  - The tiddler not being present when opening a new wiki\\n  - The tiddler not being present after stopping the node process and\\n    restarting it\\n8. Editing a tiddler in a browser:\\n  - Other browser tabs etc. with the wiki show the edit button locked for that\\n    tiddler while it is being edited\\n  - Changes to the tiddler appear almost immediately in other browser tabs\\n    after saving the changes to the tiddler.\\n  - Changes to the tiddler appear on the file system\\n9. Editing a tiddler on the file system:\\n  - The changes appear almost immediately in any connected browsers after the\\n    tiddler is saved\\n  - Adding one or more tags to a tid file that doesn't already have tags listed\\n    adds the tags to the tiddlers in already open wikis\\n  - Removing all tags from a tid file that has one or more tags removes the\\n    tags from open wikis\\n10. Renaming a tiddler in the browser:\\n  - Changes appear in other browser tabs\\n  - The old .tid file is gone, a new .tid file with the correct name for the\\n    new title is there\\n11. Renaming a tiddler on the file system (by changing the title field in the\\n    .tid file):\\n  - The file is deleted and a new file with the correct name for the new\\n    tiddler is created\\n  - The new tiddler is created in all connected wikis\\n  - The old tiddler is deleted from all connected wikis\\n  - Changes persist in newly opened wikis or reloaded wikis (both deleting the\\n    old title and creating the new one)\\n12. Importing tiddlers - TODO what do we test here?\\n13. Adding and removing tags\\n  - In browser and on the file system\\n\\n## Admin Tasks\\n\\n1. Settings can be modified and saved correctly\\n  - TODO How do we test this?\\n2. Resetting the wiki paths doesn't break anything\\n  - TODO how to test this?\\n\\n## Serving wikis\\n\\n1. The root wiki is served without errors\\n  - TODO\\n2. Child wikis are served without errors\\n  - TODO\\n3. Static files can be served when properly configured\\n  - TODO\\n\\nTODO - The rest\\n\\n## Creating new wikis\\n\\nTODO - This part\\n\\n## Syncing on Reconnect\\n\\n1. Browser->Server syncing\\n  - Disconnect from the server (stop the server process),\\n  - create a tiddler\\n  - delete a tiddler,\\n  - edit a tiddler,\\n  - rename a tiddler.\\n  - Restart the server and open the wiki in a new tab. Then reconnect the already open wiki to the server.\\n    - The created tiddler should now exist in the new wiki tab\\n    - The deleted tiddler should not exist in the new wiki tab\\n    - The edited tiddler should be changed in the new wiki tab\\n    - The renamed tiddler should be renamed in the new tab (old name should be deleted, new name should exist)\\n2. Server->Browser syncing\\n  - TODO this part\\n3. Conflicts should be properly shown\\n  - TODO this part\\n\\n## Loading and Unloading Wikis\\n\\n1. Load the root wiki and a child wiki in a browser then unload the child wiki.\\n  - The child wiki in the browser should show that it is disconnected\\n  - Reloading the wiki should work\\n2. Unload the root wiki from the root wiki\\n  - The wiki should show that it is disconnected\\n  - Reloading the wiki should work\\n3. Reconnecting should do something...\\n\\n## Logging\\n\\nDuring all of the above tests make sure that there aren't any left-over debug\\nmessages left in.\\n\",\n            \"type\": \"text/x-markdown\"\n        },\n        \"$:/plugins/OokTech/Bob/action-websocketmessage.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/action-websocketmessage.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/action-websocketmessage.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nAction widget to send a websocket message to the node process\\n\\n<$action-websocketmessage $type=type $param=value/>\\n\\nAny other key=value pairs will be added to the JSON message sent\\n\\nex:\\n\\n<$action-websocketmessage $type=git $param=pull branch=foo/>\\n\\nsends:\\n\\n{\\n  \\\"type\\\": \\\"git\\\",\\n  \\\"value\\\": \\\"pull\\\",\\n  \\\"branch\\\": foo\\n}\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nconst ActionWebSocketMessage = function(parseTreeNode,options) {\\n  this.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nActionWebSocketMessage.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nActionWebSocketMessage.prototype.render = function(parent,nextSibling) {\\n  this.computeAttributes();\\n  this.execute();\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nActionWebSocketMessage.prototype.execute = function() {\\n  this.type = this.getAttribute('$type', undefined);\\n  this.param = this.getAttribute('$param', undefined);\\n  this.tiddler = this.getAttribute('$tiddler', undefined);\\n};\\n\\n/*\\nRefresh the widget by ensuring our attributes are up to date\\n*/\\nActionWebSocketMessage.prototype.refresh = function(changedTiddlers) {\\n  const changedAttributes = this.computeAttributes();\\n  if(Object.keys(changedAttributes).length) {\\n    this.refreshSelf();\\n    return true;\\n  }\\n  return this.refreshChildren(changedTiddlers);\\n};\\n\\n/*\\nInvoke the action associated with this widget\\n*/\\nActionWebSocketMessage.prototype.invokeAction = function(triggeringWidget,event) {\\n  // Create the empty message object\\n  let message = {};\\n  // Add in the message type and param, if they exist\\n  message.type = this.type;\\n  message.param = this.param;\\n  if(this.tiddler) {\\n    message.tid_param = $tw.wiki.getTiddler(this.tiddler).fields;\\n  }\\n\\n  // This is needed for when you serve multiple wikis\\n  const wikiName = $tw.wiki.getTiddlerText(\\\"$:/WikiName\\\");\\n  message.wiki = wikiName?wikiName:'';\\n\\n  // For any other attributes passed to the widget add them to the message as\\n  // key: value pairs\\n  $tw.utils.each(this.attributes,function(attribute,name) {\\n    //if(name.charAt(0) !== \\\"$\\\") {\\n    if (['$type', '$param', '$tiddler'].indexOf(name) === -1) {\\n      message[name] = attribute;\\n    }\\n  });\\n  const token = localStorage.getItem('ws-token');\\n  message[\\\"token\\\"] = token;\\n  // We need a message type at a minimum to send anything\\n  if(message.type) {\\n    // Send the message\\n    $tw.Bob.Shared.sendMessage(message, 0)\\n  }\\n\\n  return true; // Action was invoked\\n};\\n\\nexports[\\\"action-websocketmessage\\\"] = ActionWebSocketMessage;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/OokTech/Bob/BrowserMessageHandlers.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/BrowserMessageHandlers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/BrowserMessageHandlers.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThis handles messages sent to the browser.\\n\\nThese are message handlers for messages sent to the browser. If you want to\\nadd more functions the easiest way is to use this file as a template and make a\\nnew file that adds the files you want. To do this you need should copy\\neverything until the line\\n\\n$tw.browserMessageHandlers = $tw.browserMessageHandlers || {};\\n\\nthis line makes sure that the object exists and doesn't overwrite what already\\nexists and it lets the files that define handlers be loaded in any order.\\n\\nRemember that the file has to end with\\n\\n})();\\n\\nto close the function that wraps the contents.\\nAlso change the title of the tiddler in the second line of the file, otherwise\\nit will overwrite this file.\\n\\\\*/\\n(function () {\\n\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  // Export name and synchronous status\\n  exports.name = \\\"web-sockets-setup\\\";\\n  exports.platforms = [\\\"browser\\\"];\\n  exports.after = [\\\"render\\\"];\\n  exports.synchronous = true;\\n\\n  // Polyfill because IE uses old javascript\\n  if(!String.prototype.startsWith) {\\n    String.prototype.startsWith = function(search, pos) {\\n      return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\\n    };\\n  }\\n\\n  $tw.browserMessageHandlers = $tw.browserMessageHandlers || {};\\n  $tw.Bob = $tw.Bob || {};\\n  $tw.Bob.MessageQueue = $tw.Bob.MessageQueue || [];\\n  $tw.connections = $tw.connections || [];\\n  $tw.Bob.Shared = require('$:/plugins/OokTech/Bob/SharedFunctions.js');\\n\\n  /*\\n    TODO - determine if we should sanitise the tiddler titles and field names\\n\\n    This message handler takes care of saveTiddler messages going to the\\n    browser.\\n    It creates a tiddler out of the supplied JSON object that lists the fields.\\n\\n    JSON structure of data (the function input):\\n    {\\n      \\\"fields\\\": {\\n        \\\"title\\\": \\\"Some title\\\",\\n        \\\"other\\\": \\\"field thingy\\\",\\n        \\\"text\\\": \\\"lots of text and stuff here because why not\\\"\\n      }\\n    }\\n  */\\n  $tw.browserMessageHandlers.saveTiddler = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    // Ignore the message if it isn't for this wiki\\n    if(data.wiki === $tw.wikiName) {\\n      if(data.tiddler) {\\n        // The title must exist and must be a string, everything else is optional\\n        if(data.tiddler.fields) {\\n          if(typeof data.tiddler.fields.title === 'string') {\\n            // if the tiddler exists already only update it if the update is\\n            // different than the existing one.\\n            const changed = $tw.Bob.Shared.TiddlerHasChanged(data.tiddler, $tw.wiki.getTiddler(data.tiddler.fields.title));\\n            if(changed) {\\n              $tw.wiki.addTiddler(new $tw.Tiddler(data.tiddler.fields));\\n            }\\n          } else {\\n            console.log('Invalid tiddler title');\\n          }\\n        } else {\\n          console.log(\\\"No tiddler fields given\\\");\\n        }\\n      } else {\\n        console.log('No tiddler')\\n      }\\n    }\\n  }\\n\\n  /*\\n    When the browser receives skinny tiddlers from the server dispatch the\\n    'skinny-tiddlers' event with the received tiddlers.\\n    It is handled by the syncadaptor.\\n  */\\n  $tw.browserMessageHandlers.skinnyTiddlers = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const skinnyTiddlers = new CustomEvent('skinny-tiddlers', {bubbles: true, detail: data.tiddlers || []})\\n    $tw.rootWidget.dispatchEvent(skinnyTiddlers)\\n  }\\n\\n  /*\\n    When the browser receive a loaded tiddler from the server dispatch the\\n    'loaded-tiddler' event with the received tiddler.\\n    It is handled by the syncadaptor.\\n  */\\n  $tw.browserMessageHandlers.loadTiddler = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const loadedTiddler = new CustomEvent('loaded-tiddler', {bubbles: true, detail: data.tiddler || {}})\\n    $tw.rootWidget.dispatchEvent(loadedTiddler)\\n  }\\n\\n  /*\\n    This is for updating the tiddlers currently being edited. It needs a\\n    special handler to support multi-wikis.\\n  */\\n  $tw.browserMessageHandlers.updateEditingTiddlers = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    // make sure there is actually a list sent\\n    if(data.list) {\\n        const listField = $tw.utils.stringifyList(data.list);\\n        // Make the tiddler fields\\n        const tiddlerFields = {\\n          title: \\\"$:/state/Bob/EditingTiddlers\\\",\\n          list: listField\\n        };\\n        // Add the tiddler\\n        $tw.wiki.addTiddler(new $tw.Tiddler(tiddlerFields));\\n    } else {\\n      console.log(\\\"No tiddler list given\\\", {level:2});\\n    }\\n  }\\n\\n  /*\\n    This message handles the deleteTiddler message for the browser. Note that\\n    this removes the tiddler from the wiki in the browser, but it does not\\n    delete the .tid file from the node server if you are running tiddlywiki in\\n    node. If you are running without node than this function is equavalient to\\n    deleting the tiddler.\\n  */\\n  $tw.browserMessageHandlers.deleteTiddler = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    if(data.wiki === $tw.wikiName) {\\n      data.tiddler = data.tiddler || {};\\n      data.tiddler.fields = data.tiddler.fields || {};\\n      const title = data.tiddler.fields.title;\\n      if(title) {\\n        $tw.wiki.deleteTiddler(title);\\n      }\\n    }\\n  }\\n\\n  /*\\n    This message asks the browser to send a list of all tiddlers back to the\\n    node process.\\n    This is useful for when you are trying to sync the browser and the file\\n    system or if you only want a sub-set of existing tiddlers in the browser.\\n  */\\n  $tw.browserMessageHandlers.listTiddlers = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    // This is an array of tiddler titles, each title is a string.\\n    const response = $tw.wiki.allTitles();\\n    // Send the response JSON as a string.\\n    const token = localStorage.getItem('ws-token')\\n    $tw.connections[0].socket.send(JSON.stringify({\\n      type: 'browserTiddlerList',\\n      titles: response,\\n      token: token,\\n      wiki: $tw.wiki.getTiddlerText('$:/WikiName')\\n    }));\\n  }\\n\\n  /*\\n    This message handles conflicts between the server and browser after\\n    reconnecting\\n\\n    It saves the server version under the normal title and saves the in-browser\\n    version with the prefix $:/state/Bob/Conflicts/\\n  */\\n  $tw.browserMessageHandlers.conflict = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    if(data.tiddler) {\\n      if(data.tiddler.fields) {\\n        data.tiddler.fields.created = $tw.utils.stringifyDate(new Date(data.tiddler.fields.created))\\n        data.tiddler.fields.modified = $tw.utils.stringifyDate(new Date(data.tiddler.fields.modified))\\n        let wikiTiddler = $tw.wiki.getTiddler(data.tiddler.fields.title);\\n        if(wikiTiddler) {\\n          wikiTiddler = JSON.parse(JSON.stringify(wikiTiddler));\\n          wikiTiddler.fields.modified = $tw.utils.stringifyDate(new Date(wikiTiddler.fields.modified))\\n          wikiTiddler.fields.created = $tw.utils.stringifyDate(new Date(wikiTiddler.fields.created))\\n          // Only add the tiddler if it is different\\n          if($tw.Bob.Shared.TiddlerHasChanged(data.tiddler, wikiTiddler)) {\\n            const newTitle = '$:/state/Bob/Conflicts/' + data.tiddler.fields.title;\\n            $tw.wiki.importTiddler(new $tw.Tiddler(wikiTiddler.fields, {title: newTitle}));\\n            // we have conflicts so open the conflict list tiddler\\n            let storyList = $tw.wiki.getTiddler('$:/StoryList').fields.list\\n            storyList = \\\"$:/plugins/Bob/ConflictList \\\" + $tw.utils.stringifyList(storyList)\\n            $tw.wiki.addTiddler({title: \\\"$:/StoryList\\\", text: \\\"\\\", list: storyList},$tw.wiki.getModificationFields());\\n          }\\n        } else {\\n          // If the tiddler doesn't actually have a conflicting version than\\n          // just add the tiddler.\\n          $tw.wiki.importTiddler(new $tw.Tiddler(data.tiddler.fields));\\n        }\\n      }\\n    }\\n  }\\n\\n  /*\\n    Import as a temporary tiddler so it can be saved or deleted by the person\\n    using the wiki\\n  */\\n  $tw.browserMessageHandlers.import = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    console.log('import', data.tiddler.fields.title, {level:2})\\n    data.tiddler.fields.created = $tw.utils.stringifyDate(new Date(data.tiddler.fields.created))\\n    data.tiddler.fields.modified = $tw.utils.stringifyDate(new Date(data.tiddler.fields.modified))\\n    const newTitle = '$:/state/Bob/Import/' + data.tiddler.fields.title;\\n    $tw.wiki.importTiddler(new $tw.Tiddler(data.tiddler.fields, {title: newTitle}));\\n    // we have conflicts so open the conflict list tiddler\\n    let storyList = $tw.wiki.getTiddler('$:/StoryList').fields.list\\n    storyList = \\\"$:/plugins/Bob/ImportList \\\" + $tw.utils.stringifyList(storyList)\\n    $tw.wiki.addTiddler({\\n      title: \\\"$:/StoryList\\\",\\n      text: \\\"\\\",\\n      list: storyList\\n    },$tw.wiki.getModificationFields());\\n  }\\n\\n  /*\\n    This handles a ping from the server. The server and browser make sure they\\n    are connected by sending pings periodically.\\n    The pong response also echos back whatever was sent along with the ping.\\n  */\\n  $tw.browserMessageHandlers.ping = function (data) {\\n    const token = localStorage.getItem('ws-token')\\n    let message = {};\\n    Object.keys(data).forEach(function (key) {\\n      message[key] = data[key];\\n    })\\n    message.type = 'pong';\\n    message.token = token;\\n    message.wiki = $tw.wikiName;\\n    // The message is just the message type\\n    const response = JSON.stringify(message);\\n    // Send the response\\n    $tw.connections[0].socket.send(response);\\n  }\\n\\n  /*\\n    This handles the pong response of a ping. It is also used as the heartbeat\\n    to ensure that the connection to the server is still live.\\n  */\\n  $tw.browserMessageHandlers.pong = function (data) {\\n    // If this pong is part of a heartbeat than use a setTimeout to send\\n    // another beat in the interval defined in $tw.settings.heartbeat.interval\\n    // the timeout id is stored in $tw.settings.heartbeat.timeoutid\\n    if(data.heartbeat) {\\n      if($tw.wiki.tiddlerExists('$:/plugins/OokTech/Bob/Server Warning')) {\\n        $tw.wiki.deleteTiddler('$:/plugins/OokTech/Bob/Server Warning');\\n      }\\n\\n      $tw.settings.heartbeat = $tw.settings.heartbeat || {};\\n\\n      if(!$tw.settings.heartbeat.interval) {\\n        const heartbeatTiddler = $tw.wiki.getTiddler(\\\"$:/WikiSettings/split/heartbeat\\\") || {fields:{text: \\\"{}\\\"}};\\n        const heartbeat = JSON.parse(heartbeatTiddler.fields.text) || {};\\n        $tw.settings.heartbeat[\\\"interval\\\"] = heartbeat.interval || 1000;\\n        $tw.settings.heartbeat[\\\"timeout\\\"] = heartbeat.timeout || 5000;\\n      }\\n      // Clear the time to live timeout.\\n      clearTimeout($tw.settings.heartbeat.TTLID);\\n      // Clear the retry timeout.\\n      clearTimeout($tw.settings.heartbeat.retry);\\n      setTimeout(function () {\\n        const token = localStorage.getItem('ws-token')\\n        $tw.connections[0].socket.send(JSON.stringify({\\n          type: 'ping',\\n          heartbeat: true,\\n          token: token,\\n          wiki: $tw.wikiName\\n        }));\\n      }, $tw.settings.heartbeat.interval);\\n      $tw.settings.heartbeat.TTLID = setTimeout(checkDisconnected, Number($tw.settings.heartbeat.timeout));\\n    }\\n  }\\n\\n  function checkDisconnected() {\\n    if($tw.connections[0].socket.readyState !== 1) {\\n      handleDisconnected();\\n    } else {\\n      const token = localStorage.getItem('ws-token')\\n      $tw.connections[0].socket.send(JSON.stringify({\\n        type: 'ping',\\n        heartbeat: true,\\n        token: token,\\n        wiki: $tw.wikiName\\n      }));\\n    }\\n  }\\n\\n  /*\\n    This is what happens when the browser detects that it isn't connected to\\n    the server anymore.\\n  */\\n  function handleDisconnected() {\\n    console.log('Disconnected from server', {level:0});\\n    const text = \\\"<div style='position:fixed;top:0px;width:100%;background-color:red;height:1.5em;max-height:100px;text-align:center;vertical-align:center;color:white;'>''WARNING: You are no longer connected to the server.''<$button style='color:black;'>Reconnect<$action-reconnectwebsocket/><$action-navigate $to='$:/plugins/Bob/ConflictList'/></$button></div>\\\";\\n    const tiddler = {\\n      title: '$:/plugins/OokTech/Bob/Server Warning',\\n      text: text,\\n      tags: '$:/tags/PageTemplate'\\n    };\\n    $tw.wiki.addTiddler(new $tw.Tiddler(tiddler));\\n    $tw.settings.heartbeat.retry = setInterval(function () {\\n      if($tw.connections[0].socket.readyState === 1) {\\n        const token = localStorage.getItem('ws-token')\\n        $tw.connections[0].socket.send(JSON.stringify({\\n          type: 'ping',\\n          heartbeat: true,\\n          token: token,\\n          wiki: $tw.wikiName\\n        }));\\n      }\\n    }, $tw.settings.heartbeat.interval);\\n    const tiddler2 = {\\n      title: '$:/plugins/OokTech/Bob/Unsent',\\n      text: JSON.stringify($tw.Bob.MessageQueue, '', 2),\\n      type: 'application/json',\\n      start: Date.now()-Number($tw.settings.heartbeat.timeout)\\n    };\\n    $tw.wiki.addTiddler(new $tw.Tiddler(tiddler2));\\n  }\\n\\n  /*\\n    Download the file in the message data\\n  */\\n  $tw.browserMessageHandlers.downloadFile = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    if(data) {\\n      const text = $tw.wiki.renderTiddler(\\\"text/plain\\\", \\\"$:/core/save/all\\\", {});\\n      let a = document.createElement('a');\\n      a.download = 'index.html';\\n      const thisStr = 'data:text/html;base64,'+window.btoa(unescape(encodeURIComponent(text)));\\n      a.setAttribute('href', thisStr);\\n      document.body.appendChild(a);\\n      a.click();\\n      document.body.removeChild(a);\\n    }\\n  }\\n\\n  /*\\n    Set the viewable wikis\\n  */\\n  $tw.browserMessageHandlers.setViewableWikis = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    if(data.list) {\\n      const fields = {\\n        title: '$:/state/ViewableWikis',\\n        list: data.list\\n      }\\n      $tw.wiki.addTiddler(new $tw.Tiddler(fields));\\n    }\\n  }\\n\\n  /*\\n    This takes an alert from the server and displays it in the browser.\\n    And appends it to a message history list.\\n  */\\n  $tw.browserMessageHandlers.browserAlert = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const serverMessagesTid = $tw.wiki.getTiddler('$:/settings/Bob/ServerMessageHistoryLimit');\\n    let hideAlerts = false;\\n    if(serverMessagesTid) {\\n      hideAlerts = serverMessagesTid.fields.hide_messages === 'true'?true:false;\\n    }\\n    if(!hideAlerts) {\\n      if(data.alert) {\\n        // Update the message history\\n        let tiddler = $tw.wiki.getTiddler('$:/Bob/AlertHistory');\\n        let tidObj = {\\n          title:'$:/Bob/AlertHistory',\\n          type:'application/json',\\n          text: '{}'\\n        };\\n        if(tiddler) {\\n          tidObj = JSON.parse(JSON.stringify(tiddler.fields))\\n        }\\n        const newNumber = Object.keys(JSON.parse(tidObj.text)).map(function(item) {\\n          return Number(item.replace(/^\\\\$:\\\\/temp\\\\/Server Alert /, ''))\\n        }).sort(function(a,b){return a-b}).slice(-1)[0] + 1 || 0;\\n        const AlertTitle = '$:/temp/Server Alert ' + newNumber;\\n        tidObj.text = JSON.parse(tidObj.text);\\n        tidObj.text[AlertTitle] = data.alert + ' - ' + $tw.utils.formatDateString(new Date(),\\\"0hh:0mm, 0DD/0MM/YY\\\");\\n        tidObj.text = JSON.stringify(tidObj.text);\\n        $tw.wiki.addTiddler(tidObj);\\n\\n        // Make a tiddler that has the tag $:/tags/Alert that has the text of\\n        // the alert.\\n        const fields = {\\n          component: 'Server Message',\\n          title: AlertTitle,\\n          text: data.alert+\\\"<br/><$button>Clear Alerts<$action-deletetiddler $filter='[tag[$:/tags/Alert]component[Server Message]]'/></$button>\\\",\\n          tags: '$:/tags/Alert'\\n        }\\n        $tw.wiki.addTiddler(new $tw.Tiddler(fields, $tw.wiki.getCreationFields()));\\n      }\\n    }\\n  }\\n\\n  /*\\n    This is used to update the current list of connections the server has to\\n    other servers\\n    These are used to pick which server to send messages to.\\n  */\\n  $tw.browserMessageHandlers.updateConnections = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    if (data.connections) {\\n      const fields = {\\n        title: '$:/Bob/ActiveConnections',\\n        list: $tw.utils.stringifyList(Object.keys(data.connections))\\n      };\\n      $tw.wiki.addTiddler(new $tw.Tiddler(fields));\\n      Object.keys(data.connections).forEach(function(connectionUrl) {\\n        if (data.connections[connectionUrl].name) {\\n          const connectionFields = {\\n            title: '$:/Bob/KnownServers/' + data.connections[connectionUrl].name,\\n            tags: '[[Remote Server]]',\\n            url: connectionUrl,\\n            staticurl: data.connections[connectionUrl].staticUrl,\\n            available_wikis: Object.keys(data.connections[connectionUrl].available_wikis).join(' '),\\n            available_chats: data.connections[connectionUrl].available_chats.join(' '),\\n            publickey: data.connections[connectionUrl].publicKey,\\n            allows_login: data.connections[connectionUrl].allows_login,\\n            name: data.connections[connectionUrl].name,\\n            local_name: data.connections[connectionUrl].local_name,\\n            active: data.connections[connectionUrl].active\\n          }\\n          $tw.wiki.addTiddler(new $tw.Tiddler(connectionFields));\\n          Object.keys(data.connections[connectionUrl].available_wikis).forEach(function(thisWikiName) {\\n            const theTid = $tw.wiki.getTiddler('$:/Bob/KnownServers/' + data.connections[connectionUrl].name + '/wikis/' + thisWikiName) || {fields: {}};\\n            $tw.wiki.addTiddler(new $tw.Tiddler({\\n              title: '$:/Bob/KnownServers/'+ data.connections[connectionUrl].name + '/wikis/' + thisWikiName,\\n              sync: data.connections[connectionUrl].available_wikis[thisWikiName].sync || 'no',\\n              sync_type: data.connections[connectionUrl].available_wikis[thisWikiName].sync_type || '',\\n              auto_sync: data.connections[connectionUrl].available_wikis[thisWikiName].auto_sync || 'no',\\n              sync_filter: data.connections[connectionUrl].available_wikis[thisWikiName].sync_filter || '',\\n              public: data.connections[connectionUrl].available_wikis[thisWikiName].public || 'yes',\\n              conflict_type: data.connections[connectionUrl].available_wikis[thisWikiName].conflict_type || 'manual',\\n              allows_login: data.connections[connectionUrl].available_wikis[thisWikiName].allows_login || 'no',\\n              name: thisWikiName,\\n              server_name: connectionUrl,\\n              local_name: data.connections[connectionUrl].available_wikis[thisWikiName].local_name,\\n              previous_sync: data.connections[connectionUrl].available_wikis[thisWikiName].previous_sync || 0\\n            }))\\n          })\\n          data.connections[connectionUrl].available_chats.forEach(function(thisChatName) {\\n            $tw.wiki.addTiddler(new $tw.Tiddler({\\n              title: '$:/Bob/KnownServers/' + data.connections[connectionUrl].name + '/chats/' + thisChatName,\\n              public: 'yes',\\n              relay: 'no',\\n              name: thisChatName\\n            }))\\n          })\\n        }\\n      })\\n    }\\n  }\\n\\n  /*\\n    For some messages we need an ack from the server to make sure that they\\n    were received correctly. This removes the messages from the queue after\\n    an ack is recevied.\\n  */\\n  $tw.browserMessageHandlers.ack = $tw.Bob.Shared.handleAck;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/NodeBasicHandlers.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/NodeBasicHandlers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/NodeBasicHandlers.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThese are message handler functions for the web socket servers. Use this file\\nas a template for extending the web socket funcitons.\\n\\nThis handles messages sent to the node process.\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.platforms = [\\\"node\\\"];\\n\\nif($tw.node) {\\n  $tw.nodeMessageHandlers = $tw.nodeMessageHandlers || {};\\n  $tw.Bob.Shared = require('$:/plugins/OokTech/Bob/SharedFunctions.js');\\n  /*\\n    This handles when the browser sends the list of all tiddlers that currently\\n    exist in the browser version of the wiki. This is different than the list of\\n    all tiddlers in files.\\n  */\\n  $tw.nodeMessageHandlers.browserTiddlerList = function(data) {\\n    // Save the list of tiddlers in the browser as part of the $tw object so it\\n    // can be used elsewhere.\\n    $tw.BrowserTiddlerList[data.source_connection] = data.titles;\\n    $tw.Bob.Shared.sendAck(data);\\n  }\\n\\n  /*\\n    For a lazily loaded wiki this gets the skinny tiddler list.\\n  */\\n  $tw.nodeMessageHandlers.getSkinnyTiddlers = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    // We need at least the name of the wiki\\n    if (data.wiki) {\\n      $tw.ServerSide.loadWiki(data.wiki);\\n      // Get the skinny tiddlers\\n      const tiddlers = []\\n      $tw.Bob.Wikis[data.wiki].wiki.allTitles().forEach(function(title) {\\n        if (title.slice(0,3) !== '$:/') {\\n          tiddlers.push($tw.Bob.Wikis[data.wiki].wiki.getTiddler(title).getFieldStrings({exclude:['text']}))\\n        }\\n      })\\n      const message = {\\n        type: 'skinnyTiddlers',\\n        tiddlers: tiddlers\\n      }\\n      $tw.Bob.Shared.sendMessage(message, data.source_connection)\\n    }\\n  }\\n\\n  /*\\n    For lazy loading this gets a full tiddler\\n  */\\n  $tw.nodeMessageHandlers.getFullTiddler = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    $tw.ServerSide.loadWiki(data.wiki);\\n    const tiddler = $tw.Bob.Wikis[data.wiki].wiki.getTiddler(data.title)\\n    const message = {\\n      type: 'loadTiddler',\\n      tiddler: tiddler || {}\\n    }\\n    $tw.Bob.Shared.sendMessage(message, data.source_connection)\\n  }\\n\\n  /*\\n    This responds to a ping from the browser. This is used to check and make sure\\n    that the browser and server are connected.\\n    It also echos back any data that was sent. This is used by the heartbeat to\\n    make sure that the server and browser are still connected.\\n  */\\n  $tw.nodeMessageHandlers.ping = function(data) {\\n    let message = {};\\n    Object.keys(data).forEach(function (key) {\\n      message[key] = data[key];\\n    })\\n    message.type = 'pong';\\n    if(data.heartbeat) {\\n      message.heartbeat = true;\\n    }\\n    // When the server receives a ping it sends back a pong.\\n    const response = JSON.stringify(message);\\n    $tw.connections[data.source_connection].socket.send(response);\\n  }\\n\\n  /*\\n    This handles saveTiddler messages sent from the browser.\\n\\n    If we always want to ignore draft tiddlers,\\n    use `[has[draft.of]]` in $:/plugins/OokTech/Bob/ExcludeSync\\n  */\\n  $tw.nodeMessageHandlers.saveTiddler = function(data) {\\n    // Acknowledge the message.\\n    $tw.Bob.Shared.sendAck(data);\\n    // Make sure there is actually a tiddler sent\\n    if(data.tiddler) {\\n      // Make sure that the tiddler that is sent has fields\\n      if(data.tiddler.fields) {\\n        const prefix = data.wiki || '';\\n        // Set the saved tiddler as no longer being edited. It isn't always\\n        // being edited but checking eacd time is more complex than just\\n        // always setting it this way and doesn't benifit us.\\n        $tw.nodeMessageHandlers.cancelEditingTiddler({\\n          tiddler:{\\n            fields:{\\n              title:data.tiddler.fields.title\\n            }\\n          },\\n          wiki: prefix\\n        });\\n        // If we are not expecting a save tiddler event than save the\\n        // tiddler normally.\\n        if(!$tw.Bob.Files[data.wiki][data.tiddler.fields.title]) {\\n          $tw.syncadaptor.saveTiddler(data.tiddler, prefix);\\n        } else {\\n          // If changed send tiddler\\n          let changed = true;\\n          try {\\n            let tiddlerObject = {}\\n            if(data.tiddler.fields._canonical_uri) {\\n              tiddlerObject = $tw.loadTiddlersFromFile($tw.Bob.Files[prefix][data.tiddler.fields.title].filepath+'.meta');\\n            } else {\\n              tiddlerObject = $tw.loadTiddlersFromFile($tw.Bob.Files[prefix][data.tiddler.fields.title].filepath);\\n            }\\n            // The file has the normal title so use the normal title here.\\n            changed = $tw.Bob.Shared.TiddlerHasChanged(data.tiddler, tiddlerObject);\\n          } catch (e) {\\n            $tw.Bob.logger.log('Save tiddler error: ', e, {level: 3});\\n          }\\n          if(changed) {\\n            $tw.syncadaptor.saveTiddler(data.tiddler, prefix);\\n            // Set the wiki as modified\\n            $tw.Bob.Wikis[prefix].modified = true;\\n          }\\n        }\\n        delete $tw.Bob.EditingTiddlers[data.wiki][data.tiddler.fields.title];\\n        $tw.Bob.UpdateEditingTiddlers(false, data.wiki);\\n      }\\n    }\\n  }\\n\\n  /*\\n    This is the handler for when the browser sends the deleteTiddler message.\\n  */\\n  $tw.nodeMessageHandlers.deleteTiddler = function(data) {\\n    // Acknowledge the message.\\n    $tw.Bob.Shared.sendAck(data);\\n    $tw.Bob.logger.log('Node Delete Tiddler', {level: 4});\\n    data.tiddler = data.tiddler || {};\\n    data.tiddler.fields = data.tiddler.fields || {};\\n    const title = data.tiddler.fields.title;\\n    if(title) {\\n      // Delete the tiddler file from the file system\\n      $tw.syncadaptor.deleteTiddler(title, {wiki: data.wiki});\\n      // Set the wiki as modified\\n      $tw.Bob.Wikis[data.wiki].modified = true;\\n      // Remove the tiddler from the list of tiddlers being edited.\\n      if($tw.Bob.EditingTiddlers[data.wiki][title]) {\\n        delete $tw.Bob.EditingTiddlers[data.wiki][title];\\n        $tw.Bob.UpdateEditingTiddlers(false, data.wiki);\\n      }\\n      $tw.Bob.logger.log('Deleted tiddler', data.tiddler.fields.title)\\n    }\\n  }\\n\\n  /*\\n    This is the handler for when a browser sends the editingTiddler message.\\n  */\\n  $tw.nodeMessageHandlers.editingTiddler = function(data) {\\n    // Acknowledge the message.\\n    $tw.Bob.Shared.sendAck(data);\\n    data.tiddler = data.tiddler || {};\\n    data.tiddler.fields = data.tiddler.fields || {};\\n    const title = data.tiddler.fields.title;\\n    if(title) {\\n      // Add the tiddler to the list of tiddlers being edited to prevent\\n      // multiple people from editing it at the same time.\\n      $tw.Bob.UpdateEditingTiddlers(title, data.wiki);\\n    }\\n  }\\n\\n  /*\\n    This is the handler for when a browser stops editing a tiddler.\\n  */\\n  $tw.nodeMessageHandlers.cancelEditingTiddler = function(data) {\\n    // Acknowledge the message.\\n    $tw.Bob.Shared.sendAck(data);\\n    data.tiddler = data.tiddler || {};\\n    data.tiddler.fields = data.tiddler.fields || {};\\n    let title = data.tiddler.fields.title;\\n    if(title) {\\n      // Make sure that the tiddler title is a string\\n      if(data.tiddler.fields[\\\"draft.of\\\"]) {\\n        title = data.tiddler.fields[\\\"draft.of\\\"]\\n      }\\n      // Remove the current tiddler from the list of tiddlers being edited.\\n      if($tw.Bob.EditingTiddlers[data.wiki][title]) {\\n        delete $tw.Bob.EditingTiddlers[data.wiki][title];\\n      }\\n      $tw.Bob.UpdateEditingTiddlers(false, data.wiki);\\n    }\\n  }\\n\\n  /*\\n    This updates what wikis are being served and where they are being served\\n  */\\n  $tw.nodeMessageHandlers.updateRoutes = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    // This is only usable on the root wiki!\\n    if(data.wiki === 'RootWiki' || true) {\\n      // Then clear all the routes to the non-root wiki\\n      $tw.httpServer.clearRoutes();\\n      // The re-add all the routes from the settings\\n      // This reads the settings so we don't need to give it any arguments\\n      $tw.httpServer.addOtherRoutes();\\n    }\\n  }\\n\\n  /*\\n    This sends back a list of all wikis that are viewable using the current access token.\\n  */\\n  $tw.nodeMessageHandlers.getViewableWikiList = function (data) {\\n    data = data || {};\\n    $tw.Bob.Shared.sendAck(data);\\n    const viewableWikis = $tw.ServerSide.getViewableWikiList(data);\\n    // Send viewableWikis back to the browser\\n    const message = {\\n      type: 'setViewableWikis',\\n      list: $tw.utils.stringifyList(viewableWikis),\\n      wiki: data.wiki\\n  };\\n    $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n  }\\n\\n  /*\\n    This looks in the wikis folder set in the configuration\\n    $tw.setting.wikisPath\\n    If none is set it uses ./Wikis\\n\\n    This walks though subfolders too.\\n  */\\n  $tw.nodeMessageHandlers.findAvailableWikis = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    // This gets the paths of all wikis listed in the settings\\n    function getWikiPaths(settingsObject) {\\n      const paths = Object.values(settingsObject);\\n      let outPaths = [];\\n      paths.forEach(function(thisPath) {\\n        if(typeof thisPath === 'object') {\\n          outPaths = outPaths.concat(getWikiPaths(thisPath));\\n        } else {\\n          outPaths.push(path.resolve(basePath, $tw.settings.wikisPath, thisPath));\\n        }\\n      })\\n      return outPaths\\n    }\\n    // This gets a list of all wikis in the wikis folder and subfolders\\n    function getRealPaths(startPath) {\\n      // Check each folder in the wikis folder to see if it has a\\n      // tiddlywiki.info file\\n      let realFolders = [];\\n      try {\\n        const folderContents = fs.readdirSync(startPath);\\n        folderContents.forEach(function (item) {\\n          const fullName = path.join(startPath, item);\\n          if(fs.statSync(fullName).isDirectory()) {\\n            if($tw.ServerSide.wikiExists(fullName)) {\\n              realFolders.push(fullName);\\n            }\\n            // Check if there are subfolders that contain wikis and recurse\\n            const nextPath = path.join(startPath,item)\\n            if(fs.statSync(nextPath).isDirectory()) {\\n              realFolders = realFolders.concat(getRealPaths(nextPath));\\n            }\\n          }\\n        })\\n      } catch (e) {\\n        const message = {\\n          alert: 'Error getting wiki paths: ' + e,\\n          connections: [data.source_connection]\\n        };\\n        $tw.ServerSide.sendBrowserAlert(message);\\n        $tw.Bob.logger.log('Error getting wiki paths', e, {level:1});\\n      }\\n      return realFolders;\\n    }\\n    // This takes the list of wikis in the settings and returns a new object\\n    // without any of the non-existent wikis listed\\n    function pruneWikiList(dontExistList, settingsObj) {\\n      let prunedSettings = {};\\n      Object.keys(settingsObj).forEach(function(wikiName) {\\n        if(typeof settingsObj[wikiName] === 'string') {\\n          // Check if the wikiName resolves to one of the things to remove\\n          if(dontExistList.indexOf(path.resolve(wikiFolderPath, settingsObj[wikiName])) === -1) {\\n            // If the wiki isn't listed as not existing add it to the prunedSettings\\n            prunedSettings[wikiName] = settingsObj[wikiName];\\n          }\\n        } else if(typeof settingsObj[wikiName] === 'object') {\\n          if(Object.keys(settingsObj[wikiName]).length > 0) {\\n            prunedSettings[wikiName] = pruneWikiList(dontExistList, settingsObj[wikiName])\\n          }\\n        }\\n      })\\n      return prunedSettings\\n    }\\n    const fs = require('fs');\\n    const path = require('path');\\n    const basePath = $tw.ServerSide.getBasePath()\\n    $tw.settings.wikisPath = $tw.settings.wikisPath || './Wikis';\\n    let wikiFolderPath = path.resolve(basePath, $tw.settings.wikisPath);\\n    // Make sure that the wikiFolderPath exists\\n    const error = $tw.utils.createDirectory(path.resolve(basePath, $tw.settings.wikisPath));\\n    // Check each folder in the wikis folder to see if it has a tiddlywiki.info\\n    // file.\\n    // If there is no tiddlywiki.info file it checks sub-folders.\\n    const realFolders = getRealPaths(wikiFolderPath);\\n    // If it does check to see if any listed wiki has the same path, if so skip\\n    // it\\n    let alreadyListed = [];\\n    const listedWikis = getWikiPaths($tw.settings.wikis);\\n    realFolders.forEach(function(folder) {\\n      // Check is the wiki is listed\\n      if(listedWikis.indexOf(folder) > -1) {\\n        alreadyListed.push(folder);\\n      }\\n    })\\n    let wikisToAdd = realFolders.filter(function(folder) {\\n      return alreadyListed.indexOf(folder) === -1;\\n    })\\n    wikisToAdd = wikisToAdd.map(function(thisPath) {\\n      return path.relative(wikiFolderPath,thisPath);\\n    })\\n    const dontExist = listedWikis.filter(function(folder) {\\n      return !$tw.ServerSide.wikiExists(folder);\\n    })\\n    data.update = data.update || ''\\n    if(typeof data.update !== 'string') {\\n      data.update = (data.update === true)?'true':''\\n    }\\n    if(data.update.toLowerCase() === 'true') {\\n      wikisToAdd.forEach(function (wikiName) {\\n        const nameParts = wikiName.split('/');\\n        let settingsObj = $tw.settings.wikis;\\n        let i;\\n        for (i = 0; i < nameParts.length; i++) {\\n          if(typeof settingsObj[nameParts[i]] === 'object' && i < nameParts.length - 1) {\\n            settingsObj = settingsObj[nameParts[i]];\\n          } else if(i < nameParts.length - 1) {\\n            settingsObj[nameParts[i]] = settingsObj[nameParts[i]] || {};\\n            settingsObj = settingsObj[nameParts[i]]\\n          } else {\\n            settingsObj[nameParts[i]] = settingsObj[nameParts[i]] || {};\\n            settingsObj[nameParts[i]].__path = nameParts.join('/');\\n          }\\n        }\\n      })\\n    }\\n    if(typeof data.remove !== 'string') {\\n      data.remove = (data.remove === false)?'false':'true'\\n    }\\n    if(data.remove.toLowerCase() === 'true') {\\n      // update the wikis listing in the settings with a version that doesn't\\n      // have the wikis that don't exist.\\n      $tw.settings.wikis = pruneWikiList(dontExist, $tw.settings.wikis);\\n    }\\n    // Save the new settings, update routes, update settings tiddlers in the\\n    // browser and update the list of available wikis\\n    if(data.saveSettings) {\\n      data.fromServer = true;\\n      $tw.nodeMessageHandlers.saveSettings(data);\\n      $tw.nodeMessageHandlers.updateRoutes(data);\\n      setTimeout($tw.nodeMessageHandlers.getViewableWikiList,1000,data)\\n    }\\n  }\\n\\n  /*\\n    This handles ack messages.\\n  */\\n  $tw.nodeMessageHandlers.ack = $tw.Bob.Shared.handleAck;\\n\\n}\\n})();\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/NodeMessageHandlers.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/NodeMessageHandlers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/NodeMessageHandlers.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThese are message handler functions for the web socket servers. Use this file\\nas a template for extending the web socket funcitons.\\n\\nThis handles messages sent to the node process.\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.platforms = [\\\"node\\\"];\\n\\nif($tw.node) {\\n  $tw.connections = $tw.connections || [];\\n  $tw.Bob = $tw.Bob || {};\\n  $tw.Bob.Files = $tw.Bob.Files || {};\\n  $tw.Bob.Shared = require('$:/plugins/OokTech/Bob/SharedFunctions.js');\\n  // This lets you add to the $tw.nodeMessageHandlers object without overwriting\\n  // existing handler functions\\n  $tw.nodeMessageHandlers = $tw.nodeMessageHandlers || {};\\n  // Ensure that the browser tiddler list object exists without overwriting an\\n  // existing copy.\\n  $tw.BrowserTiddlerList = $tw.BrowserTiddlerList || {};\\n\\n  /*\\n    This is just a test function to make sure that everthing is working.\\n    It displays the contents of the received data in the console.\\n  */\\n  $tw.nodeMessageHandlers.test = function(data) {\\n    $tw.Bob.logger.log(data, {level:0});\\n  }\\n}\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/NodeScriptHandlers.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/NodeScriptHandlers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/NodeScriptHandlers.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThese are message handler functions for the web socket servers. Use this file\\nas a template for extending the web socket funcitons.\\n\\nThis handles messages sent to the node process.\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.platforms = [\\\"node\\\"];\\n\\nif($tw.node) {\\n  $tw.nodeMessageHandlers = $tw.nodeMessageHandlers || {};\\n  /*\\n    This message lets you run a script defined in the settings.json file.\\n    You name and define the script there and then you can run it using this.\\n\\n    The script must be listed in the settings. You send the script name with the\\n    message and then it takes the information for it from the settings file.\\n\\n    settings file entries should be like this:\\n\\n    \\\"name\\\": \\\"somecommand argument argument\\\"\\n\\n    it would be easiest to write a script and then just call the script using\\n    this.\\n\\n    If sequential is set to true than each script will only run after the\\n    previous script has finished in the order they are received.\\n    It is possible to run non-sequential scripts and sequential scripts\\n    simultaneously.\\n  */\\n  // This holds\\n  let scriptQueue = {};\\n  let scriptActive = {};\\n  let childproc = false;\\n  // This function checks if a script is currently running, if not it runs the\\n  // next script in the queue.\\n  function processScriptQueue (queue) {\\n    if(!scriptActive[queue] && scriptQueue[queue].length > 0) {\\n      childproc = require('child_process').spawn(scriptQueue[queue][0].command, scriptQueue[queue][0].args, scriptQueue[queue][0].options);\\n      scriptActive[queue] = true;\\n      childproc.on('error', function (err) {\\n        clearQueue(queue);\\n        $tw.Bob.logger.log('Script error: ', err, {level:1});\\n      })\\n      childproc.on('exit', function () {\\n        // Remove the finished task from the queue\\n        if(scriptQueue[queue].length > 0) {\\n          scriptQueue[queue].shift();\\n        }\\n        // Set the queue as inactive\\n        scriptActive[queue] = false;\\n        // Process the next task in the queue, if any.\\n        processScriptQueue(queue);\\n      });\\n    }\\n  }\\n  function clearQueue (queue) {\\n    scriptQueue[queue] = [];\\n    if(scriptActive[queue]) {\\n      childproc.kill('SIGINT');\\n    }\\n  }\\n  $tw.nodeMessageHandlers.runScript = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const path = require('path');\\n    if(data.name) {\\n      if($tw.settings.scripts) {\\n        if($tw.settings.scripts[data.name]) {\\n          if(typeof $tw.settings.scripts[data.name] === 'string') {\\n            let splitThing = $tw.settings.scripts[data.name].split(\\\" \\\");\\n            const command = splitThing.shift(),\\n            args = splitThing || [],\\n            options = {\\n              //cwd: path.dirname(process.argv[0]),//process.cwd(),\\n              cwd: path.parse(process.argv[0]).name === 'node' ? path.dirname(process.argv[0]) : process.cwd(),\\n              detached: false,\\n              stdio: \\\"inherit\\\"\\n            };\\n            // If a command has an item that matches a property in the input\\n            // object than replace it with the value from the input object.\\n            Object.keys(data).forEach(function(item) {\\n              const index = args.indexOf(item);\\n              if(index !== -1) {\\n                args[index] = data[item];\\n              }\\n            });\\n            if(data.sequential) {\\n              data.queue = data.queue || 0;\\n              scriptActive[data.queue] = scriptActive[data.queue] || false;\\n              scriptQueue[data.queue] = scriptQueue[data.queue] || [];\\n              // Add the current script to the queue\\n              scriptQueue[data.queue].push({command: command, args: args, options: options, queue: data.queue});\\n              // Process the queue to run a command\\n              processScriptQueue(data.queue);\\n            } else {\\n              childproc = require('child_process').spawn(command, args, options);\\n              childproc.on('error', function (err) {\\n                const message = {\\n                  alert: 'Script error: ' + err,\\n                  connections: [data.source_connection]\\n                };\\n                $tw.ServerSide.sendBrowserAlert(message);\\n                $tw.Bob.logger.log('Script error: ', err, {level:1});\\n              })\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n  // Stop any currently running script queues\\n  $tw.nodeMessageHandlers.stopScripts = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    data.queue = data.queue || 0;\\n    clearQueue(data.queue);\\n    const message = {\\n      alert: 'Stopped all running scripts.',\\n      wikis: [data.wiki]\\n    };\\n    $tw.ServerSide.sendBrowserAlert(message);\\n  }\\n\\n}\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/NodeServerHandlers.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/NodeServerHandlers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/NodeServerHandlers.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThese are message handler functions for the web socket servers. Use this file\\nas a template for extending the web socket funcitons.\\n\\nThis handles messages sent to the node process.\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.platforms = [\\\"node\\\"];\\n\\nif($tw.node) {\\n  $tw.nodeMessageHandlers = $tw.nodeMessageHandlers || {};\\n  $tw.Bob.Federation = $tw.Bob.Federation || {};\\n  $tw.Bob.Federation.remoteConnections = $tw.Bob.Federation.remoteConnections || {};\\n\\n  $tw.nodeMessageHandlers.openRemoteConnection = function(data) {\\n    $tw.Bob.logger.log('openRemoteConnection', data, {level: 3})\\n    $tw.Bob.Shared.sendAck(data);\\n    if(data.url) {\\n      function authenticateMessage() {\\n        return true\\n      }\\n      function openRemoteSocket() {\\n        $tw.settings.federation = $tw.settings.federation || {};\\n        const serverName = $tw.settings.federation.serverName || 'Noh Neigh-m';\\n        const serverFederationInfo = {\\n          type: 'requestServerInfo',\\n          info: {\\n            name: serverName,\\n            publicKey: 'c minor',\\n            allows_login: 'no',\\n            available_wikis: $tw.ServerSide.getViewableWikiList(),\\n            available_chats: [],\\n            staticUrl: 'no',\\n            port: $tw.settings['ws-server'].port\\n          }\\n        }\\n        $tw.Bob.logger.log('REMOTE SOCKET OPENED', data.url, {level: 4})\\n        $tw.Bob.Federation.sendToRemoteServer(serverFederationInfo, data.url)\\n        $tw.Bob.Federation.sendToRemoteServer({type:'requestServerInfo', port:$tw.settings['ws-server'].port}, data.url)\\n        $tw.Bob.Federation.updateConnections()\\n      }\\n      // Check to make sure that we don't already have a connection to the\\n      // remote server\\n      // If the socket is closed than reconnect\\n      const remoteSocketAddress = data.url.startsWith('ws://')?data.url:'ws://'+data.url+'/api/federation/socket'\\n      const WebSocket = require('$:/plugins/OokTech/Bob/External/WS/ws.js');\\n      if(Object.keys($tw.Bob.Federation.remoteConnections).indexOf(data.url) === -1 || $tw.Bob.Federation.remoteConnections[data.url].socket.readyState === WebSocket.OPEN) {\\n        try {\\n          $tw.Bob.Federation.remoteConnections[data.url] = {}\\n          $tw.Bob.Federation.remoteConnections[data.url].socket = new WebSocket(remoteSocketAddress)\\n          /* TODO make the openRemoteSocket function authenticate the connection and destroy it if it fails authentication */\\n          $tw.Bob.Federation.remoteConnections[data.url].socket.on('open', openRemoteSocket)\\n          $tw.Bob.Federation.remoteConnections[data.url].socket.on('message', $tw.Bob.Federation.handleMessage)\\n          /* TODO\\n            add a readable name and something for a key here so that a server\\n            can change it's url and maintain the same name across different\\n            sessions\\n\\n            Add an on open function that alerts the browsers that the\\n            connection has been made\\n\\n            Add the on message handlers\\n          */\\n        } catch (e) {\\n          $tw.Bob.logger.error('error opening federated connection ', e, {level: 2})\\n        }\\n      } else {\\n        $tw.Bob.logger.log('A connection already exists to ', data.url, {level: 3})\\n      }\\n    }\\n  }\\n\\n  /*\\n    This sends a websocket message to a remote server.\\n\\n    data = {\\n      $server: the server url (or human readable name? It has to be unique),\\n      $message: the message type\\n      otherThings: data to pass on to the other server as parameters of the message being sent.\\n    }\\n  */\\n  $tw.nodeMessageHandlers.sendRemoteMessage = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    if (data.$server && data.$message) {\\n      const newData = {\\n        type: data.$message\\n      }\\n      Object.keys(data).forEach(function(key) {\\n        if (['type', '$server', '$message', 'wiki'].indexOf(key) === -1) {\\n          newData[key] = data[key]\\n        }\\n      })\\n      // TODO here we need to get the server info from the server name in data.$server\\n      // We need to get the target server port and address using data.$server and then use that to send.\\n      const serverInfo = {\\n        port: $tw.Bob.Federation.connections[data.$server].port,\\n        address: $tw.Bob.Federation.connections[data.$server].address\\n      }\\n      $tw.Bob.logger.log('send remote message:', newData, {level: 4})\\n      $tw.Bob.logger.log('send message to:', serverInfo, {level: 4})\\n      $tw.Bob.Federation.sendToRemoteServer(JSON.stringify(newData), serverInfo, data.wiki)\\n    }\\n  }\\n\\n  /*\\n    Update information about a federated connection and syncing wikis on the\\n    server.\\n\\n    To do this the tiddler that has the information about the connection gets\\n    sent with the message and it is parsed here.\\n  */\\n  $tw.nodeMessageHandlers.updateFederatedConnectionInfo = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    if(data.tid_param) {\\n      $tw.Bob.Federation.connections[data.tid_param.server_name].available_wikis[data.tid_param.name] = $tw.Bob.Federation.connections[data.tid_param.server_name].available_wikis[data.tid_param.name] || {};\\n      // $tw.Bob.Federation.connections[data.tid_param.server_name].availableWikis[data.tid_param.name] = $tw.Bob.Federation.connections[data.tid_param.server_name].availableWikis[data.tid_param.name] || {};\\n      $tw.Bob.Federation.connections[data.tid_param.server_name].available_wikis[data.tid_param.name].allows_login = data.tid_param.allows_login;\\n      $tw.Bob.Federation.connections[data.tid_param.server_name].available_wikis[data.tid_param.name].auto_sync = data.tid_param.auto_sync;\\n      $tw.Bob.Federation.connections[data.tid_param.server_name].available_wikis[data.tid_param.name].conflict_type = data.tid_param.conflict_type;\\n      $tw.Bob.Federation.connections[data.tid_param.server_name].available_wikis[data.tid_param.name].public = data.tid_param.public;\\n      $tw.Bob.Federation.connections[data.tid_param.server_name].available_wikis[data.tid_param.name].sync = data.tid_param.sync;\\n      $tw.Bob.Federation.connections[data.tid_param.server_name].available_wikis[data.tid_param.name].sync_filter = data.tid_param.sync_filter;\\n      $tw.Bob.Federation.connections[data.tid_param.server_name].available_wikis[data.tid_param.name].sync_type = data.tid_param.sync_type;\\n      $tw.Bob.Federation.connections[data.tid_param.server_name].available_wikis[data.tid_param.name].local_name = data.tid_param.local_name;\\n      $tw.Bob.Federation.updateConnectionsInfo();\\n    }\\n  }\\n\\n  /*\\n    This lets us shutdown the server from within the wiki.\\n  */\\n  $tw.nodeMessageHandlers.shutdownServer = function(data) {\\n    $tw.Bob.logger.log('Shutting down server.', {level:0});\\n    // TODO figure out if there are any cleanup tasks we should do here.\\n    // Sennd message to parent saying server is shutting down\\n    $tw.Bob.Shared.sendAck(data);\\n    process.exit();\\n  }\\n\\n  /*\\n    This sets up the logged in status of a wiki\\n\\n    It needs to:\\n\\n    - start the heartbeat process\\n    - populate the list of viewable wikis\\n    - add any configuration interface things\\n  */\\n  $tw.nodeMessageHandlers.setLoggedIn = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    // Heartbeat. This can be done if the heartbeat is started or not because\\n    // if an extra heartbeat pong is heard it just shifts the timing.\\n    let message = {};\\n    message.type = 'pong';\\n    if(data.heartbeat) {\\n      message.heartbeat = true;\\n    }\\n    // When the server receives a ping it sends back a pong.\\n    const response = JSON.stringify(message);\\n    $tw.connections[data.source_connection].socket.send(response);\\n\\n    // Populating the wiki list uses the same stuff as the other message.\\n    $tw.nodeMessageHandlers.getViewableWikiList(data);\\n\\n    // Add configuration stuff\\n    $tw.nodeMessageHandlers.setConfigurationInterface(data);\\n  }\\n\\n  /*\\n    This uses the token to determine which configuration options should be\\n    visible on the wiki and sends the appropriate tiddlers\\n  */\\n  $tw.nodeMessageHandlers.setConfigurationInterface = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    // I need to figure out what to put here\\n    const fields = {\\n      title: '$:/Bob/VisibleConfigurationTabs',\\n      list: \\\"hi\\\"\\n    }\\n    const tiddler = {fields: fields}\\n    const message = {type: 'saveTiddler', tiddler: tiddler, wiki: data.wiki}\\n    $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message)\\n    $tw.CreateSettingsTiddlers(data);\\n  }\\n\\n  /*\\n    This only really matters in the secure wiki server for now\\n    public - true or false to set the wiki as public or not\\n    viewers - the list of people who can view the wiki\\n    editors - the list of people who can edit the wiki\\n  */\\n  $tw.nodeMessageHandlers.setWikiPermissions = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    // If the person doing this is owner of the wiki they can continue\\n    if($tw.ExternalServer) {\\n      $tw.ExternalServer.updatePermissions(data);\\n    }\\n  }\\n\\n  /*\\n    This is for resyncing with a wiki that was disconnected and has reconnected\\n    The data object should have the form:\\n    {\\n      type: 'syncChanges',\\n      since: startTime,\\n      changes: messageQueue,\\n      wiki: wikiName,\\n      token: token,\\n      id: messageID,\\n      source_connection: connectionIndex\\n    }\\n\\n    This misses any changes that happened to the server since it was started\\n    this time. So if there are changes to the server after it is disconnected\\n    and then the server is reset none of those changes are synced.\\n\\n    How do we do a test to figure out if anything has changed on the server?\\n    Comparing hashes of tiddlers may work.\\n    We could send an object that has the tiddler names as keys and a hash of\\n    the contets that can be checked against the server version.\\n    This may give different results for windows and linux because of the NLCR\\n    thing.\\n    We would need a computationally inexpensive hashing algorithm, I think that\\n    there are plenty of them.\\n\\n    For now we can send a list of tiddlers in the browser and any on the server\\n    that aren't listed need to be sent.\\n  */\\n  $tw.nodeMessageHandlers.syncChanges = function(data) {\\n    // Acknowledge the message.\\n    $tw.Bob.Shared.sendAck(data);\\n    // Make sure that the wiki that the syncing is for is actually loaded\\n    // TODO make sure that this works for wikis that are under multiple levels\\n    $tw.ServerSide.loadWiki(data.wiki);\\n    // Make sure that the server history exists\\n    $tw.Bob.ServerHistory = $tw.Bob.ServerHistory || {};\\n    $tw.Bob.ServerHistory[data.wiki] = $tw.Bob.ServerHistory[data.wiki] || [];\\n    // Get the received message queue\\n    let queue = [];\\n    try {\\n      queue = JSON.parse(data.changes);\\n    } catch (e) {\\n      const message = {\\n        alert: 'Can\\\\'t parse changes from the server!',\\n        connections: [data.source_connection]\\n      };\\n      $tw.ServerSide.sendBrowserAlert(message);\\n      $tw.Bob.logger.error(\\\"Can't parse server changes!!\\\", {level:1});\\n    }\\n    // Only look at changes more recent than when the browser disconnected\\n    const recentServer = $tw.Bob.ServerHistory[data.wiki].filter(function(entry) {\\n      return entry.timestamp > data.since;\\n    })\\n    let conflicts = [];\\n    // Iterate through the received queue\\n    queue.forEach(function(messageData) {\\n      // Find the serverEntry for the tiddler the current message is for, if\\n      // any.\\n      const serverEntry = recentServer.find(function(entry) {\\n        return entry.title === messageData.title\\n      })\\n      // If the tiddler has an entry check if it is a conflict.\\n      // Both deleting the tiddler is not a conflict, both saving the same\\n      // changes is not a conflict, otherwise it is.\\n      if(serverEntry) {\\n        if(messageData.type !== serverEntry.type) {\\n          // Different message types between server and browser => conflict\\n          conflicts.push(messageData.title);\\n        } else if(messageData.type === 'saveTiddler' && serverEntry.type === 'saveTiddler') {\\n          // Server and browser are both save => conflict if the two tiddlers\\n          // aren't the same.\\n          let tempTid = JSON.parse(JSON.stringify(messageData.message.tiddler));\\n          tempTid.fields.title = messageData.title;\\n          tempTid.hash = messageData.hash;\\n          const serverTiddler = $tw.Bob.Wikis[data.wiki].wiki.getTiddler(tempTid.fields.title);\\n          if($tw.Bob.Shared.TiddlerHasChanged(serverTiddler, tempTid)) {\\n            conflicts.push(messageData.title);\\n          }\\n        }\\n      }\\n    });\\n    // Take care of all the messages that aren't conflicting\\n    // First from the received queue\\n    queue.forEach(function(messageData){\\n      if(conflicts.indexOf(messageData.title) === -1) {\\n        // Send the message to the handler with the appropriate setup\\n        $tw.Bob.handleMessage.call($tw.connections[data.source_connection].socket, JSON.stringify(messageData.message));\\n      }\\n    });\\n    // Then from the server side\\n    recentServer.forEach(function(messageData) {\\n      if(conflicts.indexOf(messageData.title) === -1) {\\n        let message = {type: messageData.type, wiki: data.wiki}\\n        let tiddler\\n        if(messageData.type === 'saveTiddler') {\\n          const longTitle = messageData.title;\\n          const tempTid = $tw.Bob.Wikis[data.wiki].wiki.getTiddler(longTitle);\\n          if(typeof tempTid === 'object') {\\n            tiddler = JSON.parse(JSON.stringify(tempTid));\\n            tiddler.fields.title = messageData.title;\\n            // Making the copy above does something that breaks the date fields\\n            if(tempTid.fields.created) {\\n              tiddler.fields.created = $tw.utils.stringifyDate(tempTid.fields.created);\\n            }\\n            if(tempTid.fields.modified) {\\n              tiddler.fields.modified = $tw.utils.stringifyDate(tempTid.fields.modified);\\n            }\\n          }\\n        } else {\\n          tiddler = {fields:{title:messageData.title}}\\n        }\\n        message.tiddler = tiddler;\\n        if(typeof tiddler === 'object') {\\n          $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message)\\n        }\\n      }\\n    });\\n    // Then do something with the conflicts\\n    // I think that we need a new message, something like 'conflictingEdits'\\n    // that sends the tiddler info from the server to the browser and the\\n    // browser takes care of the rest.\\n    conflicts.forEach(function(title) {\\n      const serverEntry = recentServer.find(function(entry) {\\n        return entry.title === title;\\n      });\\n      if(serverEntry) {\\n        let message = {};\\n        if(serverEntry.type === 'saveTiddler') {\\n          const longTitle = serverEntry.title;\\n          const tiddler = $tw.Bob.Wikis[data.wiki].wiki.getTiddler(longTitle);\\n          message = {\\n            type: 'conflict',\\n            message: 'saveTiddler',\\n            tiddler: tiddler,\\n            wiki: data.wiki\\n          };\\n        } else if(serverEntry.type === 'deleteTiddler') {\\n          message = {\\n            type: 'conflict',\\n            message: 'deleteTiddler',\\n            tiddler: {\\n              fields:{\\n                title:serverEntry.title\\n              }\\n            },\\n            wiki: data.wiki\\n          };\\n        }\\n        if(message) {\\n          $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n        }\\n      }\\n    })\\n    // There aren't any changes in the browser that aren't synced at this\\n    // point, so find any changes on the server that aren't in the browser and\\n    // send them to the browser.\\n    const serverTiddlerList = $tw.Bob.Wikis[data.wiki].wiki.allTitles();\\n    const browserChangedTitles = queue.filter(function(messageData) {\\n      return messageData.type === 'saveTiddler'\\n    }).map(function(messageData) {\\n      return messageData.title\\n    })\\n    const excludeFilter = $tw.Bob.Wikis[data.wiki].wiki.getTiddler('$:/plugins/OokTech/Bob/ExcludeSync')\\n    const excludeList = $tw.Bob.Wikis[data.wiki].wiki.filterTiddlers(excludeFilter.fields.text)\\n    const updateTiddlersList = serverTiddlerList.filter(function(tidTitle) {\\n      return (browserChangedTitles.indexOf(tidTitle) === -1 && recentServer.indexOf(tidTitle) === -1 && excludeList.indexOf(tidTitle) === -1 && $tw.Bob.Wikis[data.wiki].plugins.indexOf(tidTitle) === -1 && $tw.Bob.Wikis[data.wiki].themes.indexOf(tidTitle) === -1)\\n    })\\n    updateTiddlersList.forEach(function(tidTitle) {\\n      const tid = JSON.parse(JSON.stringify($tw.Bob.Wikis[data.wiki].wiki.getTiddler(tidTitle)));\\n      let message = {\\n        wiki: data.wiki,\\n        tiddler: tid\\n      };\\n      if(tid) {\\n        if(data.hashes[tidTitle] !== $tw.Bob.Shared.getTiddlerHash(tid)) {\\n          // Send the updated tiddler\\n          message.type = 'saveTiddler'\\n        }\\n      } else {\\n        // Tiddler has been removed on the server, so send a conflict delete\\n        // message\\n        message.type = 'conflict'\\n        message.message = 'deleteTiddler'\\n      }\\n      if(message.type) {\\n        $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n      }\\n    })\\n  }\\n\\n  $tw.nodeMessageHandlers.updateSetting = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const path = require('path');\\n    const fs = require('fs');\\n    if(data.remove && typeof data.remove === 'string') {\\n      // Remove settings\\n      const pieces = data.remove.split('.');\\n      if(pieces) {\\n        if(pieces.length === 1) {\\n          if($tw.settings[pieces[0]]) {\\n            delete $tw.settings[pieces[0]]\\n          }\\n        } else if($tw.settings[pieces[0]]) {\\n          let current = $tw.settings;\\n          for(let i = 0; i < pieces.length ; i++) {\\n            if(i == pieces.length - 1) {\\n              // If we are at the end and it exists delete the setting\\n              if(current[pieces[i]]) {\\n                delete current[pieces[i]];\\n              }\\n            } else if(current[pieces[i]]) {\\n              // If the next step exists move up one\\n              current = current[pieces[i]];\\n            } else {\\n              // The setting doesn't exist/is already gone\\n              break;\\n            }\\n          }\\n        }\\n      }\\n      $tw.CreateSettingsTiddlers(data);\\n      const message = {\\n        alert: 'Updated 1 wiki settings.'\\n      };\\n      $tw.ServerSide.sendBrowserAlert(message);\\n      $tw.nodeMessageHandlers.saveSettings({fromServer: true, wiki: data.wiki})\\n    }\\n    if(typeof data.updateString !== 'undefined') {\\n      // Add/Update settings values\\n      let failed = false;\\n      let updatesObject = {};\\n      let error = undefined;\\n      try {\\n        if (typeof data.updateString === 'object') {\\n          Object.keys(data.updateString).forEach(function(key) {\\n            if (typeof data.updateString[key] === 'object') {\\n              updatesObject[key] = data.updateString[key]\\n            } else if (typeof data.updateString[key] === 'string') {\\n              if (data.updateString[key].startsWith('{') || data.updateString[key].startsWith('[')) {\\n                try {\\n                  updatesObject[key] = JSON.parse(data.updateString[key]);\\n                } catch (e) {\\n                  updatesObject[key] = data.updateString[key];\\n                }\\n              } else {\\n                updatesObject[key] = data.updateString[key];\\n              }\\n            }\\n          })\\n        } else {\\n          updatesObject = JSON.parse(data.updateString);\\n        }\\n      } catch (e) {\\n        updatesObject = {};\\n        failed = true;\\n        error = e;\\n      }\\n      if(Object.keys(updatesObject).length > 0) {\\n        $tw.updateSettings($tw.settings, updatesObject);\\n      }\\n      if(!failed) {\\n        $tw.CreateSettingsTiddlers(data);\\n        const message = {\\n          alert: 'Updated ' + Object.keys(updatesObject).length + ' wiki settings.'\\n        };\\n        $tw.ServerSide.sendBrowserAlert(message);\\n        $tw.nodeMessageHandlers.saveSettings({fromServer: true, wiki: data.wiki})\\n      } else {\\n        $tw.CreateSettingsTiddlers(data);\\n        const message = {\\n          alert: 'Failed to update settings with error: ' + error\\n        };\\n        $tw.ServerSide.sendBrowserAlert(message);\\n      }\\n    }\\n  }\\n\\n  /*\\n    This updates the settings.json file based on the changes that have been made\\n    in the browser.\\n  */\\n  $tw.nodeMessageHandlers.saveSettings = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const path = require('path');\\n    const fs = require('fs');\\n    let settings = JSON.stringify($tw.settings, \\\"\\\", 2);\\n    if(data.fromServer !== true && data.settingsString) {\\n      // Get first tiddler to start out\\n      settings = data.settingsString;\\n\\n      // Update the $tw.settings object\\n      // Put the updated version in.\\n      $tw.updateSettings($tw.settings, JSON.parse(settings));\\n    }\\n    // Update the settings tiddler in the wiki.\\n    const tiddlerFields = {\\n      title: '$:/WikiSettings',\\n      text: settings,\\n      type: 'application/json'\\n    };\\n    // Push changes out to the browsers\\n    $tw.Bob.SendToBrowsers({\\n      type: 'saveTiddler',\\n      tiddler: {\\n        fields: tiddlerFields\\n      },\\n      wiki: data.wiki\\n    });\\n    // Save the updated settings\\n    const userSettingsPath = path.join($tw.boot.wikiPath, 'settings', 'settings.json');\\n    const userSettingsFolder = path.join($tw.boot.wikiPath, 'settings')\\n    if(!fs.existsSync(userSettingsFolder)) {\\n      // Create the settings folder\\n      fs.mkdirSync(userSettingsFolder);\\n    }\\n    // This should prevent an empty string from ever being given\\n    fs.writeFile(userSettingsPath, JSON.stringify($tw.settings, \\\"\\\", 2), {encoding: \\\"utf8\\\"}, function (err) {\\n      if(err) {\\n        const message = {\\n          alert: 'Error saving settings:' + err,\\n          connections: [data.source_connection]\\n        };\\n        $tw.ServerSide.sendBrowserAlert(message);\\n        $tw.Bob.logger.error(err, {level:1});\\n      } else {\\n        $tw.Bob.logger.log('Wrote settings file', {level:1})\\n      }\\n    });\\n\\n    $tw.CreateSettingsTiddlers(data);\\n    const message = {\\n      alert: 'Saved wiki settings.',\\n      wikis: [data.wiki]\\n    };\\n    $tw.ServerSide.sendBrowserAlert(message);\\n  }\\n\\n  /*\\n    This unloads a wiki from memory.\\n    This can be used to reduce the memory footprint and to fully reload a wiki.\\n\\n    It needs to remove everything under $tw.Bob.Wikis[data.wikiName] for the\\n    wiki. And it also need to find all of the tiddlers for the wiki and remove\\n    them. But I don't know how to do that without deleting the tiddlers.\\n  */\\n  $tw.nodeMessageHandlers.unloadWiki = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    // make sure that there is a wiki name given.\\n    if(data.wikiName) {\\n      $tw.Bob.logger.log('Unload wiki ', data.wikiName, {level:1});\\n      $tw.stopFileWatchers(data.wikiName);\\n      // Make sure that the wiki is loaded\\n      if($tw.Bob.Wikis[data.wikiName]) {\\n        if($tw.Bob.Wikis[data.wikiName].State === 'loaded') {\\n          // If so than unload the wiki\\n          // This removes the information about the wiki and the wiki object\\n          delete $tw.Bob.Wikis[data.wikiName];\\n          // This removes all the info about the files for the wiki\\n          delete $tw.Bob.Files[data.wikiName];\\n        }\\n      }\\n      $tw.Bob.DisconnectWiki(data.wikiName);\\n    }\\n  }\\n\\n  /*\\n    This sends a list of all available plugins to the wiki\\n  */\\n  $tw.nodeMessageHandlers.getPluginList = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const pluginNames = $tw.utils.getPluginInfo();\\n    const fields = {\\n      title: '$:/Bob/AvailablePluginList',\\n      list: $tw.utils.stringifyList(Object.keys(pluginNames))\\n    }\\n    const tiddler = {\\n      fields: fields\\n    };\\n    const message = {\\n      type: 'saveTiddler',\\n      tiddler: tiddler,\\n      wiki: data.wiki\\n    }\\n    $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message)\\n  }\\n\\n  /*\\n    This sends a list of all available plugins to the wiki\\n  */\\n  $tw.nodeMessageHandlers.getThemeList = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const themeNames = $tw.utils.getThemeInfo();\\n    const fields = {\\n      title: '$:/Bob/AvailableThemeList',\\n      list: $tw.utils.stringifyList(Object.keys(themeNames))\\n    };\\n    const tiddler = {\\n      fields: fields\\n    };\\n    const message = {\\n      type: 'saveTiddler',\\n      tiddler: tiddler,\\n      wiki: data.wiki\\n    };\\n    $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message)\\n  }\\n\\n  /*\\n    This loads the tiddlywiki.info and if new versions are given it updates the\\n    description, list of plugins, themes and languages\\n  */\\n  $tw.nodeMessageHandlers.updateTiddlyWikiInfo = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    if(data.wiki) {\\n      const path = require('path')\\n      const fs = require('fs')\\n      const wikiInfoPath = path.join($tw.Bob.Wikis[data.wiki].wikiPath, 'tiddlywiki.info');\\n      let wikiInfo = {}\\n      try {\\n        wikiInfo = JSON.parse(fs.readFileSync(wikiInfoPath,\\\"utf8\\\"));\\n      } catch(e) {\\n        $tw.Bob.logger.error(e, {level:1})\\n      }\\n      if(data.description || data.description === \\\"\\\") {\\n        wikiInfo.description = data.description;\\n      }\\n      if(data.pluginList || data.pluginList === \\\"\\\") {\\n        wikiInfo.plugins = $tw.utils.parseStringArray(data.pluginList);\\n      }\\n      if(data.themeList || data.themeList === \\\"\\\") {\\n        wikiInfo.themes = $tw.utils.parseStringArray(data.themeList);\\n      }\\n      if(data.languageList || data.languageList === \\\"\\\") {\\n        wikiInfo.languages = $tw.utils.parseStringArray(data.languageList);\\n      }\\n      try {\\n        fs.writeFileSync(wikiInfoPath, JSON.stringify(wikiInfo, null, 4))\\n      } catch (e) {\\n        $tw.Bob.logger.error(e, {level:1})\\n      }\\n    }\\n  }\\n\\n  /*\\n    This saves a plugin tiddler and splits it into separate .tid files and\\n    saves them into the appropriate folder\\n\\n    But first it checks the plugin version to make sure that it is newer than\\n    the existing one\\n  */\\n  $tw.nodeMessageHandlers.savePluginFolder = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    if(data.plugin) {\\n      const fs = require('fs')\\n      const path = require('path')\\n      const pluginTiddler = $tw.Bob.Wikis[data.wiki].wiki.getTiddler(data.plugin)\\n      if(pluginTiddler) {\\n        const pluginName = data.plugin.replace(/^\\\\$:\\\\/plugins\\\\//, '')\\n        const basePath = $tw.ServerSide.getBasePath()\\n        const pluginFolderPath = path.resolve(basePath, $tw.settings.pluginsPath, pluginName)\\n        const pluginInfoPath = path.join(pluginFolderPath, 'plugin.info')\\n        let isNewVersion = true\\n        let oldVersion = {}\\n        let newVersion = {}\\n        // Check if the plugin folder exists\\n        if(fs.existsSync(pluginInfoPath)) {\\n          // If it does exist than check versions, only save new or equal\\n          // versions\\n          // Load the plugin.info file and check the version\\n          let oldInfo\\n          try {\\n            oldInfo = JSON.parse(fs.readFileSync(pluginInfoPath, 'utf8'))\\n          } catch (e) {\\n            //Something\\n            $tw.Bob.logger.error(e, {level:1})\\n          }\\n          if(oldInfo) {\\n            // Check the version here\\n            oldVersion = $tw.utils.parseVersion(oldInfo.version)\\n            newVersion = $tw.utils.parseVersion(pluginTiddler.fields.version)\\n            if(oldVersion.major > newVersion.major) {\\n              isNewVersion = false\\n            } else if(oldVersion.minor > newVersion.minor) {\\n              isNewVersion = false\\n            } else if(oldVersion.patch > newVersion.patch) {\\n              isNewVersion = false\\n            }\\n          }\\n        } else {\\n          // We don't have any version of the plugin yet\\n          let error = $tw.utils.createDirectory(pluginFolderPath);\\n          if(error) {\\n            $tw.Bob.logger.error(error, {level:1})\\n          }\\n        }\\n        if(isNewVersion) {\\n          // Save the plugin tiddlers\\n          Object.keys(JSON.parse(pluginTiddler.fields.text).tiddlers).forEach(function(title) {\\n            const content = $tw.Bob.Wikis[data.wiki].wiki.renderTiddler(\\\"text/plain\\\", \\\"$:/core/templates/tid-tiddler\\\", {variables: {currentTiddler: title}});\\n            const fileExtension = '.tid'\\n            const filepath = path.join(pluginFolderPath, $tw.syncadaptor.generateTiddlerBaseFilepath(title, data.wiki) + fileExtension);\\n            // If we aren't passed a path\\n            fs.writeFile(filepath,content,{encoding: \\\"utf8\\\"},function (err) {\\n              if(err) {\\n                $tw.Bob.logger.error(err, {level:1});\\n              } else {\\n                $tw.Bob.logger.log('saved file', filepath, {level:2})\\n              }\\n            });\\n          })\\n          // Make the plugin.info file\\n          let pluginInfo = {}\\n          Object.keys(pluginTiddler.fields).forEach(function(field) {\\n            if(field !== 'text' && field !== 'tags' && field !== 'type') {\\n              pluginInfo[field] = pluginTiddler.fields[field]\\n            }\\n          })\\n          fs.writeFile(pluginInfoPath,JSON.stringify(pluginInfo, null, 2),{encoding: \\\"utf8\\\"},function (err) {\\n            if(err) {\\n              $tw.Bob.logger.error(err, {level:1});\\n            } else {\\n              $tw.Bob.logger.log('saved file', pluginInfoPath, {level:2})\\n            }\\n          });\\n        } else {\\n          $tw.Bob.logger.log(\\\"Didn't save plugin\\\", pluginName, \\\"with version\\\", newVersion.version,\\\"it is already saved with version\\\", oldVersion.version, {level:1})\\n        }\\n      }\\n    }\\n  }\\n\\n  /*\\n    Given a url that points to either github, gitlab or a zip file with a\\n    plugin this gets the plugin and adds it to the plugins on the server.\\n  */\\n  $tw.nodeMessageHandlers.getGitPlugin = function(data) {\\n    $tw.Bob.Shared.sendAck(data)\\n    if(data.url) {\\n      // Special handling for github, we will see about other things later.\\n      if(!data.url.toLowerCase().endsWith('.zip')) {\\n        if(data.url.toLowerCase().startsWith('https://github.com')) {\\n          data.url = data.url + '/archive/master.zip';\\n        } else if(data.url.toLowerCase().startsWith('https://gitlab.com')) {\\n          const repoName = data.url.toLowerCase().split('/').pop()\\n          data.url = data.url + '/-/archive/master/' + repoName + '-master.zip'\\n        }\\n      }\\n      const path = require('path');\\n      const fs = require('fs')\\n      const protocol = data.url.startsWith('https')?'https':'http';\\n      const JSZip = require(\\\"$:/plugins/OokTech/Bob/External/jszip/jszip.js\\\");\\n      const http = require(\\\"$:/plugins/OokTech/Bob/External/followRedirects/followRedirects.js\\\")[protocol];\\n      var req = http.get(data.url, function (res) {\\n        if(res.statusCode !== 200) {\\n          $tw.Bob.logger.error('failed to fetch git plugin with code', res.statusCode, {level:1});\\n          // handle error\\n          return;\\n        }\\n        var data = [], dataLen = 0;\\n        res.on(\\\"data\\\", function (chunk) {\\n          data.push(chunk);\\n          dataLen += chunk.length;\\n        });\\n        res.on(\\\"end\\\", function () {\\n          var buf = Buffer.concat(data);\\n          // here we go !\\n          let zipObj;\\n          let rootFolder;\\n          JSZip.loadAsync(buf).then(function (zip) {\\n            zipObj = zip;\\n            const pluginInfo = zip.filter(function(relativePath,file) {\\n              const goodFolder = relativePath.split('/').length === 2;\\n              const correctName = relativePath.endsWith('plugin.info');\\n              return goodFolder && correctName;\\n            })[0]\\n            rootFolder = pluginInfo.name.split('/')[0];\\n            return pluginInfo.async('string');\\n          }).then(function(info) {\\n            const infoObj = JSON.parse(info.trim());\\n            // Check if we have the plugin already, if so check if this version\\n            // is newer than our local version. If not skip it.\\n            const pluginName = infoObj.title.replace('$:/plugins/','');\\n            const pluginNames = Object.keys($tw.utils.getPluginInfo());\\n            let exists = false;\\n            let newer = false;\\n            if(pluginNames.indexOf(pluginName) !== 0) {\\n              // Check versions\\n              exists = true;\\n            }\\n            const basePath = $tw.ServerSide.getBasePath()\\n            const pluginsPath = path.resolve(basePath, $tw.settings.pluginsPath);\\n            // If we don't have the plugin than create the plugin folder, also\\n            // creating the author folder if we don't have it already.\\n            if(!exists) {\\n              // Make plugin folder\\n              $tw.utils.createDirectory(path.join(pluginsPath,pluginName));\\n            }\\n            if(!(exists && newer)) {\\n              // Then walk though the zip file and add all files and folders in\\n              // the zip file to our local folder.\\n              zipObj.folder(rootFolder).forEach(function(relativePath, file) {\\n                // Check if folder exists, if not create it.\\n                // This is for every file because I am not sure order is\\n                // gaurenteed so you may not get the folder before you get\\n                // files in the folder.\\n                if(!fs.existsSync(path.join(pluginsPath, pluginName, relativePath.split('/').slice(0,-1).join('/')))) {\\n                  // Make a folder\\n                  $tw.utils.createDirectory(path.join(pluginsPath, pluginName, relativePath.split('/').slice(0,-1).join('/')));\\n                }\\n                if(!file.dir) {\\n                  // save the file in the correct folder\\n                  file.nodeStream()\\n                  .pipe(fs.createWriteStream(path.join(pluginsPath,pluginName,relativePath)))\\n                  .on('finish', function() {\\n                    $tw.Bob.logger.log('wrote file: ', path.join(pluginsPath,pluginName,relativePath), {level:2});\\n                  })\\n                }\\n              });\\n              const message = {\\n                alert: 'Saved ' + pluginName + 'to server library.'\\n              };\\n              $tw.ServerSide.sendBrowserAlert(message);\\n            }\\n          }).catch(function(err) {\\n            $tw.Bob.logger.error('some error saving git plugin',err, {level:1});\\n          });\\n        });\\n      });\\n\\n      req.on(\\\"error\\\", function(err){\\n        // handle error\\n        $tw.Bob.logger.error('Rocks fall, everyone dies: ',err, {level:0});\\n      });\\n    }\\n  }\\n\\n  /*\\n    This takes all embedded media and moves it into the folder for serving\\n    files and replaces all of the media tiddlers with _canonical_uri tiddlers.\\n\\n    Structure of data\\n    {\\n      \\\"type\\\": \\\"makeImagesExternal\\\",\\n      \\\"wiki\\\": \\\"wikiName\\\",\\n      \\\"storeIn\\\": \\\"folderType\\\"\\n    }\\n\\n    storeIn can be 'global' (default) or 'wiki'\\n    global puts the files in the global folder\\n    wiki puts the files in the wiki specific folder\\n\\n  */\\n  $tw.nodeMessageHandlers.makeImagesExternal = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const authorised = $tw.Bob.AccessCheck(data.fromWiki, {\\\"decoded\\\":data.decoded}, 'admin');\\n    if(authorised) {\\n      $tw.settings.fileURLPrefix = $tw.settings.fileURLPrefix || 'files'\\n      const path = require('path');\\n      const fs = require('fs');\\n      // Get all the tiddlers that have a media type we care about\\n      // Get files path\\n      const basePath = $tw.ServerSide.getBasePath()\\n      let midPath;\\n      if(data.storeIn !== 'wiki') {\\n        midPath = path.join($tw.settings.wikisPath, data.wiki);\\n      } else {\\n        //midPath = $tw.settings.filePathRoot;\\n        midPath = $tw.ServerSide.getFilePathRoot();\\n      }\\n      let filesPath;\\n      if(data.storeIn !== 'wiki') {\\n        filesPath = path.resolve(basePath, midPath, 'files');\\n      } else {\\n        filesPath = path.resolve(basePath, midPath);\\n      }\\n      // Make sure that filesPath exists\\n      $tw.utils.createDirectory(filesPath);\\n      let tiddlersToMove = [];\\n      $tw.Bob.Wikis[data.wiki].wiki.allTitles().forEach(function(tidTitle) {\\n        const tiddler = $tw.Bob.Wikis[data.wiki].wiki.getTiddler(tidTitle);\\n        if(tiddler) {\\n          if(tiddler.fields.type) {\\n            const typeParts = tiddler.fields.type.split('/')\\n            if((['image', 'audio', 'video'].indexOf(typeParts[0]) !== -1 || tiddler.fields.type === 'application/pdf') && (!tiddler.fields._canonical_uri || tiddler.fields._canonical_uri === '')) {\\n              // Move the file from the tiddlers folder to the files folder,\\n              if($tw.Bob.Files[data.wiki][tidTitle]) {\\n                const fileName = $tw.Bob.Files[data.wiki][tidTitle].filepath.split('/').slice(-1)[0]\\n                fs.rename($tw.Bob.Files[data.wiki][tidTitle].filepath, path.join(filesPath, fileName), function(e) {\\n                  if(e) {\\n                    $tw.Bob.logger.error('failed to move image file',e, {level:1});\\n                  } else {\\n                    let newFields = JSON.parse(JSON.stringify(tiddler.fields));\\n                    newFields.text = ''\\n                    if(data.storeIn === 'wiki') {\\n                      newFields._canonical_uri = path.join('/', data.wiki, $tw.settings.fileURLPrefix, fileName);\\n                    } else {\\n                      newFields._canonical_uri = path.join('/', $tw.settings.fileURLPrefix, fileName);\\n                    }\\n                    //delete the original tiddler\\n                    $tw.Bob.DeleteTiddler($tw.Bob.Files[data.wiki][tidTitle].filepath.split('/').slice(0,-1).join('/'), fileName, data.wiki);\\n                    // create the tiddler with the same name and give it a\\n                    // _canonical_uri field pointing to the correct file.\\n                    $tw.syncadaptor.saveTiddler(new $tw.Tiddler(newFields), data.wiki);\\n                  }\\n                });\\n              }\\n            }\\n          }\\n        }\\n      })\\n      const message = {\\n        alert: 'Made media external for ' + data.wiki,\\n        wikis: [data.wiki]\\n      };\\n      $tw.ServerSide.sendBrowserAlert(message);\\n    }\\n  }\\n\\n  /*\\n    This renames/moves a wiki\\n\\n    {\\n      wiki: callingWiki,\\n      oldWiki: oldWikiName,\\n      newWiki: newWikiName\\n    }\\n\\n    oldWiki is the name of the wiki you want to rename, newWiki is the new name\\n    for the wiki.\\n\\n    If the new name is an existing wiki than this won't do anything.\\n  */\\n  $tw.nodeMessageHandlers.renameWiki = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const path = require('path')\\n    const fs = require('fs')\\n    const authorised = $tw.Bob.AccessCheck(data.fromWiki, {\\\"decoded\\\":data.decoded}, 'duplicate');\\n    if($tw.ServerSide.existsListed(data.oldWiki) && !$tw.ServerSide.existsListed(data.newWiki) && authorised) {\\n      // Unload the old wiki\\n      $tw.nodeMessageHandlers.unloadWiki({wikiName: data.oldWiki});\\n      const basePath = $tw.ServerSide.getBasePath();\\n      const oldWikiPath = $tw.ServerSide.getWikiPath(data.oldWiki);\\n      const newWikiPath = path.resolve(basePath, $tw.settings.wikisPath, data.newWiki);\\n      fs.rename(oldWikiPath, newWikiPath, function(e) {\\n        if(e) {\\n          $tw.Bob.logger.log('failed to rename wiki',e,{level:1});\\n        } else {\\n          // Refresh wiki listing\\n          data.update = 'true';\\n          data.saveSettings = 'true';\\n          $tw.nodeMessageHandlers.findAvailableWikis(data);\\n          const message = {\\n            alert: 'Renamed ' + data.oldWiki + ' to ' + data.newWiki\\n          };\\n          $tw.ServerSide.sendBrowserAlert(message);\\n        }\\n      })\\n    }\\n  }\\n\\n  /*\\n    This deletes a wiki.\\n\\n    {\\n      wiki: callingWiki,\\n      deleteWiki: wikiToDelete,\\n      deleteChildren: deleteChildren\\n    }\\n\\n    wikiToDelete is the wiki that will be deleted\\n    deleteChildren if set to 'yes' than the entire wiki folder, including any\\n    child wikis, is deleted, Otherwise only the tiddlywiki.info file and the\\n    tiddlers folder is removed.\\n  */\\n\\n  // This is a thing to do rm -rf using node since rmdir fails on non-empty directories\\n\\n  function deleteFile(dir, file) {\\n    const fs = require('fs');\\n    const path = require('path');\\n    return new Promise(function (resolve, reject) {\\n      //Check to make sure that dir is in the place we expect\\n      if(dir.startsWith($tw.ServerSide.getBasePath())) {\\n        var filePath = path.join(dir, file);\\n        fs.lstat(filePath, function (err, stats) {\\n          if(err) {\\n            return reject(err);\\n          }\\n          if(stats.isDirectory()) {\\n            resolve(deleteDirectory(filePath));\\n          } else {\\n            fs.unlink(filePath, function (err) {\\n              if(err) {\\n                return reject(err);\\n              }\\n              resolve();\\n            });\\n          }\\n        });\\n      } else {\\n        reject('The folder is not in expected place!');\\n      }\\n    });\\n  };\\n\\n  function deleteDirectory(dir) {\\n    const fs = require('fs');\\n    const path = require('path');\\n    return new Promise(function (resolve, reject) {\\n      // Check to make sure that dir is in the place we expect\\n      if(dir.startsWith($tw.ServerSide.getBasePath())) {\\n        fs.access(dir, function (err) {\\n          if(err) {\\n            if(err.code === 'ENOENT') {\\n              return resolve();\\n            }\\n            return reject(err);\\n          }\\n          fs.readdir(dir, function (err, files) {\\n            if(err) {\\n              return reject(err);\\n            }\\n            Promise.all(files.map(function (file) {\\n              return deleteFile(dir, file);\\n            })).then(function () {\\n              fs.rmdir(dir, function (err) {\\n                if(err) {\\n                  return reject(err);\\n                }\\n                resolve();\\n              });\\n            }).catch(reject);\\n          });\\n        });\\n      } else {\\n        reject('The folder is not in expected pace!');\\n      }\\n    });\\n  };\\n  $tw.stopFileWatchers = function(wikiName) {\\n    // Close any file watchers that are active for the wiki\\n    if ($tw.Bob.Wikis[wikiName]) {\\n      if ($tw.Bob.Wikis[wikiName].watchers) {\\n        Object.values($tw.Bob.Wikis[wikiName].watchers).forEach(function(thisWatcher) {\\n          thisWatcher.close();\\n        })\\n      }\\n    }\\n  }\\n  $tw.nodeMessageHandlers.deleteWiki = function(data) {\\n    $tw.Bob.Shared.sendAck(data)\\n    const path = require('path')\\n    const fs = require('fs')\\n    const authorised = $tw.Bob.AccessCheck(data.deleteWiki, {\\\"decoded\\\":data.decoded}, 'delete');\\n    // Make sure that the wiki exists and is listed\\n    if($tw.ServerSide.existsListed(data.deleteWiki) && authorised) {\\n      $tw.stopFileWatchers(data.deleteWiki)\\n      const wikiPath = $tw.ServerSide.getWikiPath(data.deleteWiki);\\n      if(data.deleteChildren === 'yes') {\\n        deleteDirectory(wikiPath).then(function() {\\n          // Refresh wiki listing\\n          data.update = 'true';\\n          data.saveSettings = 'true';\\n          $tw.nodeMessageHandlers.findAvailableWikis(data);\\n          const message = {\\n            alert: 'Deleted wiki ' + data.deleteWiki + ' and its child wikis.'\\n          };\\n          $tw.ServerSide.sendBrowserAlert(message);\\n        }).catch(function(e) {\\n          // Refresh wiki listing\\n          data.update = 'true';\\n          data.saveSettings = 'true';\\n          $tw.nodeMessageHandlers.findAvailableWikis(data);\\n          const message = {\\n            alert: 'Error trying to delete wiki ' + e\\n          };\\n          $tw.ServerSide.sendBrowserAlert(message);\\n        })\\n      } else {\\n        // Delete the tiddlywiki.info file\\n        fs.unlink(path.join(wikiPath, 'tiddlywiki.info'), function(e) {\\n          if(e) {\\n            $tw.Bob.logger.error('failed to delete tiddlywiki.info',e, {level:1});\\n          } else {\\n            // Delete the tiddlers folder (if any)\\n            deleteDirectory(path.join(wikiPath, 'tiddlers')).then(function() {\\n              $tw.utils.deleteEmptyDirs(wikiPath,function() {\\n                // Refresh wiki listing\\n                data.update = 'true';\\n                data.saveSettings = 'true';\\n                $tw.nodeMessageHandlers.findAvailableWikis(data);\\n                const message = {\\n                  alert: 'Deleted wiki ' + data.deleteWiki\\n                };\\n                $tw.ServerSide.sendBrowserAlert(message);\\n              });\\n            }).catch(function(e){\\n              // Refresh wiki listing\\n              data.update = 'true';\\n              data.saveSettings = 'true';\\n              $tw.nodeMessageHandlers.findAvailableWikis(data);\\n              const message = {\\n                alert: 'Error trying to delete wiki ' + e\\n              };\\n              $tw.ServerSide.sendBrowserAlert(message);\\n            })\\n          }\\n        })\\n      }\\n    }\\n  }\\n\\n  /*\\n    This handlers takes a folder as input and if the folder is one of the\\n    folders with media being served it will return a list of files available in\\n    the folder.\\n\\n    TODO make this return the path to use in a _canonical_uri\\n\\n    data = {\\n      folder: './',\\n      mediaTypes: .mp3 .mp3 .doc,\\n      tiddler: $:/state/fileList,\\n      field: list\\n    }\\n\\n    TODO figure out the authorisation level for this one\\n  */\\n  $tw.nodeMessageHandlers.listFiles = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const path = require('path');\\n    const fs = require('fs');\\n    const authorised = $tw.Bob.AccessCheck(data.wiki, {\\\"decoded\\\":data.decoded}, 'serverAdmin');\\n\\n    $tw.settings.fileURLPrefix = $tw.settings.fileURLPrefix || 'files';\\n    data.folder = data.folder || $tw.settings.fileURLPrefix;\\n    data.folder = data.folder.startsWith('/') ? data.folder : '/' + data.folder;\\n    const wikiName = $tw.ServerSide.findName(data.folder);\\n    const repRegex = new RegExp(`^\\\\/?.+?\\\\/?${$tw.settings.fileURLPrefix}\\\\/?`)\\n    const thePath = data.folder.replace(repRegex, '').replace(/^\\\\/*/,'');\\n    let fileFolder\\n    if(thePath === '' && wikiName === '') {\\n      // Globally available files in filePathRoot\\n      const filePathRoot = $tw.ServerSide.getFilePathRoot();\\n      //fileFolder = path.resolve($tw.ServerSide.getBasePath(), $tw.settings.filePathRoot);\\n      fileFolder = path.resolve($tw.ServerSide.getBasePath(), filePathRoot);\\n      // send to browser\\n      next(fileFolder, '');\\n    } else if (wikiName === '' && $tw.settings.servingFiles[thePath]) {\\n      // Explicitly listed folders that are globally available\\n      fileFolder = $tw.settings.servingFiles[thePath];\\n      // send to browser\\n      next(fileFolder, thePath);\\n    } else if (wikiName !== '') {\\n      // Wiki specific files, need to check to make sure that if perwikiFiles is set this only works from the target wiki.\\n      if($tw.settings.perWikiFiles !== 'yes' || wikiName === data.wiki) {\\n        const wikiPath = $tw.ServerSide.existsListed(wikiName);\\n        if(!wikiPath) {\\n          return;\\n        }\\n        fileFolder = path.join(wikiPath, 'files');\\n        next(fileFolder, thePath, wikiName);\\n      }\\n    } else {\\n      const testPaths = [path.resolve($tw.ServerSide.getBasePath)].concat( Object.values($tw.settings.servingFiles));\\n      let ind = 0\\n      nextTest(0, testPaths)\\n      function nextTest(index, pathsToTest) {\\n        // If the path isn't listed in the servingFiles thing check if it is a child of one of the paths, or of the filePathRoot\\n        const filePathRoot = $tw.ServerSide.getFilePathRoot();\\n        let test = path.resolve($tw.ServerSide.getBasePath(), filePathRoot, pathsToTest[index]);\\n        fs.access(test, fs.constants.F_OK, function(err) {\\n          if(err) {\\n            if(index < pathToTest.length - 1) {\\n              nextTest(index + 1, pathsToTest);\\n            }\\n          } else {\\n            // send the list to the browser\\n            next(test, pathsToTest[index]);\\n          }\\n        })\\n      }\\n    }\\n    function next(folder, urlPath, wikiName) {\\n      wikiName = wikiName || '';\\n      data.tiddler = data.tiddler || path.join('$:/state/fileList/', wikiName, $tw.settings.fileURLPrefix, urlPath);\\n      data.field = data.field || 'list';\\n      // if the folder listed in data.folder is either a child of the filePathRoot or if it is a child of one of the folders listed in the $tw.settings.servingFiles thing we will continue, otherwise end.\\n      const filePathRoot = $tw.ServerSide.getFilePathRoot();\\n      const usedPaths = Object.values($tw.settings.servingFiles).map(function(item) {\\n          return path.resolve($tw.ServerSide.getBasePath(), filePathRoot, item)\\n        });\\n      const resolvedPath = path.resolve($tw.ServerSide.getBasePath(), filePathRoot, folder);\\n      let match = false;\\n      if (authorised) {\\n        const mimeMap = $tw.settings.mimeMap || {\\n          '.aac': 'audio/aac',\\n          '.avi': 'video/x-msvideo',\\n          '.csv': 'text/csv',\\n          '.doc': 'application/msword',\\n          '.epub': 'application/epub+zip',\\n          '.gif': 'image/gif',\\n          '.html': 'text/html',\\n          '.htm': 'text/html',\\n          '.ico': 'image/x-icon',\\n          '.jpg': 'image/jpeg',\\n          '.jpeg': 'image/jpeg',\\n          '.mp3': 'audio/mpeg',\\n          '.mpeg': 'video/mpeg',\\n          '.oga': 'audio/ogg',\\n          '.ogv': 'video/ogg',\\n          '.ogx': 'application/ogg',\\n          '.png': 'image/png',\\n          '.svg': 'image/svg+xml',\\n          '.weba': 'audio/weba',\\n          '.webm': 'video/webm',\\n          '.wav': 'audio/wav'\\n        };\\n        const extList = data.mediaTypes || false;\\n        fs.readdir(resolvedPath, function(err, items) {\\n          if(err || !items) {\\n            $tw.Bob.logger.error(\\\"Can't read files folder \\\", resolvedPath, \\\" with error \\\", err, {level: 1});\\n          } else {\\n            // filter the list to only include listed mimetypes.\\n            let filteredItems = items.filter(function(item) {\\n              const splitItem = item.split('.');\\n              const ext = splitItem[splitItem.length-1];\\n              return typeof mimeMap['.' + ext] === 'string';\\n            })\\n            if(extList) {\\n              filteredItems = filteredItems.filter(function(item) {\\n                const splitItem = item.split('.');\\n                const ext = splitItem[splitItem.length-1];\\n                return typeof extList.indexOf('.' + ext) !== -1;\\n              })\\n            }\\n            // Reply with the list\\n            let prefix = path.join(wikiName, $tw.settings.fileURLPrefix, urlPath);\\n            prefix = prefix.startsWith('/') ? prefix : '/' + prefix;\\n            prefix = prefix.endsWith('/') ? prefix : prefix + '/';\\n            const fields = {\\n              title: data.tiddler,\\n              pathprefix: prefix,\\n              folder: data.folder,\\n            }\\n            fields[data.field] = $tw.utils.stringifyList(filteredItems);\\n            const message = {\\n              type: \\\"saveTiddler\\\",\\n              tiddler: {\\n                fields: fields\\n              },\\n              wiki: data.wiki\\n            }\\n            $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n            $tw.Bob.logger.log(\\\"Scanned \\\", resolvedPath, \\\" for files, returned \\\", filteredItems, {level: 3});\\n          }\\n        });\\n      }\\n    }\\n  }\\n\\n  /*\\n    This handler takes a folder as input and scans the folder for media\\n    and creates _canonical_uri tiddlers for each file found.,\\n    an optional extension list can be passed to restrict the media types scanned for.\\n\\n    ignoreExisting takes precidence over overwrite\\n\\n    data = {\\n      folder: './',\\n      ignoreExisting: 'true',\\n      overwrite: 'false',\\n      prune: 'false',\\n      mediaTypes: [things listed in the mimemap],\\n      prefix: 'docs'\\n    }\\n    Folder paths are either absolute or relative to $tw.Bob.getBasePath()\\n\\n    folder - the folder to scan\\n    ignoreExisting -\\n    overwrite - if this is true than tiddlers are made even if they overwrite existing tiddlers\\n    prune - remove tiddlers that have _canonical_uri fields pointing to files that don't exist in the folder\\n    mediaTypes - an array of file extensions to look for. If the media type is not in the mimemap than the tiddler type may be set incorrectly.\\n    prefix - the prefix to put on the uri, the uri will be in the form\\n            /wikiName/files/prefix/file.ext\\n\\n    TODO - add a recursive option (with some sane limits, no recursively finding everything in /)\\n    TODO - figure out what permission this one should go with\\n    TODO - maybe add some check to limit where the folders can be\\n    TODO - add a flag to add folders to the static file server component\\n  */\\n  $tw.nodeMessageHandlers.mediaScan = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    data.prefix = data.prefix || 'prefix';\\n    const path = require('path');\\n    const fs = require('fs');\\n    const authorised = $tw.Bob.AccessCheck(data.wiki, {\\\"decoded\\\":data.decoded}, 'serverAdmin');\\n    const filePathRoot = $tw.ServerSide.getFilePathRoot();\\n    //$tw.settings.filePathRoot = $tw.settings.filePathRoot || './files';\\n    $tw.settings.fileURLPrefix = $tw.settings.fileURLPrefix || 'files';\\n    if (authorised) {\\n      $tw.settings.servingFiles[data.prefix] = data.folder;\\n      const mimeMap = $tw.settings.mimeMap || {\\n        '.aac': 'audio/aac',\\n        '.avi': 'video/x-msvideo',\\n        '.csv': 'text/csv',\\n        '.doc': 'application/msword',\\n        '.epub': 'application/epub+zip',\\n        '.gif': 'image/gif',\\n        '.html': 'text/html',\\n        '.htm': 'text/html',\\n        '.ico': 'image/x-icon',\\n        '.jpg': 'image/jpeg',\\n        '.jpeg': 'image/jpeg',\\n        '.mp3': 'audio/mpeg',\\n        '.mpeg': 'video/mpeg',\\n        '.oga': 'audio/ogg',\\n        '.ogv': 'video/ogg',\\n        '.ogx': 'application/ogg',\\n        '.png': 'image/png',\\n        '.svg': 'image/svg+xml',\\n        '.weba': 'audio/weba',\\n        '.webm': 'video/webm',\\n        '.wav': 'audio/wav'\\n      };\\n      if (typeof data.mediaTypes === 'string') {\\n        if (data.mediaTypes.length > 0) {\\n          data.mediaTypes = data.mediaTypes.split(' ');\\n        }\\n      } else {\\n        data.mediaTypes = undefined;\\n      }\\n      data.mediaTypes = data.mediaTypes || Object.keys(mimeMap);\\n      if (data.folder && data.wiki) {\\n        // Make sure the folder exists\\n        let mediaURIList = [];\\n        /*\\n        if(typeof $tw.settings.filePathRoot !== 'string') {\\n          $tw.settings.filePathRoot = './files';\\n        }\\n        */\\n        const mediaDir = path.resolve($tw.ServerSide.getBasePath(), filePathRoot, data.folder)\\n        if($tw.utils.isDirectory(mediaDir)) {\\n          fs.readdir(mediaDir, function(err, files) {\\n            if (err) {\\n              $tw.Bob.logger.error('Error scanning folder', data.folder, {level:1});\\n              return;\\n            }\\n            const uriPrefix = '/' + path.relative($tw.ServerSide.getBasePath(), mediaDir);\\n            if (data.keepBroken !== true) {\\n              // get a list of all tiddlers with _canonical_uri fields that\\n              // point to this folder.\\n              mediaURIList = $tw.Bob.Wikis[data.wiki].wiki.filterTiddlers(`[has[_canonical_uri]get[_canonical_uri]prefix[${uriPrefix}]]`);\\n              // We don't want to list uris for subfolders until we do a recursive find thing\\n              mediaURIList = mediaURIList.filter(function(uri) {\\n                return uri.slice(uriPrefix.length+1).indexOf('/') === -1;\\n              })\\n            }\\n            // For each file check the extension against the mimemap, if it matches make the corresponding _canonical_uri tiddler.\\n            files.forEach(function(file) {\\n              if (fs.statSync(path.join(mediaDir, file)).isFile()) {\\n                const pathInfo = path.parse(file);\\n                if (data.mediaTypes.indexOf(pathInfo.ext) !== -1) {\\n                  const thisURI = '/' + $tw.settings.fileURLPrefix + '/' + data.prefix + '/' + path.relative(path.resolve(data.folder),path.join(mediaDir, file));\\n                  if (data.prune === 'yes') {\\n                    // Remove any _canonical_uri tiddlers that have paths to\\n                    // this folder but no files exist for them.\\n                    // remove the current file from the mediaURIList so that at\\n                    // the end we have a list of URIs that don't have files\\n                    // that exist.\\n                    if (mediaURIList.indexOf(thisURI) > -1) {\\n                      mediaURIList.splice(mediaURIList.indexOf(thisURI),1);\\n                    }\\n                  }\\n                  // It is a file and the extension is listed, so create a tiddler for it.\\n                  const fields = {\\n                    title: pathInfo.base,\\n                    type: mimeMap[pathInfo.ext],\\n                    _canonical_uri: thisURI\\n                  };\\n                  if (data.ignoreExisting !== 'yes') {\\n                    // check if the tiddler with this _canonical_uri already\\n                    // exists.\\n                    // If we aren't set to overwrite than don't do anything for\\n                    // this file if it exists\\n                    if ($tw.Bob.Wikis[data.wiki].wiki.filterTiddlers(`[_canonical_uri[${fields._canonical_uri}]]`).length > 0) {\\n                      return;\\n                    }\\n                  }\\n                  const thisTiddler = new $tw.Tiddler($tw.Bob.Wikis[data.wiki].wiki.getCreationFields(), fields);\\n                  const tiddlerPath = path.join($tw.Bob.Wikis[data.wiki].wikiTiddlersPath, file);\\n                  // Check if the file exists and only overwrite it if the\\n                  // overwrite flag is set.\\n                  // Update this to check for files by the _canonical_uri field\\n                  if (data.overwrite === 'yes' || !$tw.Bob.Wikis[data.wiki].wiki.getTiddler(file)) {\\n                    // Add tiddler to the wiki listed in data.wiki\\n                    $tw.syncadaptor.saveTiddler(thisTiddler, data.wiki);\\n                  }\\n                }\\n              }\\n            });\\n            if (data.prune === 'yes') {\\n              // mediaURIList now has the uris from tiddlers that don't point\\n              // to real files.\\n              // Get the tiddlers with the uris listed and remove them.\\n              mediaURIList.forEach(function(uri) {\\n                const tiddlerList = $tw.Bob.Wikis[data.wiki].wiki.filterTiddlers(`[_canonical_uri[${uri}]]`);\\n                tiddlerList.forEach(function(tidTitle) {\\n                  $tw.syncadaptor.deleteTiddler(tidTitle, {wiki: data.wiki});\\n                })\\n              })\\n            }\\n          })\\n        }\\n      }\\n      // Save the settings\\n      $tw.nodeMessageHandlers.saveSettings({fromServer: true, wiki: data.wiki});\\n    }\\n  }\\n}\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/NodeWebSocketsSetup.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/NodeWebSocketsSetup.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/NodeWebSocketsSetup.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThis is the node component of the web sockets. It works with\\nweb-sockets-setup.js and ActionWebSocketMessage.js which set up the browser\\nside and make the action widget used to send messages to the node process.\\n\\nTo extend this you make a new file that adds functions to the\\n$tw.nodeMessageHandlers object.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"websocket-server\\\";\\nexports.platforms = [\\\"node\\\"];\\nexports.after = [\\\"node-settings\\\"];\\nexports.synchronous = true;\\n\\n\\n// Make sure that $tw.settings is available.\\n$tw.settings = $tw.settings || require('$:/plugins/OokTech/NodeSettings/NodeSettings.js');\\n\\n\\nif($tw.node) {\\n  //  var TOML = $tw.node ? require('$:/plugins/OokTech/Bob/External/@iarna/toml/toml.js') : undefined;\\n  // Import shared commands\\n  $tw.Bob.Shared = require('$:/plugins/OokTech/Bob/SharedFunctions.js');\\n  $tw.Bob = $tw.Bob || {};\\n  $tw.Bob.EditingTiddlers = $tw.Bob.EditingTiddlers || {};\\n  // Initialise connections array\\n  $tw.connections = $tw.connections || [];\\n  /*\\n    This sets up the websocket server and attaches it to the $tw object\\n  */\\n  const setup = function () {\\n    // require the websockets module if we are running node\\n    const WebSocketServer = require('$:/plugins/OokTech/Bob/External/WS/ws.js').Server;\\n    // initialise the empty $tw.nodeMessageHandlers object. This holds the\\n    // functions that are used for each message type\\n    $tw.nodeMessageHandlers = $tw.nodeMessageHandlers || {};\\n    $tw.settings['ws-server'] = $tw.settings['ws-server'] || {};\\n\\n    /*\\n      Setup the websocket server if we aren't using an external one\\n    */\\n    function finishSetup () {\\n      if(!$tw.settings['ws-server'].useExternalWSS) {\\n        $tw.wss = new WebSocketServer({noServer: true});\\n        // Set the onconnection function\\n        $tw.wss.on('connection', handleConnection);\\n        // I don't know how to set up actually closing a connection, so this doesn't\\n        // do anything useful yet\\n        $tw.wss.on('close', function(connection) {\\n          $tw.Bob.logger.log('closed connection ', connection, {level:2});\\n        });\\n      }\\n      $tw.PruneTimeout = setInterval(function(){\\n        $tw.Bob.PruneConnections();\\n      }, 10000);\\n    }\\n    finishSetup();\\n  }\\n\\n  /*\\n    This function handles connections to a client.\\n    It currently only supports one client and if a new client connection is made\\n    it will replace the current connection.\\n    This function saves the connection and adds the message handler wrapper to\\n    the client connection.\\n    The message handler part is a generic wrapper that checks to see if we have a\\n    handler function for the message type and if so it passes the message to the\\n    handler, if not it prints an error to the console.\\n\\n    connection objects are:\\n    {\\n      \\\"socket\\\": socketObject,\\n      \\\"wiki\\\": the name for the wiki using this connection\\n    }\\n  */\\n  function handleConnection(client, request) {\\n    $tw.Bob.logger.log(\\\"new connection\\\", {level:2});\\n    $tw.connections.push({'socket':client, 'wiki': undefined});\\n    client.on('message', $tw.Bob.handleMessage);\\n    // Respond to the initial connection with a request for the tiddlers the\\n    // browser currently has to initialise everything.\\n    $tw.connections[Object.keys($tw.connections).length-1].index = Object.keys($tw.connections).length-1;\\n    const message = {type: 'listTiddlers'}\\n    $tw.Bob.SendToBrowser($tw.connections[Object.keys($tw.connections).length-1], message);\\n    if(false && $tw.node && $tw.settings.enableFederation === 'yes') {\\n      $tw.Bob.Federation.updateConnections();\\n    }\\n  }\\n\\n  /*\\n    This makes sure that the token send allows the action on the wiki\\n  */\\n  function authenticateMessage(event) {\\n    return $tw.Bob.AccessCheck(event.wiki, event.token, event.type);\\n  }\\n\\n  /*\\n    The handle message function, split out so we can use it other places\\n  */\\n  $tw.Bob.handleMessage = function(event) {\\n    $tw.Bob.logger.log('Received websocket message ', event, {level:4});\\n    let self = this;\\n    // Determine which connection the message came from\\n    const thisIndex = $tw.connections.findIndex(function(connection) {return connection.socket === self;});\\n    try {\\n      let eventData = JSON.parse(event);\\n      // Add the source to the eventData object so it can be used later.\\n      eventData.source_connection = thisIndex;\\n      // If the wiki on this connection hasn't been determined yet, take it\\n      // from the first message that lists the wiki.\\n      // After that the wiki can't be changed. It isn't a good security\\n      // measure but this part doesn't have real security anyway.\\n      // TODO figure out if this is actually a security problem.\\n      // We may have to add a check to the token before sending outgoing\\n      // messages.\\n      // This is really only a concern for the secure server, in that case\\n      // you authenticate the token and it only works if the wiki matches\\n      // and the token has access to that wiki.\\n      if(eventData.wiki && eventData.wiki !== $tw.connections[thisIndex].wiki && !$tw.connections[thisIndex].wiki) {\\n        $tw.connections[thisIndex].wiki = eventData.wiki;\\n        // Make sure that the new connection has the correct list of tiddlers\\n        // being edited.\\n        $tw.Bob.UpdateEditingTiddlers(false, eventData.wiki);\\n      }\\n      // Make sure that the connection is from the wiki the message is for.\\n      // This may not be a necessary security measure.\\n      // I don't think that not having this would open up any exploits but I am not sure.\\n      // TODO figure out if this is needed.\\n      if(eventData.wiki === $tw.connections[thisIndex].wiki) {\\n        // Make sure we have a handler for the message type\\n        if(typeof $tw.nodeMessageHandlers[eventData.type] === 'function') {\\n          // Check authorisation\\n          const authorised = authenticateMessage(eventData)\\n          if(authorised) {\\n            eventData.decoded = authorised\\n            $tw.nodeMessageHandlers[eventData.type](eventData);\\n          }\\n        } else {\\n          $tw.Bob.logger.error('No handler for message of type ', eventData.type, {level:3});\\n        }\\n      } else {\\n        $tw.Bob.logger.log('Target wiki and connected wiki don\\\\'t match', {level:3});\\n      }\\n    } catch (e) {\\n      $tw.Bob.logger.error(\\\"WebSocket error: \\\", e, {level:1});\\n    }\\n  }\\n\\n  /*\\n    This disconnects all connections that are for a specific wiki. this is used\\n    when unloading a wiki to make sure that people aren't trying to interact\\n    with a disconnected wiki.\\n  */\\n  $tw.Bob.DisconnectWiki = function (wiki) {\\n    $tw.connections.forEach(function(connectionIndex) {\\n      if(connectionIndex.wiki === wiki) {\\n        if(connectionIndex.socket !== undefined) {\\n          // Close the websocket connection\\n          connectionIndex.socket.terminate();\\n        }\\n      }\\n    })\\n  }\\n\\n  /*\\n    This checks to see if a wiki has no connected sockets and if not it unloads\\n    the wiki.\\n  */\\n  $tw.Bob.PruneConnections = function () {\\n    if($tw.settings.autoUnloadWikis === \\\"true\\\") {\\n      $tw.connections.forEach(function(connection) {\\n        if(connection.socket !== undefined) {\\n          if(connection.socket.readyState !== 1) {\\n            $tw.nodeMessageHandlers.unloadWiki({wikiName: connection.wiki});\\n            connection.socket.terminate();\\n            connection.socket = undefined;\\n          }\\n        }\\n      })\\n    }\\n  }\\n\\n  /*\\n    This updates the list of tiddlers being edited in each wiki. Any tiddler on\\n    this list has the edit button disabled to prevent two people from\\n    simultaneously editing the same tiddler.\\n    If run without an input it just re-sends the lists to each browser, with a\\n    tiddler title as input it appends that tiddler to the list and sends the\\n    updated list to all connected browsers.\\n\\n    For privacy and security only the tiddlers that are in the wiki a\\n    conneciton is using are sent to that connection.\\n  */\\n  $tw.Bob.UpdateEditingTiddlers = function (tiddler, wikiName) {\\n    // Make sure that the wiki is loaded\\n    const exists = $tw.ServerSide.loadWiki(wikiName);\\n    // This should never be false, but then this shouldn't every have been a\\n    // problem to start.\\n    if(exists) {\\n      // Check if a tiddler title was passed as input and that the tiddler isn't\\n      // already listed as being edited.\\n      // If there is a title and it isn't being edited add it to the list.\\n      if(tiddler && !$tw.Bob.EditingTiddlers[wikiName][tiddler]) {\\n        $tw.Bob.EditingTiddlers[wikiName][tiddler] = true;\\n      }\\n      Object.keys($tw.connections).forEach(function(index) {\\n        if($tw.connections[index].wiki === wikiName) {\\n          $tw.Bob.EditingTiddlers[wikiName] = $tw.Bob.EditingTiddlers[wikiName] || {};\\n          const list = Object.keys($tw.Bob.EditingTiddlers[wikiName]);\\n          const message = {type: 'updateEditingTiddlers', list: list, wiki: wikiName};\\n          $tw.Bob.SendToBrowser($tw.connections[index], message);\\n          $tw.Bob.logger.log('Update Editing Tiddlers', {level: 4})\\n        }\\n      });\\n    }\\n  }\\n\\n  /*\\n    This is a wrapper function that takes a message that is meant to be sent to\\n    all connected browsers and handles the details.\\n\\n    It iterates though all connections, checkis if each one is active, tries to\\n    send the message, if the sending fails than it sets the connection as\\n    inactive.\\n\\n    Note: This checks if the message is a string despite SendToBrowser also\\n    checking because if it needs to be changed and sent to multiple browsers\\n    changing it once here instead of once per browser should be better.\\n  */\\n  $tw.Bob.SendToBrowsers = function (message) {\\n    $tw.Bob.UpdateHistory(message);\\n    const messageData = $tw.Bob.Shared.createMessageData(message);\\n\\n    $tw.connections.forEach(function (connection) {\\n      if (connection.socket) {\\n        if (connection.socket.readyState === 1 && (connection.wiki === message.wiki || !message.wiki)) {\\n          $tw.Bob.Shared.sendMessage(message, connection.index, messageData);\\n        }\\n      }\\n    })\\n  }\\n\\n  /*\\n    This function sends a message to a single connected browser. It takes the\\n    browser connection object and the stringifyed message as input.\\n    If any attempt fails mark the connection as inacive.\\n\\n    On the server side the history is a bit more complex.\\n    There is one history of messages sent that has the message ids, each\\n    connection has a list of message ids that are still waiting for acks.\\n  */\\n  $tw.Bob.SendToBrowser = function (connection, message) {\\n    if(connection) {\\n      $tw.Bob.UpdateHistory(message);\\n      const messageData = $tw.Bob.Shared.createMessageData(message);\\n      if (connection.socket) {\\n        if (connection.socket.readyState === 1 && (connection.wiki === message.wiki || !message.wiki)) {\\n          $tw.Bob.Shared.sendMessage(message, connection.index, messageData);\\n        }\\n      }\\n    }\\n  }\\n\\n  /*\\n    This keeps a history of changes for each wiki so that when a wiki is\\n    disconnected and reconnects and asks to resync this can be used to resync\\n    the wiki with the minimum amount of network traffic.\\n\\n    Resyncing only needs to keep track of creating and deleting tiddlers here.\\n    The editing state of tiddlers is taken care of by the websocket\\n    reconnection process.\\n\\n    So this is just the list of deleted tiddlers and saved tiddlers with time\\n    stamps, and it should at most have one item per tiddler because the newest\\n    save or delete message overrides any previous messages.\\n\\n    The hisotry is an array of change entries\\n    Each entry in the history is in the form\\n    {\\n      title: tiddlerTitle,\\n      timestamp: changeTimeStamp,\\n      type: messageType\\n    }\\n  */\\n  $tw.Bob.UpdateHistory = function(message) {\\n    // Only save saveTiddler or deleteTiddler events that have a wiki listed\\n    if(['saveTiddler', 'deleteTiddler'].indexOf(message.type) !== -1 && message.wiki) {\\n      $tw.Bob.ServerHistory = $tw.Bob.ServerHistory || {};\\n      $tw.Bob.ServerHistory[message.wiki] = $tw.Bob.ServerHistory[message.wiki] || [];\\n      const entryIndex = $tw.Bob.ServerHistory[message.wiki].findIndex(function(entry) {\\n        return entry.title === message.tiddler.fields.title;\\n      })\\n      const entry = {\\n        timestamp: Date.now(),\\n        title: message.tiddler.fields.title,\\n        type: message.type\\n      }\\n      if(entryIndex > -1) {\\n        $tw.Bob.ServerHistory[message.wiki][entryIndex] = entry;\\n      } else {\\n        $tw.Bob.ServerHistory[message.wiki].push(entry);\\n      }\\n    }\\n  }\\n\\n  // Only act if we are running on node. Otherwise WebSocketServer will be\\n  // undefined.\\n  // Also we don't do this if we have an external server running things\\n  // we have to use the command line arguments because the externalserver\\n  // command hasn't run yet so we can't check $tw.ExternalServer\\n  if($tw.boot.argv.indexOf('--externalserver') === -1) {\\n    setup();\\n  }\\n}\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/NodeWikiCreationHandlers.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/NodeWikiCreationHandlers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/NodeWikiCreationHandlers.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThese are message handler functions for the web socket servers. Use this file\\nas a template for extending the web socket funcitons.\\n\\nThis handles messages sent to the node process.\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.platforms = [\\\"node\\\"];\\n\\nif($tw.node) {\\n  $tw.nodeMessageHandlers = $tw.nodeMessageHandlers || {};\\n  /*\\n    This builds a single file html version of the current wiki.\\n    This is a modified version of the renderTiddler command.\\n    It can exclude tiddlers from the wiki using a filter and it can include\\n    tiddlers form any served wiki.\\n    buildWiki - the name of the base wiki to build\\n    excludeList - a filter that returns tiddlers to exclude from the resulting single file wiki.\\n    ignoreDefaultExclude - if this is 'true' than the default exclude list is ignored\\n    outputFolder - the name of the folder to save the result in\\n    outputName - the file name to use for the resulting html file (this should include the .html suffix)\\n    externalTiddlers - a json object that contains information about other tiddlers to include in the resulting html file\\n\\n    About externalTiddlers:\\n      Each key is a the name of a wiki served by Bob, the value is a filter\\n      that will be run in that wiki and any returned tiddlers will be included in the output html file.\\n  */\\n  $tw.nodeMessageHandlers.buildHTMLWiki = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const path = require('path');\\n    const fs = require('fs');\\n    let wikiPath, fullName, excludeList = [];\\n    if(data.buildWiki) {\\n      const exists = $tw.ServerSide.loadWiki(data.buildWiki);\\n      if(exists) {\\n        wikiPath = $tw.Bob.Wikis[data.buildWiki].wikiPath || undefined;\\n        fullName = data.buildWiki;\\n      }\\n    } else {\\n      wikiPath = $tw.Bob.Wikis[data.wiki].wikiPath;\\n      fullName = data.wiki;\\n    }\\n    $tw.Bob.logger.log('Build HTML Wiki:', fullName, {level:1});\\n    if(data.excludeList) {\\n      // Get the excludeList from the provided filter, if it exists\\n      excludeList = $tw.Bob.Wikis[fullName].wiki.filterTiddlers(data.excludeList);\\n    } else {\\n      // Otherwise we want to ignore the server-specific plugins to keep things\\n      // small.\\n      excludeList = ['$:/plugins/OokTech/Bob', '$:/plugins/tiddlywiki/filesystem', '$:/plugins/tiddlywiki/tiddlyweb'];\\n    }\\n    if(data.ignoreDefaultExclude !== 'true') {\\n      const defaultExclude = $tw.Bob.Wikis[fullName].wiki.filterTiddlers('[prefix[$:/plugins/OokTech/Bob/]][[$:/plugins/OokTech/Bob]][prefix[$:/WikiSettings]][prefix[$:/Bob/]][[$:/ServerIP]][[$:/plugins/tiddlywiki/filesystem]][[$:/plugins/tiddlywiki/tiddlyweb]]');\\n      excludeList = excludeList.concat(defaultExclude);\\n    }\\n    if(wikiPath) {\\n      const outputFolder = data.outputFolder || 'output';\\n      const outputName = data.outputName || 'index.html';\\n      const outputFile = path.resolve(wikiPath, outputFolder, outputName);\\n      $tw.utils.createFileDirectories(outputFile);\\n      let tempWiki = new $tw.Wiki();\\n      $tw.Bob.Wikis[fullName].wiki.allTitles().forEach(function(title) {\\n        if(excludeList.indexOf(title) === -1) {\\n          tempWiki.addTiddler($tw.Bob.Wikis[fullName].wiki.getTiddler(title));\\n        }\\n      })\\n      // If there are external tiddlers to add try and add them\\n      GatherTiddlers (tempWiki, data.externalTiddlers, data.transformFilters, data.transformFilter, data.decoded)\\n      // Prepare the wiki\\n      tempWiki.registerPluginTiddlers(\\\"plugin\\\",[\\\"$:/core\\\"]);\\n      // Unpack plugin tiddlers\\n      tempWiki.readPluginInfo();\\n      tempWiki.unpackPluginTiddlers();\\n      const text = tempWiki.renderTiddler('text/plain',\\\"$:/core/save/all\\\", {\\n        variables:{\\n          wikiTiddlers:$tw.utils.stringifyList(tempWiki.allTitles())\\n        }\\n      });\\n      fs.writeFile(outputFile,text,\\\"utf8\\\",function(err) {\\n        if(err) {\\n            $tw.Bob.logger.error(err, {level:1});\\n          } else {\\n            $tw.Bob.logger.log('Built Wiki: ', outputFile, {level:1});\\n            const message = {\\n              alert: 'Saved html file ' + outputFile + ' to the server.',\\n              wikis: [data.buildWiki, data.wiki]\\n            };\\n            $tw.ServerSide.sendBrowserAlert(message);\\n          }\\n      });\\n    } else {\\n      $tw.Bob.logger.error(\\\"Can't find wiki \\\", fullName, \\\", is it listed in the Bob settings tab?\\\", {level:1});\\n    }\\n  }\\n\\n  /*\\n    This lets you create a new wiki from existing tiddlers in other wikis.\\n    Tiddlers from each wiki are selected by filters\\n\\n    inputs:\\n\\n    tiddlers - an array of tiddlers in json format\\n    wikiFolder - The name of the folder that holds your wikis\\n    wikiName - The name of the wiki to create or add to\\n    wikisPath - the path to the folder that holds the wikiFolder\\n    overwrite - if a wikiName is given and a wiki with that name already exists\\n    than the tiddlers will be added to that wiki instead of making a new wiki.\\n\\n    externalTiddlers - a json object that has filters to import tiddlers from\\n    existing wikis.\\n\\n    If overwrite is not set to 'yes' than wiki names are made unique. If you\\n    already have a wiki called MyWiki and give MyWiki as the wikiName parameter\\n    than a number will be appended to the end of the name to make it unique,\\n    similarly to how new tiddler titles are made unique.\\n  */\\n  $tw.nodeMessageHandlers.newWikiFromTiddlers = function (data) {\\n    // send ack first because otherwise it often takes too long to run this\\n    // command and the message is sent again.\\n    $tw.Bob.Shared.sendAck(data);\\n    // Do nothing unless there is an input file path given\\n    if(data.tiddlers || data.externalTiddlers) {\\n      const path = require('path');\\n      const fs = require('fs')\\n      let wikiName, wikiTiddlersPath, basePath;\\n      const wikiFolder = data.wikiFolder || \\\"Wikis\\\";\\n      // If there is no wikiname given create one\\n      if(data.wikiName) {\\n        if(data.overwrite !== 'yes') {\\n          // If a name is given use it\\n          wikiName = GetWikiName(data.wikiName);\\n        } else {\\n          wikiName = data.wikiName;\\n        }\\n      } else {\\n        // Otherwise create a new wikiname\\n        wikiName = GetWikiName();\\n      }\\n      // If there is no output path given use a default one\\n      if(data.wikisPath) {\\n        basePath = data.wikisPath;\\n      } else {\\n        basePath = $tw.ServerSide.getBasePath()\\n      }\\n\\n      // even if overwrite is set to true we need to make sure the wiki already\\n      // exists\\n      let exists = false;\\n      const wikiPath = path.join(basePath, wikiFolder, wikiName)\\n      if(data.overwrite === 'true') {\\n        exists = $tw.ServerSide.loadWiki(wikiName)\\n      }\\n\\n      // If we aren't overwriting or it doesn't already exist than make the new\\n      // wiki and load it\\n      if(!(typeof exists === 'string') || data.overwrite !== 'true') {\\n        // First copy the empty edition to the wikiPath to make the\\n        // tiddlywiki.info\\n        const params = {\\n          \\\"wiki\\\": data.wiki,\\n          \\\"basePath\\\": basePath,\\n          \\\"wikisFolder\\\": wikiFolder,\\n          \\\"edition\\\": \\\"empty\\\",\\n          \\\"path\\\": wikiName,\\n          \\\"wikiName\\\": wikiName,\\n          \\\"decoded\\\": data.decoded,\\n          \\\"fromServer\\\": true\\n        };\\n        $tw.nodeMessageHandlers.createNewWiki(params, nextPart);\\n        // Get the folder for the wiki tiddlers\\n        wikiTiddlersPath = path.join(basePath, wikiFolder, wikiName, 'tiddlers');\\n        // Make sure tiddlers folder exists\\n        try {\\n          fs.mkdirSync(wikiTiddlersPath);\\n          $tw.Bob.logger.log('Created Tiddlers Folder ', wikiTiddlersPath, {level:2});\\n        } catch (e) {\\n          $tw.Bob.logger.log('Tiddlers Folder Exists:', wikiTiddlersPath, {level:2});\\n        }\\n      } else {\\n        nextPart();\\n      }\\n      function nextPart() {\\n        // Load the empty wiki\\n        $tw.ServerSide.loadWiki(wikiName)\\n        // Add all the received tiddlers to the loaded wiki\\n        let count = 0;\\n        $tw.utils.each(data.tiddlers,function(tiddler) {\\n          // Save each tiddler using the syncadaptor\\n          // We don't save the components that are part of the empty edition\\n          // because we start with that\\n          if(tiddler.title !== '$:/core' && tiddler.title !== '$:/themes/tiddlywiki/snowwhite' && tiddler.title !== '$:/themes/tiddlywiki/vanilla') {\\n            $tw.syncadaptor.saveTiddler({fields: tiddler}, wikiName);\\n          }\\n          count++;\\n        });\\n        // If there are external tiddlers to add try and add them\\n        let tempWiki = new $tw.Wiki();\\n        GatherTiddlers(tempWiki, data.externalTiddlers, data.transformFilters, data.transformFilter, data.decoded);\\n        tempWiki.allTitles().forEach(function(tidTitle) {\\n          $tw.syncadaptor.saveTiddler(tempWiki.getTiddler(tidTitle), wikiName);\\n          count++;\\n        })\\n        if(!count) {\\n          $tw.Bob.logger.log(\\\"No tiddlers found in the input file\\\", {level:1});\\n        } else {\\n          $tw.Bob.logger.log(\\\"Wiki created\\\",{level:1});\\n          const message = {\\n            alert: 'Created wiki ' + wikiName,\\n            connections: [data.source_connection]\\n          };\\n          $tw.ServerSide.sendBrowserAlert(message);\\n          $tw.Bob.logger.log('Created wiki ', wikiName, {level: 2})\\n        }\\n        setTimeout(function() {\\n          $tw.Bob.Wikis[wikiName].modified = true;\\n          data.update = 'true';\\n          data.saveSettings = 'true';\\n          $tw.nodeMessageHandlers.findAvailableWikis(data);\\n        }, 1000);\\n      }\\n    } else {\\n      $tw.Bob.logger.log('No tiddlers given!', {level:1});\\n    }\\n  }\\n\\n  /*\\n    This takes an externalTiddlers object that lists wikis and filters that\\n    define the tiddlers to get from that wiki\\n\\n    inputs:\\n\\n    wiki - the $tw.Wiki object to add the tiddlers to\\n    externalTiddlers - a json object that lists the wikis and filters\\n    token - the access token, if any\\n  */\\n  function GatherTiddlers (wiki, externalTiddlers, transformFilters, transformFilter, decodedToken) {\\n    if(externalTiddlers) {\\n      try {\\n        let externalData = externalTiddlers\\n        if(typeof externalTiddlers !== 'object') {\\n          externalData = JSON.parse(externalTiddlers);\\n        }\\n        transformFilters = transformFilters || '{}'\\n        if(typeof transformFilters !== 'object') {\\n          transformFilters = JSON.parse(transformFilters);\\n        }\\n        Object.keys(externalData).forEach(function(wikiTitle) {\\n          const allowed = $tw.Bob.AccessCheck(wikiTitle, {\\\"decoded\\\": decodedToken}, 'view');\\n          if(allowed) {\\n            const exists = $tw.ServerSide.loadWiki(wikiTitle);\\n            if(exists) {\\n              const includeList = $tw.Bob.Wikis[wikiTitle].wiki.filterTiddlers(externalData[wikiTitle]);\\n              includeList.forEach(function(tiddlerTitle) {\\n                let tiddler = $tw.Bob.Wikis[wikiTitle].wiki.getTiddler(tiddlerTitle)\\n                // Transform the tiddler title if a transfom filter is given\\n                let txformFilter = transformFilter\\n                if(transformFilters) {\\n                  txformFilter = transformFilters[wikiTitle] || transformFilter;\\n                }\\n                if(txformFilter) {\\n                  const transformedTitle = ($tw.Bob.Wikis[wikiTitle].wiki.filterTiddlers(txformFilter, null, $tw.Bob.Wikis[wikiTitle].wiki.makeTiddlerIterator([tiddlerTitle])) || [\\\"\\\"])[0];\\n                  if(transformedTitle) {\\n                    tiddler = new $tw.Tiddler(tiddler,{title: transformedTitle});\\n                  }\\n                }\\n                wiki.addTiddler(tiddler);\\n              })\\n            }\\n          }\\n        });\\n      } catch (e) {\\n        $tw.Bob.logger.log(\\\"Couldn't parse externalTiddlers input:\\\", e, {level:1});\\n      }\\n    }\\n    return wiki;\\n  }\\n\\n  /*\\n    This ensures that the wikiName used is unique by appending a number to the\\n    end of the name and incrementing the number if needed until an unused name\\n    is created.\\n    If on name is given it defualts to NewWiki\\n  */\\n  function GetWikiName (wikiName, count, wikiObj, fullName) {\\n    let updatedName;\\n    count = count || 0;\\n    wikiName = wikiName || ''\\n    if(wikiName.trim() === '') {\\n      wikiName = 'NewWiki'\\n    }\\n    fullName = fullName || wikiName || 'NewWiki';\\n    wikiObj = wikiObj || $tw.settings.wikis;\\n    const nameParts = wikiName.split('/');\\n    if(nameParts.length === 1) {\\n      updatedName = nameParts[0];\\n      if(wikiObj[updatedName]) {\\n        if(wikiObj[updatedName].__path) {\\n          count = count + 1;\\n          while (wikiObj[updatedName + String(count)]) {\\n            if(wikiObj[updatedName + String(count)].__path) {\\n              count = count + 1;\\n            } else {\\n              break;\\n            }\\n          }\\n        }\\n      }\\n      if(count > 0) {\\n        return fullName + String(count);\\n      } else {\\n        return fullName;\\n      }\\n    } else if(!wikiObj[nameParts[0]]) {\\n      if(count > 0) {\\n        return fullName + String(count);\\n      } else {\\n        return fullName;\\n      }\\n    }\\n    if(nameParts.length > 1) {\\n      if(wikiObj[nameParts[0]]) {\\n        return GetWikiName(nameParts.slice(1).join('/'), count, wikiObj[nameParts[0]], fullName);\\n      } else {\\n        return fullName;\\n      }\\n    } else {\\n      return undefined\\n    }\\n  }\\n\\n  function addListing(wikiName, wikiPath, overwrite) {\\n    const pieces = wikiName.split('/');\\n    let current = $tw.settings.wikis\\n    for(let i = 0; i < pieces.length; i++) {\\n      current[pieces[i]] = current[pieces[i]] || {};\\n      current = current[pieces[i]];\\n    }\\n    if(!current.__path || overwrite) {\\n      current.__path = wikiPath;\\n    }\\n  }\\n\\n  /*\\n    This is the generic command for making a new wiki in Bob, it also covers\\n    just listing a non-bob wiki.\\n\\n    Anything that adds a wiki to the listing uses this.\\n  */\\n  // This is just a copy of the init command modified to work in this context\\n  $tw.nodeMessageHandlers.createNewWiki = function (data, cb) {\\n    $tw.Bob.Shared.sendAck(data);\\n    if(data.wiki === 'RootWiki' || true) {\\n      const fs = require(\\\"fs\\\"),\\n        path = require(\\\"path\\\");\\n      let name = GetWikiName(data.wikiName || data.newWiki);\\n\\n      if(data.nodeWikiPath) {\\n        // This is just adding an existing node wiki to the listing\\n        addListing(name, data.nodeWikiPath);\\n        data.fromServer = true;\\n        $tw.nodeMessageHandlers.saveSettings(data);\\n      } else if(data.tiddlers || data.externalTiddlers) {\\n        // Create a wiki using tiddlers sent from the browser, this is what is\\n        // used to create wikis from existing html files.\\n      } else if(data.fromWiki && data.newWiki) {\\n        // Duplicate a wiki\\n      } else {\\n        // Paths are relative to the root wiki path\\n        $tw.settings.wikisPath = $tw.settings.wikisPath || 'Wikis';\\n        data.wikisFolder = data.wikisFolder || $tw.settings.wikisPath;\\n        // If no basepath is given than the default is to place the folder in the\\n        // default wikis folder\\n        const basePath = data.basePath || $tw.ServerSide.getBasePath();\\n        // This is the path given by the person making the wiki, it needs to be\\n        // relative to the basePath\\n        // data.wikisFolder is an optional sub-folder to use. If it is set to\\n        // Wikis than wikis created will be in the basepath/Wikis/relativePath\\n        // folder I need better names here.\\n        $tw.utils.createDirectory(path.join(basePath, data.wikisFolder));\\n        // This only does something for the secure wiki server\\n        if($tw.settings.namespacedWikis === 'true') {\\n          data.decoded = data.decoded || {};\\n          data.decoded.name = data.decoded.name || 'imaginaryPerson';\\n          name = data.decoded.name + '/' + (data.wikiName || data.newWiki);\\n          name = GetWikiName(name);\\n          relativePath = name;\\n          $tw.utils.createDirectory(path.join(basePath, data.decoded.name));\\n        }\\n        const fullPath = path.join(basePath, data.wikisFolder, name)\\n        // For now we only support creating wikis with one edition, multi edition\\n        // things like in the normal init command can come later.\\n        const editionName = data.edition?data.edition:\\\"empty\\\";\\n        const searchPaths = $tw.getLibraryItemSearchPaths($tw.config.editionsPath,$tw.config.editionsEnvVar);\\n        let editionPath = $tw.findLibraryItem(editionName,searchPaths);\\n        if(!fs.existsSync(editionPath) && false) {\\n          editionPath = undefined\\n          editionPath = path.resolve(__dirname, \\\"./editions\\\", \\\"./\\\" + editionName);\\n          if(fs.existsSync(editionPath)) {\\n            try {\\n              $tw.ServerSide.specialCopy(editionPath, fullPath);\\n              $tw.Bob.logger.log(\\\"Copied edition '\\\" + editionName + \\\"' to \\\" + fullPath + \\\"\\\\n\\\", {level:2});\\n            } catch (e) {\\n              $tw.Bob.logger.error('error copying edition ', editionName, e, {level:1});\\n            }\\n          } else {\\n            $tw.Bob.logger.error(\\\"Edition not found \\\", editionName, {level:1});\\n          }\\n        } else {\\n          // Copy the edition content\\n          const err = $tw.ServerSide.specialCopy(editionPath, fullPath, true);\\n          if(!err) {\\n            $tw.Bob.logger.log(\\\"Copied edition '\\\" + editionName + \\\"' to \\\" + fullPath + \\\"\\\\n\\\", {level:2});\\n          } else {\\n            $tw.Bob.logger.error(err, {level:1});\\n          }\\n        }\\n        // Tweak the tiddlywiki.info to remove any included wikis\\n        const packagePath = path.join(fullPath, \\\"tiddlywiki.info\\\");\\n        let packageJson = {};\\n        try {\\n          packageJson = JSON.parse(fs.readFileSync(packagePath));\\n        } catch (e) {\\n          $tw.Bob.logger.error('failed to load tiddlywiki.info file', e, {level:1});\\n        }\\n        delete packageJson.includeWikis;\\n        try {\\n          fs.writeFileSync(packagePath,JSON.stringify(packageJson,null,$tw.config.preferences.jsonSpaces));\\n        } catch (e) {\\n          $tw.Bob.logger.error('failed to write tiddlywiki.info ', e, {level:1})\\n        }\\n\\n        // This is here as a hook for an external server. It is defined by the\\n        // external server and shouldn't be defined here or it will break\\n        // If you are not using an external server than this does nothing\\n        if($tw.ExternalServer) {\\n          if(typeof $tw.ExternalServer.initialiseWikiSettings === 'function') {\\n            $tw.ExternalServer.initialiseWikiSettings(relativePath, data);\\n          }\\n        }\\n      }\\n\\n      setTimeout(function() {\\n        data.update = 'true';\\n        data.saveSettings = 'true';\\n        $tw.nodeMessageHandlers.findAvailableWikis(data);\\n        if(typeof cb === 'function') {\\n          setTimeout(cb, 1500);\\n        }\\n      }, 1000);\\n\\n      const message = {\\n        alert: 'Created wiki ' + name,\\n        connections: [data.source_connection]\\n      };\\n      $tw.ServerSide.sendBrowserAlert(message);\\n      $tw.Bob.logger.log('Created wiki ', name, {level: 2})\\n    }\\n  }\\n\\n  /*\\n    This downloads the single html file version of a wiki\\n    It defaults to the current wiki but if you give a forWiki input it\\n    downloads that wiki instead.\\n  */\\n  $tw.nodeMessageHandlers.downloadHTMLFile = function (data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    if(data.wiki) {\\n      const downloadWiki = data.forWiki || data.wiki;\\n      const allowed = $tw.Bob.AccessCheck(downloadWiki, {\\\"decoded\\\":data.decoded}, 'view');\\n      if(allowed) {\\n        const path = require('path');\\n        const fs = require('fs');\\n        try {\\n          const outputFilePath = path.join($tw.Bob.Wikis[data.wiki].wikiPath, 'output', 'index.html');\\n          const file = fs.readFileSync(outputFilePath);\\n          // Send file to browser in a websocket message\\n          const message = {'type': 'downloadFile', 'file': file};\\n          $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message);\\n          $tw.Bob.logger.log('Downloading wiki ', name, {level: 2})\\n        } catch (e) {\\n          $tw.Bob.logger.error('Error:', e, {level:1})\\n        }\\n      }\\n    }\\n  }\\n\\n  /*\\n    This message fetches tiddlers from another wiki on the same Bob server\\n    The input data object has:\\n      fromWiki - the name of the wiki to pull from\\n      filter - the tiddler filter to use to select tiddlers from the remote\\n        wiki\\n      transformFilter - the titles of imported tiddlers are modified by this\\n        filter.\\n      resolution - how conflicts are handled\\n        - manual - all tiddlers are saved in a temporary place and have to be\\n          manually accepted or rejected\\n        - conflct - only tiddlers that conflict with existing tiddlers are\\n          saved in a temporary place to be accepted or rejected.\\n        - force - all imported tiddlers are saved regardelss of conflicts\\n  */\\n  $tw.nodeMessageHandlers.internalFetch = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    // Make sure that the person has access to the wiki\\n    const authorised = $tw.Bob.AccessCheck(data.fromWiki, {\\\"decoded\\\":data.decoded}, 'view');\\n    if(authorised) {\\n      let externalTiddlers = {};\\n      if(data.externalTiddlers) {\\n        try {\\n          externalTiddlers = JSON.parse(data.externalTiddlers);\\n        } catch (e) {\\n          $tw.Bob.logger.error(\\\"Can't parse externalTiddlers\\\", {level:1});\\n        }\\n      }\\n      externalTiddlers[data.fromWiki] = data.filter\\n      let tempWiki = new $tw.Wiki();\\n      GatherTiddlers(tempWiki, externalTiddlers, data.transformFilters, data.transformFilter, data.decoded);\\n\\n      // Add the results to the current wiki\\n      // Each tiddler gets added to the requesting wiki\\n      let list = []\\n      let message\\n      tempWiki.allTitles().forEach(function(tidTitle){\\n        // Get the current tiddler\\n        const tiddler = tempWiki.getTiddler(tidTitle);\\n        list.push(tiddler.fields.title)\\n        // Create the message with the appropriate conflict resolution\\n        // method and send it\\n        if(data.resolution === 'conflict') {\\n          message = {\\n            type: 'conflict',\\n            message: 'saveTiddler',\\n            tiddler: tiddler,\\n            wiki: data.wiki\\n          };\\n        } else if(data.resolution === 'force') {\\n          message = {\\n            type: 'saveTiddler',\\n            tiddler: tiddler,\\n            wiki: data.wiki\\n          };\\n        } else {\\n          message = {\\n            type: 'import',\\n            tiddler: tiddler,\\n            wiki: data.wiki\\n          };\\n        }\\n        $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message)\\n      })\\n      // Make the import list and send that tiddler too\\n      const importListTiddler = {\\n        fields: {\\n          title: '$:/status/Bob/importlist',\\n          tags: [],\\n          list: list\\n        }\\n      };\\n      message = {\\n        type: 'saveTiddler',\\n        tiddler: importListTiddler,\\n        wiki: data.wiki\\n      };\\n      $tw.Bob.SendToBrowser($tw.connections[data.source_connection], message)\\n      if (data.resolution !== 'force') {\\n        const thisMessage = {\\n          alert: 'Fetched Tiddlers, see import list',\\n          wikis: [data.wiki]\\n        };\\n        $tw.ServerSide.sendBrowserAlert(thisMessage);\\n      }\\n      $tw.Bob.logger.log('Fetched tiddlers', {level: 2})\\n      $tw.Bob.logger.log('Fetched ',list, {level: 4})\\n    }\\n  }\\n\\n  /*\\n    This creates a duplicate of an existing wiki, complete with any\\n    wiki-specific media files\\n\\n    {\\n      wiki: callingWiki,\\n      fromWiki: fromWikiName,\\n      newWiki: newWikiName,\\n      copyChildren: copyChildren\\n    }\\n\\n    fromWiki - the name of the wiki to duplicate\\n    newWiki - the name of the new wiki created\\n    copyChildren - if true than any child wikis contained in the fromWiki\\n    folder are also copied.\\n\\n    If no fromWiki is given, or the name doesn't match an existing wiki, than\\n    the empty edition is used, if no newWiki is given than the default new name\\n    is used.\\n  */\\n  $tw.nodeMessageHandlers.duplicateWiki = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const path = require('path');\\n    const fs = require('fs');\\n    // Make sure that the wiki to duplicate exists and that the target wiki\\n    // name isn't in use\\n    const authorised = $tw.Bob.AccessCheck(data.fromWiki, {\\\"decoded\\\":data.decoded}, 'duplicate');\\n    if(typeof data.fromWiki === 'undefined') {\\n      return;\\n    }\\n    if ($tw.ServerSide.existsListed(data.fromWiki) && authorised) {\\n      const wikiName = GetWikiName(data.newWiki);\\n      // Get the paths for the source and destination\\n      $tw.settings.wikisPath = $tw.settings.wikisPath || './Wikis';\\n      const source = $tw.ServerSide.getWikiPath(data.fromWiki);\\n      const basePath = $tw.ServerSide.getBasePath();\\n      const destination = path.resolve(basePath, $tw.settings.wikisPath, wikiName);\\n      data.copyChildren = data.copyChildren || 'no';\\n      const copyChildren = data.copyChildren.toLowerCase() === 'yes'?true:false;\\n      // Make the duplicate\\n      $tw.ServerSide.specialCopy(source, destination, copyChildren, function() {\\n        // Refresh wiki listing\\n        data.update = 'true';\\n        data.saveSettings = 'true';\\n        $tw.nodeMessageHandlers.findAvailableWikis(data);\\n        const message = {\\n          alert: 'Created wiki ' + wikiName,\\n          connections: [data.source_connection]\\n        };\\n        $tw.ServerSide.sendBrowserAlert(message);\\n        $tw.Bob.logger.log('Duplicated wiki', data.fromWiki, 'as', wikiName, {level: 2})\\n      });\\n    }\\n  }\\n}\\n})()\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/OokTech/Bob/Folding Wiki Listing\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Folding Wiki Listing\",\n            \"caption\": \"Folding Wiki Listing\",\n            \"tags\": \"$:/tags/Macro\",\n            \"text\": \"\\\\define thisFoldingWikiListingMakeState() $:/state/FoldingWikiList/$(currentTiddler)$/$(WikiPrefix)$$(WikiName)$\\n\\n\\\\define thisFoldingWikiListingMakeURL() /$(WikiPrefix)$$(WikiName)$\\n\\n\\\\define thisFoldingWikiListingMakeWikiListingTab()\\n<$action-setfield\\n  $tiddler='$:/plugins/OokTech/Bob/SideBarTab'\\n  tags='$:/tags/SideBar'\\n  text='{{$:/plugins/OokTech/Bob/Wiki Listing}}'\\n  caption='Wikis'\\n/>\\n\\\\end\\n\\n\\\\define thisFoldingWikiListingRemoveWikiListingTab()\\n<$action-setfield\\n  $tiddler='$:/plugins/OokTech/Bob/SideBarTab'\\n  text=''\\n/>\\n<$action-deletetiddler\\n  $tiddler='$:/plugins/OokTech/Bob/SideBarTab'\\n/>\\n\\\\end\\n\\n\\\\define thisFoldingWikiListingInnerList()\\n  <$list\\n    filter='[subfilter<InputList>removeprefix<WikiPrefix>splitbefore<Sep>prefix<WikiName>] +[sort[]]'\\n    variable=WikiName\\n  >\\n    <$list\\n      filter=\\\"[<WikiName>suffix<Sep>]\\\"\\n      variable=unused\\n    >\\n      <$list\\n        filter=\\\"[<WikiName>]\\\"\\n        variable=InnerWikiName\\n      >\\n        <li>\\n          <!-- Button for collapsing this part -->\\n          <$button\\n            class='tc-btn-invisible'\\n          >\\n            <$reveal\\n              state=<<thisFoldingWikiListingMakeState>>\\n              text='show'\\n              type='match'\\n            >\\n              {{$:/core/images/chevron-down}}\\n              <$action-setfield\\n                $tiddler=<<thisFoldingWikiListingMakeState>>\\n                text=hide\\n              />\\n            </$reveal>\\n            <$reveal\\n              state=<<thisFoldingWikiListingMakeState>>\\n              text='show'\\n              type='nomatch'\\n            >\\n              {{$:/core/images/chevron-right}}\\n              <$action-setfield\\n                $tiddler=<<thisFoldingWikiListingMakeState>>\\n                text=show\\n              />\\n            </$reveal>\\n          </$button>\\n          <!-- The text for the current entry -->\\n          <$set\\n            name=TEMP\\n            filter='[<InnerWikiName>removesuffix<Sep>]'\\n          >\\n            <$list\\n              filter=\\\"[subfilter<InputList>removeprefix<WikiPrefix>splitbefore<Sep>prefix<TEMP>suffix<TEMP>limit[1]]\\\"\\n              emptyMessage=\\\"\\\"\\\"\\n              <!-- Parts of paths to wikis that aren't wiki names -->\\n              <<__notexist__>>\\n              \\\"\\\"\\\"\\n              variable=unused\\n            >\\n              <!-- Wikis that exist and are part of paths to other wikis -->\\n              <<__exist__>>\\n            </$list>\\n          </$set>\\n          <!-- Recurse for the next level -->\\n          <$reveal\\n            state=<<thisFoldingWikiListingMakeState>>\\n            text='show'\\n            type='match'\\n          >\\n            <$set\\n              name=WikiName\\n              value=\\\"\\\"\\n            >\\n              <$set\\n                name=WikiPrefix\\n                filter='[<WikiPrefix>addsuffix<InnerWikiName>]'\\n              >\\n                <ul>\\n                  <<thisFoldingWikiListingInnerList>>\\n                </ul>\\n              </$set>\\n            </$set>\\n          </$reveal>\\n        </li>\\n      </$list>\\n    </$list>\\n    <$list\\n      filter='[<WikiName>!suffix<Sep>] -[subfilter<InputList>removeprefix<WikiPrefix>splitbefore<Sep>prefix<WikiName>suffix<Sep>removesuffix<Sep>]'\\n      variable=WikiName\\n    >\\n      <li>\\n      <<__exist__>>\\n      </li>\\n    </$list>\\n  </$list>\\n\\\\end\\n\\n\\\\define existsTemplate()\\n<a\\n  href=<<thisFoldingWikiListingMakeURL>>\\n  target='_blank'\\n>\\n  <$text\\n    text=<<WikiName>>\\n  />\\n</a>\\n^^<span style='font-size:8pt;'>\\n(<$button\\n  class='tc-btn-invisible'\\n>\\n  Unload\\n  <$action-websocketmessage\\n    $type='unloadWiki'\\n    wikiName=<<WikiName>>\\n  />\\n</$button>)\\n</span>^^\\n\\\\end\\n\\n\\\\define doesntExistTemplate()\\n<$text\\n  text=<<InnerWikiName>>\\n/>\\n\\\\end\\n\\n\\\\define foldingTree(source:'[list[$:/state/ViewableWikis]]' sep:'/' exist:\\\"<<existsTemplate>>\\\" notexist:\\\"<<doesntExistTemplate>>\\\")\\n<$vars\\n  InputList=<<__source__>>\\n  Sep=<<__sep__>>\\n>\\n  <ul\\n    class='folding-list'\\n  >\\n    <$list\\n      filter='[subfilter<InputList>splitbefore<Sep>removesuffix<Sep>][subfilter<InputList>splitbefore<Sep>!suffix<Sep>] +[sort[]]'\\n      variable=WikiName\\n      emptyMessage='No child wikis listed.'\\n    >\\n      <$set\\n        name=WikiPrefix\\n        value=''\\n      >\\n        <<thisFoldingWikiListingInnerList>>\\n      </$set>\\n    </$list>\\n  </ul>\\n</$vars>\\n\\\\end\\n\\n! Folding Tree List\\n\\nThis was originally made to list the different wikis that I manage with Bob.\\nAnd I forgot that the core `tree` macro existed, although I needed some\\nfeatures that the core macro doesn't have, like templating each entry.\\n\\n!! Parameters\\n\\n|!Name |!Description |!Default |\\n|!source |The input titles to use while making the tree. To get the same output as from the core macro use `[is[system]]` |`[list[$:/state/ViewableWikis]]` |\\n|!sep |The separator used to distinguish different levels of the tree. |`/` |\\n|!exist |A template to use when an item in the tree exists. |`<<existsTemplate>>` |\\n|!notexist |A template to use when an item in the tree doesn't exist (it is part of the path to another item) |`<<doesntExistTemplate>>` |\\n\\n<<foldingTree>>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Wiki Listing\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Wiki Listing\",\n            \"caption\": \"Wiki Listing\",\n            \"text\": \"\\\\define thisWikiListingMakeURL() /$(WikiName)$\\n\\n\\\\define thisWikiListingMakeWikiListingTab()\\n<$action-setfield\\n  $tiddler='$:/plugins/OokTech/Bob/SideBarTab'\\n  tags='$:/tags/SideBar'\\n  text=\\\"\\\"\\\"{{$:/plugins/OokTech/Bob/Wiki Listing}}\\\"\\\"\\\"\\n  caption='Wikis'\\n/>\\n\\\\end\\n\\n\\\\define thisWikiListingRemoveWikiListingTab()\\n<$action-setfield\\n  $tiddler='$:/plugins/OokTech/Bob/SideBarTab'\\n  text=''\\n/>\\n<$action-deletetiddler\\n  $tiddler='$:/plugins/OokTech/Bob/SideBarTab'\\n/>\\n\\\\end\\n\\n\\\\define makeWikiListing()\\n<h2 style='margin:0px;padding:0px;'>Available Wikis</h2>\\n<div\\n  style='font-size:12px;display:inline-block;'\\n>\\n  <$checkbox\\n    actions=<<thisWikiListingMakeWikiListingTab>>\\n    uncheckactions=<<thisWikiListingRemoveWikiListingTab>>\\n    tiddler='$:/settings/Bob/ListInSidebar'\\n    field='text'\\n    checked='yes'\\n    unchecked='no'\\n  >\\n    List in sidebar\\n  </$checkbox>\\n\\n  <$checkbox\\n    tiddler='$:/settings/Bob/ListInSidebar'\\n    field='folding'\\n    checked='true'\\n    unchecked='false'\\n  >\\n    Use folding list\\n  </$checkbox>\\n  <$button>\\n    Update List\\n    <$action-websocketmessage\\n      $type='findAvailableWikis'\\n      remove={{$:/settings/Bob/removemissingwikis!!text}}\\n      update='true'\\n      saveSettings='true'\\n    />\\n  </$button>\\n</div>\\n\\n---\\n\\n<$list\\n  filter='[[$:/settings/Bob/ListInSidebar]has[folding]get[folding]!prefix[true]limit[1]]'\\n  prefix='true'\\n  emptyMessage=\\\"\\\"\\\"<<foldingTree>>\\\"\\\"\\\"\\n>\\n  <$list\\n    filter='[list[$:/state/ViewableWikis]]'\\n    variable=WikiName\\n    emptyMessage='No child wikis listed.'\\n  >\\n    <li>\\n      <a\\n        href=<<thisWikiListingMakeURL>>\\n        target='_blank'\\n      >\\n        <$text\\n          text=<<WikiName>>\\n        />\\n      </a>\\n      ^^<span style='font-size:8pt;'>\\n      (<$button\\n        class='tc-btn-invisible'\\n      >\\n        Unload\\n        <$action-websocketmessage\\n          $type='unloadWiki'\\n          wikiName=<<WikiName>>\\n        />\\n      </$button>)\\n      </span>^^\\n    </li>\\n  </$list>\\n</$list>\\n\\\\end\\n\\n<<makeWikiListing>>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/ChatMessageHandlers.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/ChatMessageHandlers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/ChatMessageHandlers.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThese are message handler functions for the federated chat server.\\nThis handles messages sent to the node process.\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.platforms = [\\\"node\\\"];\\n\\nif($tw.node) {\\n  $tw.nodeMessageHandlers = $tw.nodeMessageHandlers || {};\\n\\n  /*\\n    Receive a chat message from a browser, they are automatically sent to other connected browsers when the tiddlers are synced.\\n  */\\n  $tw.nodeMessageHandlers.chatMessage = function(data) {\\n    $tw.Bob.Shared.sendAck(data);\\n    const conversationTiddler = data.conversation || 'DefaultChat'\\n    if (conversationTiddler && data.message) {\\n      // Get the history tiddler\\n      const historyTiddler = $tw.Bob.Wikis[data.wiki].wiki.getTiddler(`$:/chat/${conversationTiddler}`)\\n      let history = {}\\n      if (historyTiddler) {\\n        // Make sure that the fields aren't read only\\n        history = JSON.parse(JSON.stringify(historyTiddler.fields.text));\\n      }\\n      const theTime = $tw.utils.stringifyDate(new Date());\\n      if (typeof history === 'string') {\\n        history = JSON.parse(history);\\n      }\\n      // Add new message\\n      history[theTime] = {\\n        message:data.message,\\n        from: data.from,\\n        server: data.server,\\n        conversation: data.conversation\\n      }\\n      // save the updated tiddler\\n      $tw.syncadaptor.saveTiddler(new $tw.Tiddler({\\n        text:JSON.stringify(history, null, 2),\\n        title: `$:/chat/${conversationTiddler}`,\\n        type: 'application/json'\\n      }), data.wiki);\\n      if ($tw.settings.enableFederation === 'yes') {\\n        // Send it to any connected servers\\n        $tw.Bob.Federation.sendToRemoteServers(data);\\n      }\\n    }\\n  }\\n}\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/Bob/Federation/Chat/styles\": {\n            \"title\": \"$:/plugins/Bob/Federation/Chat/styles\",\n            \"tags\": \"$:/tags/Stylesheet\",\n            \"text\": \".defaultChatHistoryView {\\n  min-height: 3em;\\n  max-height: 30em;\\n  width: 100%;\\n  overflow: scroll;\\n  border: solid 1px grey;\\n}\\n\\n.defaultChatHistoryViewOddMessages {\\n  background-color: #4441;\\n}\\n\\n.defaultChatHistoryViewEvenMessages {\\n\\n}\\n\\n.defaultChatInput {\\n\\n}\\n\\n.defaultChatSendButton {\\n\\n}\\n\\n.chatDateDisplay {\\n  font-size: 10px;\\n  line-height: 10px;\\n}\\n\\n.chatNameDisplay {\\n  font-size: 10px;\\n  line-height: 10px;\\n  font-weight: bold;\\n  position:relative;\\n}\\n\\n.chatNameDisplay:after {\\n    content: \\\"<br/> \\\";\\n    display: block;\\n    position: relative;\\n}\\n\\n.chatMessageDisplay {\\n\\n}\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/chatview.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/chatview.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/Federation/chatview.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nA widget that creates a view of a chat hisotry.\\n\\nTODO get something to indicate if different messages have been seen or not.\\n\\nProbably go through each div and see if it has been completely inside the\\nvisible part of the text.\\n\\n\\\\*/\\n\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nconst Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nconst ChatView = function(parseTreeNode,options) {\\n  this.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nChatView.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nChatView.prototype.render = function(parent,nextSibling) {\\n  this.parentDomNode = parent;\\n  this.computeAttributes();\\n  this.execute();\\n\\n  this.id = this.id || Math.random()*1000;\\n  // The full container div\\n  const containerDiv = this.document.createElement('div');\\n  containerDiv.classList.add(this.class);\\n  containerDiv.id = this.id;\\n  // The tiddler should be a json tiddler so we get the json object here\\n  const historyTiddlerThing = this.wiki.getTiddler(this.historyTiddler);\\n  let chatHistoryObject = {};\\n  if (historyTiddlerThing) {\\n    try {\\n      chatHistoryObject = JSON.parse(historyTiddlerThing.fields.text);\\n    } catch (e) {\\n\\n    }\\n  }\\n  const format = this.format || '0hh:0mm:0ss';\\n  // For each line in the history append a div with that message in it.\\n  Object.keys(chatHistoryObject).slice().sort().forEach(function(messageTimestamp, messageIndex) {\\n    if(!chatHistoryObject[messageTimestamp].message) {\\n      return;\\n    }\\n    const dateDisplay = $tw.utils.formatDateString($tw.utils.parseDate(messageTimestamp),format);\\n    const newElement = document.createElement('div');\\n    newElement.innerHTML = `<span\\n        class='chatDateDisplay'\\n      >\\n        ${dateDisplay}\\n      </span>\\n      <span\\n        class='chatNameDisplay'\\n      >\\n        ${chatHistoryObject[messageTimestamp].from || 'Nameless Interloper'}:\\n      </span>\\n      <span\\n        class='chatMessageDisplay'\\n      >\\n        ${chatHistoryObject[messageTimestamp].message}\\n      </span>`;\\n    if (messageIndex % 2 === 0) {\\n      newElement.classList.add('defaultChatHistoryViewEvenMessages');\\n    } else {\\n      newElement.classList.add('defaultChatHistoryViewOddMessages');\\n    }\\n    containerDiv.appendChild(newElement);\\n  })\\n\\n  parent.insertBefore(containerDiv,nextSibling);\\n  this.renderChildren(containerDiv,null);\\n\\n  // This determines if the div is scrolled to the bottom, if so than\\n  // the text scrolls up, if not than the div position is maintained so\\n  // it doesn't move what you are looking at out of frame.\\n  const isScrolledToBottom = this.scrollPosition + containerDiv.clientHeight >= containerDiv.scrollHeight - 50;\\n  if (this.scrollPosition === 0) {\\n    this.scrollPosition = containerDiv.scrollHeight;\\n  }\\n\\n  if (isScrolledToBottom) {\\n    containerDiv.scrollTop = containerDiv.scrollHeight;\\n  } else {\\n    containerDiv.scrollTop = this.scrollPosition;\\n  }\\n  this.domNodes.push(containerDiv);\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nChatView.prototype.execute = function() {\\n  //Get widget attributes.\\n  this.historyTiddler = this.getAttribute('tiddler', '$:/chat/DefaultChat');\\n  this.historyLimit = this.getAttribute('limit', 100);\\n  this.class = this.getAttribute('class', 'defaultChatHistoryView');\\n  this.scrollPosition = this.scrollPosition || 0;\\n  this.format = this.getAttribute('format', '0hh:0mm:0ss');\\n};\\n\\n/*\\nRefresh the widget by ensuring our attributes are up to date\\n*/\\nChatView.prototype.refresh = function(changedTiddlers) {\\n  const changedAttributes = this.computeAttributes();\\n  if(Object.keys(changedAttributes).length > 0 || changedTiddlers[this.historyTiddler]) {\\n    const containerDiv = this.document.getElementById(this.id);\\n    this.scrollPosition = containerDiv.scrollTop;\\n    this.refreshSelf();\\n    return true;\\n  }\\n  return true;\\n};\\n\\nexports[\\\"chatview\\\"] = ChatView;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/OokTech/Bob/commands/externalserver.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/commands/externalserver.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/commands/externalserver.js\\ntype: application/javascript\\nmodule-type: command\\n\\nServe tiddlers using a two-way websocket server over http\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.info = {\\n  name: \\\"externalserver\\\",\\n  synchronous: true\\n};\\n\\nexports.platforms = [\\\"node\\\"];\\n\\nif($tw.node) {\\n  const Command = function(params,commander,callback) {\\n    this.params = params;\\n    this.commander = commander;\\n    this.callback = callback;\\n    // Commands that are just for the server\\n    $tw.ServerSide = require('$:/plugins/OokTech/Bob/ServerSide.js');\\n  };\\n\\n  Command.prototype.execute = function() {\\n    const bobVersion = $tw.wiki.getTiddler('$:/plugins/OokTech/Bob').fields.version\\n    $tw.Bob.logger.log('TiddlyWiki version', $tw.version, 'with Bob version', bobVersion, {level: 0})\\n\\n    // Get the ip address to display to make it easier for other computers to\\n    // connect.\\n    const ip = require('$:/plugins/OokTech/Bob/External/IP/ip.js');\\n    const ipAddress = ip.address();\\n    $tw.settings.serverInfo = {\\n      ipAddress: ipAddress\\n    };\\n\\n    return null;\\n  };\\n\\n  exports.Command = Command;\\n}\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"command\"\n        },\n        \"$:/plugins/OokTech/Bob/ws-server-default-settings\": {\n            \"title\": \"$:/plugins/OokTech/Bob/ws-server-default-settings\",\n            \"type\": \"application/json\",\n            \"text\": \"{\\n  \\\"ws-server\\\": {\\n    \\\"port\\\": \\\"8080\\\",\\n    \\\"rootTiddler\\\": \\\"$:/plugins/OokTech/Bob/save/single\\\",\\n    \\\"renderType\\\": \\\"text/plain\\\",\\n    \\\"serveType\\\": \\\"text/html\\\",\\n    \\\"username\\\": \\\"\\\",\\n    \\\"password\\\": \\\"\\\",\\n    \\\"host\\\": \\\"127.0.0.1\\\",\\n    \\\"pathprefix\\\": \\\"\\\"\\n  }\\n}\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/commands/wsserver.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/commands/wsserver.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/OokTech/Bob/commands/wsserver.js\\ntype: application/javascript\\nmodule-type: command\\n\\nServe tiddlers using a two-way websocket server over http\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.info = {\\n  name: \\\"wsserver\\\",\\n  synchronous: true\\n};\\n\\nexports.platforms = [\\\"node\\\"];\\n\\nif($tw.node) {\\n  const URL = require(\\\"url\\\"),\\n    path = require(\\\"path\\\"),\\n    http = require(\\\"http\\\")\\n\\n  /*\\n  A simple HTTP server with regexp-based routes\\n  */\\n  function SimpleServer(options) {\\n    this.routes = options.routes || [];\\n    this.wiki = options.wiki;\\n    this.variables = options.variables || {};\\n  }\\n\\n  SimpleServer.prototype.set = function(obj) {\\n    let self = this;\\n    $tw.utils.each(obj,function(value,name) {\\n      self.variables[name] = value;\\n    });\\n  };\\n\\n  SimpleServer.prototype.get = function(name) {\\n    return this.variables[name];\\n  };\\n\\n  SimpleServer.prototype.addRoute = function(route) {\\n    this.routes.push(route);\\n  };\\n\\n  // Add route but make sure it isn't a duplicate.\\n  SimpleServer.prototype.updateRoute = function (route) {\\n    // Remove any routes that have the same path as the input\\n    this.routes = this.routes.filter(function(thisRoute) {\\n      return String(thisRoute.path) !== String(route.path);\\n    });\\n    // Push on the new route.\\n    this.routes.push(route);\\n  }\\n\\n  // This removes all but the root wiki from the routes\\n  SimpleServer.prototype.clearRoutes = function () {\\n    // Remove any routes that don't match the root path\\n    this.routes = this.routes.filter(function(thisRoute) {\\n      return String(thisRoute.path) === String(/^\\\\/$/) || String(thisRoute.path) === String(/^\\\\/favicon.ico$/);\\n    });\\n  }\\n\\n  SimpleServer.prototype.findMatchingRoute = function(request,state) {\\n    let pathprefix = this.get(\\\"pathprefix\\\") || \\\"\\\";\\n    pathprefix = pathprefix.startsWith(\\\"/\\\") ? pathprefix : \\\"/\\\" + pathprefix;\\n    let pathname = decodeURIComponent(state.urlInfo.pathname);\\n    if(!pathname.startsWith(pathprefix)) {\\n      return null;\\n    }\\n    pathname = pathname.replace(pathprefix,'');\\n    pathname = pathname.startsWith('/') ? pathname : '/' + pathname;\\n    for(let t=0; t<this.routes.length; t++) {\\n      const potentialRoute = this.routes[t];\\n      let match;\\n      if(typeof potentialRoute.path.exec === 'function') {\\n        match = potentialRoute.path.exec(pathname);\\n      }\\n      if(match && request.method === potentialRoute.method) {\\n        state.params = [];\\n        for(let p=1; p<match.length; p++) {\\n          state.params.push(match[p]);\\n        }\\n        return potentialRoute;\\n      }\\n    }\\n    return null;\\n  };\\n\\n  SimpleServer.prototype.checkCredentials = function(request,incomingUsername,incomingPassword) {\\n    const header = request.headers.authorization || \\\"\\\",\\n      token = header.split(/\\\\s+/).pop() || \\\"\\\",\\n      auth = $tw.utils.base64Decode(token),\\n      parts = auth.split(/:/),\\n      username = parts[0],\\n      password = parts[1];\\n    if(incomingUsername === username && incomingPassword === password) {\\n      return \\\"ALLOWED\\\";\\n    } else {\\n      return \\\"DENIED\\\";\\n    }\\n  };\\n\\n  SimpleServer.prototype.requestHandler = function(request,response) {\\n    // Compose the state object\\n    let self = this;\\n    let state = {};\\n    state.wiki = self.wiki;\\n    state.server = self;\\n    state.urlInfo = URL.parse(request.url);\\n    // Find the route that matches this path\\n    const route = self.findMatchingRoute(request,state);\\n    // Check for the username and password if we've got one\\n    const username = self.get(\\\"username\\\"),\\n      password = self.get(\\\"password\\\");\\n    if(username && password) {\\n      // Check they match\\n      if(self.checkCredentials(request,username,password) !== \\\"ALLOWED\\\") {\\n        const servername = state.wiki.getTiddlerText(\\\"$:/SiteTitle\\\") || \\\"TiddlyWiki5\\\";\\n        response.writeHead(401,\\\"Authentication required\\\",{\\n          \\\"WWW-Authenticate\\\": 'Basic realm=\\\"Please provide your username and password to login to ' + servername + '\\\"'\\n        });\\n        response.end();\\n        return;\\n      }\\n    }\\n    // Return a 404 if we didn't find a route\\n    if(!route) {\\n      response.writeHead(404);\\n      response.end();\\n      return;\\n    }\\n    // Set the encoding for the incoming request\\n    // TODO: Presumably this would need tweaking if we supported PUTting binary tiddlers\\n    request.setEncoding(\\\"utf8\\\");\\n    // Dispatch the appropriate method\\n    switch(request.method) {\\n      case \\\"GET\\\": // Intentional fall-through\\n      case \\\"POST\\\": // Intentional fall-through\\n      case \\\"DELETE\\\":\\n        route.handler(request,response,state);\\n        break;\\n      case \\\"PUT\\\":\\n        let data = \\\"\\\";\\n        request.on(\\\"data\\\",function(chunk) {\\n          data += chunk.toString();\\n        });\\n        request.on(\\\"end\\\",function() {\\n          state.data = data;\\n          route.handler(request,response,state);\\n        });\\n        break;\\n    }\\n  };\\n\\n  /*\\n    This function will try the default port, if that port is in use than it will\\n    increment port numbers until it finds an unused port.\\n  */\\n  SimpleServer.prototype.listen = function(port,host) {\\n    let self = this;\\n    const httpServer = http.createServer(this.requestHandler.bind(this));\\n    httpServer.on('error', function (e) {\\n      if($tw.settings['ws-server'].autoIncrementPort || typeof $tw.settings['ws-server'].autoIncrementPort === 'undefined') {\\n        if(e.code === 'EADDRINUSE') {\\n          self.listen(Number(port)+1, host);\\n        }\\n      } else {\\n        $tw.Bob.logger.error(e, {level:0});\\n      }\\n    });\\n    httpServer.listen(port,host, function (e) {\\n      if(!e) {\\n        $tw.httpServerPort = port;\\n        $tw.Bob.logger.log(\\\"Serving on \\\" + host + \\\":\\\" + $tw.httpServerPort, {level:0});\\n        $tw.Bob.logger.log(\\\"(press ctrl-C to exit)\\\", {level:0});\\n        $tw.settings['ws-server'].port = $tw.httpServerPort;\\n      } else {\\n        if($tw.settings['ws-server'].autoIncrementPort || typeof $tw.settings['ws-server'].autoIncrementPort === 'undefined') {\\n          $tw.Bob.logger.log('Port ', port, ' in use, trying ', port+1, {level:1});\\n        } else {\\n          $tw.Bob.logger.error(e, {level:0});\\n        }\\n      }\\n    });\\n    httpServer.on('upgrade', function(request, socket, head) {\\n      if (request.headers.upgrade === 'websocket') {\\n        if (request.url === '/') {\\n          $tw.wss.handleUpgrade(request, socket, head, function(ws) {\\n            $tw.wss.emit('connection', ws, request);\\n          });\\n        } else if (request.url === '/api/federation/socket' && $tw.federationWss && $tw.settings.enableFederation === 'yes') {\\n          $tw.federationWss.handleUpgrade(request, socket, head, function(ws) {\\n            console.log('WSS federation upgrade')\\n            $tw.federationWss.emit('connection', ws, request);\\n          })\\n        }\\n      }\\n    });\\n    return httpServer;\\n  };\\n\\n  function findName(url) {\\n    const pieces = url.split('/')\\n    let name = ''\\n    let settingsObj = $tw.settings.wikis[pieces[0]]\\n    if(settingsObj) {\\n      name = pieces[0]\\n    }\\n    for (let i = 1; i < pieces.length; i++) {\\n      if(settingsObj) {\\n        if(typeof settingsObj[pieces[i]] === 'object') {\\n          name = name + '/' + pieces[i]\\n          settingsObj = settingsObj[pieces[i]]\\n        } else if(typeof settingsObj[pieces[i]] === 'string') {\\n          name = name + '/' + pieces[i]\\n          break\\n        } else {\\n          break\\n        }\\n      }\\n    }\\n    if (name === '') {\\n      //name = 'RootWiki'\\n    }\\n    return name\\n  }\\n\\n  const Command = function(params,commander,callback) {\\n    this.params = params;\\n    this.commander = commander;\\n    this.callback = callback;\\n    // Commands that are just for the server\\n    $tw.ServerSide = require('$:/plugins/OokTech/Bob/ServerSide.js');\\n\\n    // Set up server\\n    $tw.httpServer = new SimpleServer({\\n      wiki: this.commander.wiki\\n    });\\n    // Add route handlers\\n    $tw.modules.forEachModuleOfType(\\\"serverroute\\\", function(title, routeDefinition) {\\n      $tw.httpServer.addRoute(routeDefinition);\\n    });\\n    // Add placeholders for other routes that load the wikis associated with\\n    // each route.\\n    $tw.httpServer.addOtherRoutes();\\n  };\\n\\n  /*\\n    Walk through the $tw.settings.wikis object and add a route for each listed wiki. The routes should make the wiki boot if it hasn't already.\\n  */\\n  SimpleServer.prototype.addOtherRoutes = function () {\\n    addRoutesThing($tw.settings.wikis, '');\\n  }\\n\\n\\n\\n  function addRoutesThing(inputObject, prefix) {\\n    $tw.modules.forEachModuleOfType(\\\"wikiroute\\\", function(title, routeDefinition) {\\n      $tw.httpServer.addRoute(routeDefinition('RootWiki'));\\n    });\\n    if(typeof inputObject === 'object') {\\n      Object.keys(inputObject).forEach(function (wikiName) {\\n        if(typeof inputObject[wikiName] === 'string') {\\n          let fullName = wikiName;\\n          if(prefix !== '') {\\n            if(wikiName !== '__path') {\\n              fullName = prefix + '/' + wikiName;\\n            } else {\\n              fullName = prefix;\\n            }\\n          }\\n\\n          $tw.modules.forEachModuleOfType(\\\"wikiroute\\\", function(title, routeDefinition) {\\n            $tw.httpServer.addRoute(routeDefinition(fullName));\\n          });\\n\\n          $tw.Bob.logger.log(\\\"Added route \\\" + String(new RegExp('^\\\\/' + fullName + '\\\\/?$')), {level:1})\\n        } else {\\n          // recurse!\\n          // This needs to be a new variable or else the rest of the wikis at\\n          // this level will get the longer prefix as well.\\n          const nextPrefix = prefix===''?wikiName:prefix + '/' + wikiName;\\n          addRoutesThing(inputObject[wikiName], nextPrefix);\\n        }\\n      })\\n    }\\n  }\\n\\n  function createSaverServer() {\\n    $tw.settings.saver = $tw.settings.saver || {};\\n    const port = $tw.settings.saver.port || 61192;\\n    let host = '127.0.0.1';\\n    if ($tw.settings.saver.host && $tw.settings.acceptance === 'I Will Not Get Tech Support For This') {\\n      host = $tw.settings.saver.host;\\n    }\\n    function saverHandler(request, response) {\\n      let body = '';\\n      response.writeHead(200, {\\\"Content-Type\\\": \\\"application/json\\\", \\\"Access-Control-Allow-Origin\\\": \\\"*\\\", \\\"Access-Control-Allow-Headers\\\": \\\"Content-Type, x-file-path, x-saver-key\\\"});\\n      if (request.url.endsWith('/save')) {\\n        request.on('data', function(chunk){\\n          body += chunk;\\n          // We limit this to 100mb, this could change if people have gigantic\\n          // wkis.\\n          if(body.length > 100e6) {\\n            response.writeHead(413, {'Content-Type': 'text/plain'}).end();\\n            request.connection.destroy();\\n          }\\n        });\\n        request.on('end', function() {\\n          // The body should be the html text of a wiki\\n          body = body.replace(/^message=/, '');\\n          const responseData = {'ok':'no'};\\n          const filepath = request.headers['x-file-path'];\\n          const key = request.headers['x-saver-key'];\\n          const match = (key === $tw.settings.saver.key) || (typeof $tw.settings.saver.key === 'undefined');\\n          if (typeof body === 'string' && body.length > 0 && filepath && match) {\\n            // Write the file\\n            const fs = require('fs');\\n            const path = require('path');\\n            if (['.html', '.htm', '.hta'].indexOf(path.extname(filepath)) === -1) {\\n              response.writeHead(403, {'Content-Type': 'text/plain'}).end();\\n            }\\n            // Make sure that the path exists, if so save the wiki file\\n            fs.writeFile(path.resolve(filepath),body,{encoding: \\\"utf8\\\"},function (err) {\\n              if(err) {\\n                $tw.Bob.logger.error(err, {level:1});\\n                responseData.error = err;\\n              } else {\\n                $tw.Bob.logger.log('saved file', filepath, {level:2});\\n                responseData.ok = 'yes';\\n              }\\n              response.end(JSON.stringify(responseData));\\n            });\\n          } else {\\n            response.end(JSON.stringify(responseData));\\n          }\\n        });\\n      } else if (request.url.endsWith('/check')) {\\n        response.end('{\\\"ok\\\":\\\"yes\\\"}')\\n      }\\n    }\\n    const saverServer = http.createServer(saverHandler);\\n    saverServer.on('error', function (e) {\\n      if($tw.settings['ws-server'].autoIncrementPort || typeof $tw.settings['ws-server'].autoIncrementPort === 'undefined') {\\n        if(e.code === 'EADDRINUSE') {\\n          $tw.Bob.logger.error('Port conflict with the saver server, do you have Bob running already?', e,{level:0})\\n        }\\n      } else {\\n        $tw.Bob.logger.error(e, {level:0});\\n      }\\n    });\\n    saverServer.listen(port, host, function(err) {\\n      if (err) {\\n        console.log('Bob saver server error!', err);\\n      } else {\\n        console.log('Bob saver server running on', host + ':' + port);\\n      }\\n    })\\n  }\\n\\n  Command.prototype.execute = function() {\\n    $tw.Bob = $tw.Bob || {};\\n    $tw.Bob.Wikis = $tw.Bob.Wikis || {};\\n    if(!$tw.boot.wikiTiddlersPath) {\\n      $tw.utils.warning(\\\"Warning: Wiki folder '\\\" + $tw.boot.wikiPath + \\\"' does not exist or is missing a tiddlywiki.info file\\\");\\n    }\\n    const port = $tw.settings['ws-server'].port || \\\"8080\\\",\\n      rootTiddler = $tw.settings['ws-server'].rootTiddler || \\\"$:/core/save/all\\\",\\n      renderType = $tw.settings['ws-server'].renderType || \\\"text/plain\\\",\\n      serveType = $tw.settings['ws-server'].serveType || \\\"text/html\\\",\\n      username = $tw.settings['ws-server'].username,\\n      password = $tw.settings['ws-server'].password,\\n      host = $tw.settings['ws-server'].host || \\\"127.0.0.1\\\",\\n      pathprefix = $tw.settings['ws-server'].pathprefix;\\n    $tw.httpServer.set({\\n      rootTiddler: rootTiddler,\\n      renderType: renderType,\\n      serveType: serveType,\\n      username: username,\\n      password: password,\\n      pathprefix: pathprefix\\n    });\\n\\n    if ($tw.settings.enableSaver !== 'no') {\\n      // Create single file saver server\\n      createSaverServer()\\n    }\\n\\n    const basePath = $tw.ServerSide.getBasePath();\\n    $tw.settings.pluginsPath = $tw.settings.pluginsPath || './Plugins';\\n    if(typeof $tw.settings.pluginsPath === 'string') {\\n      const resolvedpluginspath = path.resolve(basePath, $tw.settings.pluginsPath);\\n      if(process.env[\\\"TIDDLYWIKI_PLUGIN_PATH\\\"] !== undefined && process.env[\\\"TIDDLYWIKI_PLUGIN_PATH\\\"] !== '') {\\n        process.env[\\\"TIDDLYWIKI_PLUGIN_PATH\\\"] = process.env[\\\"TIDDLYWIKI_PLUGIN_PATH\\\"] + path.delimiter + resolvedpluginspath;\\n      } else {\\n        process.env[\\\"TIDDLYWIKI_PLUGIN_PATH\\\"] = resolvedpluginspath;\\n      }\\n    }\\n    $tw.settings.themesPath = $tw.settings.themesPath || './Themes';\\n    if(typeof $tw.settings.themesPath === 'string') {\\n      const resolvedthemespath = path.resolve(basePath, $tw.settings.themesPath);\\n      if(process.env[\\\"TIDDLYWIKI_THEME_PATH\\\"] !== undefined && process.env[\\\"TIDDLYWIKI_THEME_PATH\\\"] !== '') {\\n        process.env[\\\"TIDDLYWIKI_THEME_PATH\\\"] = process.env[\\\"TIDDLYWIKI_THEME_PATH\\\"] + path.delimiter + resolvedthemespath;\\n      } else {\\n        process.env[\\\"TIDDLYWIKI_THEME_PATH\\\"] = resolvedthemespath;\\n      }\\n    }\\n    $tw.settings.editionsPath = $tw.settings.editionsPath || './Editions';\\n    if(typeof $tw.settings.editionsPath === 'string') {\\n      const resolvededitionspath = path.resolve(basePath, $tw.settings.editionsPath)\\n      if(process.env[\\\"TIDDLYWIKI_EDITION_PATH\\\"] !== undefined && process.env[\\\"TIDDLYWIKI_EDITION_PATH\\\"] !== '') {\\n        process.env[\\\"TIDDLYWIKI_EDITION_PATH\\\"] = process.env[\\\"TIDDLYWIKI_EDITION_PATH\\\"] + path.delimiter + resolvededitionspath;\\n      } else {\\n        process.env[\\\"TIDDLYWIKI_EDITION_PATH\\\"] = resolvededitionspath;\\n      }\\n    }\\n    $tw.settings.languagesPath = $tw.settings.languagesPath || './Languages';\\n    if(typeof $tw.settings.languagesPath === 'string') {\\n      const resolvedlanguagespath = path.resolve(basePath, $tw.settings.languagesPath)\\n      if(process.env[\\\"TIDDLYWIKI_LANGUAGE_PATH\\\"] !== undefined && process.env[\\\"TIDDLYWIKI_LANGUAGE_PATH\\\"] !== '') {\\n        process.env[\\\"TIDDLYWIKI_LANGUAGE_PATH\\\"] = process.env[\\\"TIDDLYWIKI_LANGUAGE_PATH\\\"] + path.delimiter + resolvedlanguagespath;\\n      } else {\\n        process.env[\\\"TIDDLYWIKI_LANGUAGE_PATH\\\"] = resolvedlanguagespath;\\n      }\\n    }\\n\\n    const bobVersion = $tw.wiki.getTiddler('$:/plugins/OokTech/Bob').fields.version\\n    $tw.Bob.logger.log('TiddlyWiki version', $tw.version, 'with Bob version', bobVersion, {level:0})\\n\\n    /*\\n      This function checks to see if the current action is allowed with the access\\n      level given by the supplied token\\n\\n      If access controls are not enabled than this just returns true and\\n      everything is allowed.\\n\\n      If access controls are enabled than this needs to check the token to get\\n      the list of wikis and actions that are allowed to it and if the action is\\n      allowed for the wiki return true, otherwise false.\\n    */\\n    $tw.Bob.AccessCheck = function(wikiName, token, action) {\\n      return true;\\n    }\\n\\n    const nodeServer = $tw.httpServer.listen(port,host);\\n\\n    // Get the ip address to display to make it easier for other computers to\\n    // connect.\\n    const ip = require('$:/plugins/OokTech/Bob/External/IP/ip.js');\\n    const ipAddress = ip.address();\\n    $tw.settings.serverInfo = {\\n      ipAddress: ipAddress,\\n      port: port,\\n      host: host\\n    };\\n\\n    $tw.hooks.invokeHook(\\\"th-server-command-post-start\\\",$tw.httpServer,nodeServer,\\\"tiddlywiki\\\");\\n    return null;\\n  };\\n\\n  exports.Command = Command;\\n}\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"command\"\n        },\n        \"$:/plugins/OokTech/Bob/macros/getSetting.js\": {\n            \"title\": \"$:/plugins/OokTech/Bob/macros/getSetting.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"macro\",\n            \"text\": \"/*\\nMacro to return the value of a setting in the settings json structure\\n\\nThis is needed because tiddlywiki doesn't support nested json objects and\\nthe settings structure is faking it.\\n\\nThis is done relative to the tiddler given by the root parameter.\\n\\nTo fit with tiddlywiki as much as possible each level is separated by ##\\n\\n{\\n  First: {\\n    Second: {\\n      Item: Value\\n    }\\n  }\\n}\\n\\nGiven the above JSON you could use this:\\n\\n<<getSetting key=\\\"First##Second##Item\\\">>\\n\\nwhich would return Value\\n\\nNote that this returns the first leaf reached. If you add extra levels that\\ndon't exit to the end of the key they are ignored. So in the example if you\\nused First##Second##Item##this##changes##nothing than it would work the same\\nway.\\n\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*\\nInformation about this macro\\n*/\\n\\nexports.name = \\\"getSetting\\\";\\n\\nexports.params = [\\n\\t{name: \\\"key\\\"},\\n  {name: \\\"root\\\"}\\n];\\n\\n/*\\nRun the macro\\n*/\\nexports.run = function(key, root) {\\n  if(!key) {\\n    // If no key is given return an empty string.\\n    return \\\"\\\";\\n  } else {\\n    // Split the key up into it separate parts.\\n    var keys = key.split('##');\\n  }\\n  // If no root is given use the default.\\n  if(!root) {\\n    root = \\\"$:/WikiSettings/split\\\";\\n  }\\n  var tiddler = $tw.wiki.getTiddler(root);\\n  if(!tiddler) {\\n    // if the root doesn't exist return an empty string.\\n    return \\\"\\\";\\n  }\\n  // Walk through the settings to find the desired key and return it.\\n  return walk(keys, tiddler);\\n};\\n\\n/*\\nThis function walks though each property in the json from the tiddler text and\\neither returns the value indicated by the next key or, if the value is a\\ntiddler title in the correct form, calls itself again with the next key and\\ntiddler.\\n*/\\nfunction walk(keys, tiddler) {\\n  try {\\n    var currentLevel = JSON.parse(tiddler.fields.text);\\n    if(typeof currentLevel[keys[0]] === 'string') {\\n      // If the current level is a tiddler holding the next nested object pass\\n      // that into the walk function, otherwise return the value of the key at\\n      // this level.\\n      if(currentLevel[keys[0]].startsWith(tiddler.fields.title)) {\\n        var newTiddler = $tw.wiki.getTiddler(currentLevel[keys[0]]);\\n        keys.shift();\\n        return walk(keys, newTiddler);\\n      } else {\\n        return currentLevel[keys[0]];\\n      }\\n    } else {\\n      // If we run into an invalid key, or one that doesn't exist return an\\n      // empty string.\\n      return \\\"\\\";\\n    }\\n  } catch (e) {\\n    // If parsing fails return an empty string.\\n    return \\\"\\\";\\n  }\\n}\\n\\n})();\"\n        },\n        \"$:/plugins/OokTech/Bob/readme\": {\n            \"title\": \"$:/plugins/OokTech/Bob/readme\",\n            \"caption\": \"readme\",\n            \"text\": \"! Connecting other computers to the wiki\\n\\nThe wiki server ip address and port is:\\n\\n<pre>{{$:/ServerIP}}:{{$:/ServerIP!!port}}</pre>\\n\\nto connect to this wiki from another computer on the same network enter the\\nabove into the address bar of a browser.\\n\\n! Configuration\\n\\nYou can configure the plugin (and possibly other things in the future) using\\nthe `Bob Settings` tab in the [[$:/ControlPanel]].\\n\\nThese settings are available to the node process in the $tw.settings object.\\n\\nAfter changing any of the settings they are not saved in a way that will change\\nanything until you click the `Update Settings` button. Note that some settings\\nmay not take effect until you reset the server.\\n\\nConfiguring the host is done in the `ws-server` section. You can set the host,\\nport username and password for the wiki there (see [[a note about ports|$:/plugins/OokTech/Bob/A note about ports]]).\\nSome of these settings may not always be updated the way you expect when\\nresetting the server using the node message. I am not exactly sure what is\\ndifferent or why.\\n\\nThe scripts that you can run using the `runScript` websocket message are listed\\nin the `scripts` section. You can also add or modify the scripts here. See [[running scripts using websocket messages|$:/plugins/OokTech/Bob/Running Scripts Using Websocket Messages]].\\n\\nThe other wikis you can start from this wiki are listed in the `wikis` section.\\nYou can add new wikis here as well. See [[starting other wikis from within a wiki|$:/plugins/OokTech/Bob/Starting Other Wikis]].\\n\\n! Other Documentation\\n\\n<$list\\n  filter='[all[tiddlers+shadows]tag[Bob Documentation]]'\\n>\\n  <$link\\n    to=<<currentTiddler>>\\n  >\\n    <$view\\n      field='caption'\\n    >\\n      <$view\\n        field='title'\\n      />\\n    </$view>\\n  </$link> - <$view field='description'/>\\n  <br>\\n</$list>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/AddRemoteServerTemplate\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/AddRemoteServerTemplate\",\n            \"text\": \"Remote URL:\\n\\n<$edit-text\\n  tiddler='$:/state/Federation/AddServer'\\n  field='remote_url'\\n  cass='tc-edit-texteditor'\\n/>\\n\\n<$button>\\n  Try Connecting\\n  <$action-websocketmessage\\n    $type='openRemoteConnection'\\n    url={{$:/state/Federation/AddServer!!remote_url}}\\n  />\\n</$button>\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/AvailableChatsListingTemplate\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/AvailableChatsListingTemplate\",\n            \"text\": \"<tr>\\n  <th>\\n    <$view\\n      field='title'\\n    />\\n  </th>\\n  <td>\\n    <$view\\n      field='public'\\n    >\\n      No\\n    </$view>\\n  </td>\\n  <td>\\n    <$button>\\n      Join\\n    </$button>\\n  </td>\\n</tr>\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/AvailableWikisListingTemplate\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/AvailableWikisListingTemplate\",\n            \"text\": \"<tr>\\n  <th>\\n    <$button\\n      class='tc-btn-invisible'\\n    >\\n      <$list\\n        filter='[<currentTiddler>!field:edit[edit]]'\\n        emptyMessage=\\\"\\\"\\\"\\n        {{$:/core/images/save-button}}\\n        <$action-setfield\\n          edit=''\\n        />\\n        <$action-websocketmessage\\n          $type='updateFederatedConnectionInfo'\\n          $tiddler=<<currentTiddler>>\\n        />\\n        \\\"\\\"\\\"\\n        variable=unused\\n      >\\n        {{$:/core/images/edit-button}}\\n        <$action-setfield\\n          edit='edit'\\n        />\\n      </$list>\\n    </$button>\\n  </th>\\n  <th>\\n    <$view\\n      field='name'\\n    >\\n      <$view\\n        field='title'\\n      />\\n    </$view>\\n  </th>\\n  <td>\\n    <$list\\n      filter='[<currentTiddler>!field:edit[edit]]'\\n      emptyMessage=\\\"\\\"\\\"\\n      <$edit-text\\n        field='local_name'\\n        default={{!!name}}\\n      />\\n      \\\"\\\"\\\"\\n      variable=unused\\n    >\\n      <$view\\n        field='local_name'\\n      >\\n        <$view\\n          field='name'\\n        >\\n          --\\n        </$view>\\n      </$view>\\n    </$list>\\n  </td>\\n  <td>\\n    <$view\\n      field='public'\\n    >\\n      No\\n    </$view>\\n  </td>\\n  <td>\\n    <$list\\n      filter='[<currentTiddler>!field:edit[edit]]'\\n      emptyMessage=\\\"\\\"\\\"\\n      <$edit-text\\n        field='sync_filter'\\n        default=''\\n      />\\n      \\\"\\\"\\\"\\n      variable=unused\\n    >\\n      <$view\\n        field='sync_filter'\\n      >\\n        --\\n      </$view>\\n    </$list>\\n  </td>\\n  <td>\\n    <$list\\n      filter='[<currentTiddler>!field:edit[edit]]'\\n      emptyMessage=\\\"\\\"\\\"\\n        <$select\\n          field='sync_type'\\n          default='none'\\n        >\\n          <option\\n            value=''\\n          >\\n            None\\n          </option>\\n          <option\\n            value='bidirectional'\\n          >\\n            Bidirectional\\n          </option>\\n          <option\\n            value='pull'\\n          >\\n            Pull Only\\n          </option>\\n          <option\\n            value='push'\\n          >\\n            Push Only\\n          </option>\\n        </$select>\\n      \\\"\\\"\\\"\\n      variable=unused\\n    >\\n      <$view\\n        field='sync_type'\\n      >\\n        None\\n      </$view>\\n    </$list>\\n  </td>\\n  <td>\\n    <$list\\n      filter='[<currentTiddler>!field:edit[edit]]'\\n      emptyMessage=\\\"\\\"\\\"\\n      <$select\\n        field='conflict_type'\\n        default='localWins'\\n      >\\n        <option\\n          value='newestWins'\\n        >\\n          Newest Wins\\n        </option>\\n        <option\\n          value='oldestWins'\\n        >\\n          Oldest Wins\\n        </option>\\n        <option\\n          value='localWins'\\n        >\\n          Local Wins\\n        </option>\\n        <option\\n          value='remoteWins'\\n        >\\n          Remote Wins\\n        </option>\\n        <option\\n          value='manual'\\n        >\\n          Manual\\n        </option>\\n      </$select>\\n      \\\"\\\"\\\"\\n      variable=unused\\n    >\\n      <$view\\n        field='conflict_type'\\n      >\\n        Local Wins\\n      </$view>\\n    </$list>\\n  </td>\\n  <td>\\n  <$list\\n    filter='[<currentTiddler>!field:edit[edit]]'\\n    emptyMessage=\\\"\\\"\\\"\\n    <$select\\n      field='auto_sync'\\n      default='no'\\n    >\\n      <option\\n        value='yes'\\n      >\\n        Yes\\n      </option>\\n      <option\\n        value='no'\\n      >\\n        No\\n      </option>\\n    </$select>\\n    \\\"\\\"\\\"\\n    variable=unused\\n  >\\n    <$view\\n      field='auto_sync'\\n    >\\n      No\\n    </$view>\\n  </$list>\\n  </td>\\n  <td>\\n    <$button>\\n      Sync Now\\n      <$action-websocketmessage\\n        $type='sendRemoteMessage'\\n        $server={{{ [{$:/state/Federation/SelectedRemoteServer}get[name]] }}}\\n        $message=\\\"requestHashes\\\"\\n        $tiddler=<<currentTiddler>>\\n        filter={{!!sync_filter}}\\n        fromWiki={{{ [<currentTiddler>split[/]nth[6]] }}}\\n      />\\n    </$button>\\n  </td>\\n</tr>\\n\"\n        },\n        \"$:/plugins/Bob/template/ConflictTemplate\": {\n            \"title\": \"$:/plugins/Bob/template/ConflictTemplate\",\n            \"list-after\": \"$:/core/ui/ViewTemplate/tags\",\n            \"tags\": \"$:/tags/ViewTemplate\",\n            \"text\": \"<$list\\n  filter='[is[current]addprefix[$:/state/Bob/Conflicts/]has[text]]'\\n>\\n  There are syncing conflicts with this tiddler!!\\n  <br>\\n  <$button>\\n    Open Other Version\\n    <$action-navigate\\n      $to=<<currentTiddler>>\\n    />\\n  </$button>\\n  <br>\\n\\n  <$button>\\n    Use This Version\\n    <$action-deletetiddler\\n      $tiddler=<<currentTiddler>>\\n    />\\n  </$button>\\n  <$set\\n    name=OriginalTitle\\n    filter='[is[current]removeprefix[$:/state/Bob/Conflicts/]has[text]]'\\n    select='0'\\n  >\\n    <$button>\\n      Use Other Version\\n      <$action-setfield\\n        $tiddler=<<currentTiddler>>\\n        $field='title'\\n        $value=<<OriginalTitle>>\\n      />\\n      <$action-deletetiddler\\n        $tiddler=<<currentTiddler>>\\n      />\\n    </$button>\\n  </$set>\\n</$list>\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/EditableJSONViewTemplate\": {\n            \"title\": \"$:/plugins/OokTech/Bob/EditableJSONViewTemplate\",\n            \"text\": \"\\\\define thisEditingState() $:/state/$(currentTiddler)$/$(item)$/editing\\n\\n\\\\define thisNewItemState() $:/state/$(currentTiddler)$/$(item)$/newItem\\n\\n\\\\define thisNewItemValues() $:/state/$(currentTiddler)$/$(item)$/values\\n\\n\\\\define EditButton()\\n<$reveal\\n  type='nomatch'\\n  state=<<thisEditingState>>\\n  text='editing'\\n>\\n  <$button\\n    class='tc-btn-invisible'\\n  >\\n    \\\"<$view index=<<item>>/>\\\"\\n    <$reveal type='match'\\n      state='$:/state/Bob/EditManualSettings'\\n      text='true'\\n      tag='span'\\n    >\\n      <$action-setfield\\n        $tiddler=<<thisEditingState>>\\n        text=editing\\n      />\\n      {{$:/core/images/edit-button}}\\n    </$reveal>\\n  </$button>\\n</$reveal>\\n<$reveal\\n  type='match'\\n  state=<<thisEditingState>>\\n  text='editing'\\n>\\n  <$edit-text\\n    class='tc-edit-texteditor'\\n    tiddler=<<currentTiddler>>\\n    index=<<item>>\\n    tag=input\\n  />\\n  <$button\\n    tooltip='Finish Editing'\\n  >\\n    Done\\n    <$action-setfield\\n      $tiddler=<<thisEditingState>>\\n      text=''\\n    />\\n    <$action-deletetiddler\\n      $tiddler=<<thisEditingState>>\\n    />\\n  </$button>\\n  <$button\\n    class='tc-btn-invisible'\\n    tooltip='Delete Field'\\n  >\\n    {{$:/core/images/delete-button}}\\n    <$action-setfield\\n      $tiddler=<<currentTiddler>>\\n      $index=<<item>>\\n    />\\n  </$button>\\n</$reveal>\\n\\\\end\\n\\n{\\n<$reveal type='match'\\n  state='$:/state/Bob/EditManualSettings'\\n  text='true'\\n>\\n  <$list\\n    filter='[<currentTiddler>!title[$:/WikiSettings/split]]'\\n  >\\n    <$button\\n      class='tc-btn-invisible'\\n      tooltip='Delete Section'\\n    >\\n      <$action-deletetiddler\\n        $tiddler=<<currentTiddler>>\\n      />\\n      {{$:/core/images/delete-button}}\\n    </$button>\\n  </$list>\\n</$reveal>\\n\\n<ul>\\n  <$list\\n    filter='[<currentTiddler>indexes[]butlast[]]'\\n    variable='item'\\n  >\\n    \\\"<$view tiddler=<<item>> field=title/>\\\":\\n    <$list\\n      filter='[<currentTiddler>getindex<item>type[application/json]]'\\n      emptyMessage=\\\"\\\"\\\"<<EditButton>>,\\\"\\\"\\\"\\n    >\\n      {{||$:/plugins/OokTech/Bob/EditableJSONViewTemplate}},\\n    </$list>\\n    <br>\\n  </$list>\\n  <$list\\n    filter='[<currentTiddler>indexes[]last[]]'\\n    variable='item'\\n  >\\n    \\\"<$view tiddler=<<item>> field=title/>\\\":\\n    <$list\\n      filter='[<currentTiddler>getindex<item>type[application/json]]'\\n      emptyMessage=\\\"\\\"\\\"<<EditButton>>\\\"\\\"\\\"\\n    >\\n      {{||$:/plugins/OokTech/Bob/EditableJSONViewTemplate}}\\n    </$list>\\n    <br>\\n  </$list>\\n  <$reveal\\n    type='nomatch'\\n    state=<<thisNewItemState>>\\n    text=editing\\n  >\\n    <$reveal type='match'\\n      state='$:/state/Bob/EditManualSettings'\\n      text='true'\\n      tag='span'\\n    >\\n      <$button\\n        tooltip='Add Property'\\n      >\\n        {{$:/core/images/new-button}}\\n        <$action-setfield\\n          $tiddler=<<thisNewItemState>>\\n          text=editing\\n          item_type=Field\\n        />\\n      </$button>\\n    </$reveal>\\n  </$reveal>\\n  <$reveal\\n    type='match'\\n    state=<<thisNewItemState>>\\n    text=editing\\n  >\\n    <$edit-text\\n      tiddler=<<thisNewItemValues>>\\n      field='new_name'\\n    />:\\n    <$radio\\n      tiddler=<<thisNewItemState>>\\n      field=item_type\\n      value='Object'\\n    >\\n      Object\\n    </$radio>\\n    <$radio\\n      tiddler=<<thisNewItemState>>\\n      field=item_type\\n      value='Field'\\n    >\\n      Field\\n    </$radio>\\n    <$list\\n      filter='[<thisNewItemState>item_type[Field]]'\\n      variable=dummy\\n      emptyMessage=\\\"<br>\\\"\\n    >\\n      <$edit-text\\n        tiddler=<<thisNewItemValues>>\\n        field='new_value'\\n        class='tc-edit-texteditor'\\n      />\\n    </$list>\\n    <$button\\n      class='tc-btn-invisible'\\n      tooltip='Save'\\n    >\\n      {{$:/core/images/save-button}}\\n      <$set\\n        name=CurrentLevel\\n        value=<<currentTiddler>>\\n      >\\n        <$list\\n          filter='[<thisNewItemState>item_type[Object]]'\\n          variable=unused\\n          emptyMessage=\\\"\\\"\\\"\\n          <$tiddler\\n            tiddler=<<thisNewItemValues>>\\n          >\\n          <$action-setfield\\n            $tiddler=<<CurrentLevel>>\\n            $index={{!!new_name}}\\n            $value={{!!new_value}}\\n          />\\n          </$tiddler>\\\"\\\"\\\"\\n        >\\n          <$tiddler\\n            tiddler=<<thisNewItemValues>>\\n          >\\n            <$list\\n              filter='[<CurrentLevel>addsuffix[/]addsuffix{!!new_name}]'\\n              variable='NewName'\\n            >\\n              <$action-setfield\\n                $tiddler=<<NewName>>\\n                type='application/json'\\n                text='{}'\\n              />\\n              <$action-setfield\\n                $tiddler=<<CurrentLevel>>\\n                $index={{!!new_name}}\\n                $value=<<NewName>>\\n              />\\n            </$list>\\n          </$tiddler>\\n        </$list>\\n      </$set>\\n      <$action-setfield\\n        $tiddler=<<thisNewItemState>>\\n        text=''\\n      />\\n      <$action-deletetiddler\\n        $tiddler=<<thisNewItemState>>\\n      />\\n      <$action-setfield\\n        $tiddler=<<thisNewItemValues>>\\n        text=''\\n      />\\n      <$action-deletetiddler\\n        $tiddler=<<thisNewItemValues>>\\n      />\\n    </$button>\\n    <$button\\n      class='tc-btn-invisible'\\n      tooltip='Cancel'\\n    >\\n      {{$:/core/images/cancel-button}}\\n      <$action-setfield\\n        $tiddler=<<thisNewItemState>>\\n        text=''\\n      />\\n      <$action-deletetiddler\\n        $tiddler=<<thisNewItemState>>\\n      />\\n    </$button>\\n  </$reveal>\\n</ul>\\n}\\n\"\n        },\n        \"$:/plugins/OokTech/Bob/Federation/RemoteServerTemplate\": {\n            \"title\": \"$:/plugins/OokTech/Bob/Federation/RemoteServerTemplate\",\n            \"text\": \"Connection Status:\\n<$list\\n  filter='[field:connection_status[connected]]'\\n  emptyMessage=\\\"\\\"\\\"\\n  Disconnected\\n  <$button>\\n    Connect\\n  </$button>\\n  \\\"\\\"\\\"\\n  variable=unused\\n>\\n  Connected\\n  <$button>\\n    Disconnect\\n  </$button>\\n</$list>\\n\\n<$list\\n  filter='[field:allows_login[yes]]'\\n  variable=unused\\n  emptyMessage='Server does not allow login'\\n>\\n  //Login Interface Here//\\n</$list>\\n\\n!! Available Wikis on <$view field='name'><$view field='title'/></$view>\\n\\n<table>\\n  <tr>\\n    <th>\\n      Edit\\n    </th>\\n    <th>\\n      Remote Wiki Name\\n    </th>\\n    <th>\\n      Local Wiki Name\\n    </th>\\n    <th>\\n      Pubilc\\n    </th>\\n    <th>\\n      Sync Filter\\n    </th>\\n    <th>\\n      Sync Type\\n    </th>\\n    <th>\\n      Conflict Handling\\n    </th>\\n    <th>\\n      Auto Sync\\n    </th>\\n    <th>\\n      Sync Now\\n    </th>\\n  </tr>\\n  <$list\\n    filter='[enlist{!!available_wikis}addprefix[/wikis/]addprefix<currentTiddler>]'\\n    emptyMessage='<tr><td colspan=8>No Wikis Available</td></tr>'\\n  >\\n    {{||$:/plugins/OokTech/Bob/Federation/AvailableWikisListingTemplate}}\\n  </$list>\\n</table>\\n\\n!! Available Chats\\n\\n<table>\\n  <tr>\\n    <th>\\n      Chat Name\\n    </th>\\n    <th>\\n      Public?\\n    </th>\\n    <th>\\n    </th>\\n  </tr>\\n  <$list\\n    filter='[enlist{!!available_chats}addprefix[/chats/]addprefix<currentTiddler>]'\\n    emptyMessage='No Chats Available'\\n  >\\n    {{||$:/plugins/OokTech/Bob/Federation/AvailableChatsListingTemplate}}\\n  </$list>\\n</table>\\n\"\n        }\n    }\n}"}